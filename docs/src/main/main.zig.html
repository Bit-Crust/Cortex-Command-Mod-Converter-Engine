<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>main.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAPNJREFUeNpi/P//PwMlgOXHUjly9E0G4hwgZmQiQZMqEK8H4v9QzUEgQSaoADK+zhH9iAGL+C0gDoAaNg9mGLoLfgA1awK9hS9gzgJxA9RQBmQDrgMxJzRMGKE4HYj/Ial5A8QmQLwCJoBsgBYW2+TR1ChDaWt4LOBxKsi/VUh8XiD+gq4IVyzwQAMJBoKwacZlAB8Qf0bi96IZhtOAe1D6LpqaEiz6rmEzQAeIzwGxCJpieFqApo/vQKyJboAaEBsAsSEupwI1MwKjGBTVHOhegMX5UajYRqiBjMgYmj400cVh0XgTiKdC0zhJgJHS7AwQYABm9EAdCKrEfAAAAABJRU5ErkJggg=="/>
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);</span>
<span class="line" id="L2"><span class="tok-kw">const</span> ziplib = <span class="tok-builtin">@cImport</span>(<span class="tok-builtin">@cInclude</span>(<span class="tok-str">&quot;zip.h&quot;</span>));</span>
<span class="line" id="L3"></span>
<span class="line" id="L4"><span class="tok-kw">const</span> default_max_load_percentage = std.hash_map.default_max_load_percentage;</span>
<span class="line" id="L5"><span class="tok-kw">const</span> default_max_value_len = std.json.default_max_value_len;</span>
<span class="line" id="L6"><span class="tok-kw">const</span> MAX_PATH_BYTES = std.fs.MAX_PATH_BYTES;</span>
<span class="line" id="L7"><span class="tok-kw">const</span> page_allocator = std.heap.page_allocator;</span>
<span class="line" id="L8"></span>
<span class="line" id="L9"><span class="tok-kw">const</span> Allocator = std.mem.Allocator;</span>
<span class="line" id="L10"><span class="tok-kw">const</span> ArenaAllocator = std.heap.ArenaAllocator;</span>
<span class="line" id="L11"><span class="tok-kw">const</span> ArrayList = std.ArrayList;</span>
<span class="line" id="L12"><span class="tok-kw">const</span> HashMap = std.hash_map.HashMap;</span>
<span class="line" id="L13"><span class="tok-kw">const</span> MultiArrayList = std.MultiArrayList;</span>
<span class="line" id="L14"><span class="tok-kw">const</span> Scanner = std.json.Scanner;</span>
<span class="line" id="L15"><span class="tok-kw">const</span> StringHashMap = std.hash_map.StringHashMap;</span>
<span class="line" id="L16"></span>
<span class="line" id="L17"><span class="tok-kw">const</span> allocPrint = std.fmt.allocPrint;</span>
<span class="line" id="L18"><span class="tok-kw">const</span> basename = std.fs.path.basename;</span>
<span class="line" id="L19"><span class="tok-kw">const</span> bufferedReader = std.io.bufferedReader;</span>
<span class="line" id="L20"><span class="tok-kw">const</span> bufferedWriter = std.io.bufferedWriter;</span>
<span class="line" id="L21"><span class="tok-kw">const</span> copyFileAbsolute = std.fs.copyFileAbsolute;</span>
<span class="line" id="L22"><span class="tok-kw">const</span> endsWith = std.mem.endsWith;</span>
<span class="line" id="L23"><span class="tok-kw">const</span> eql = std.mem.eql;</span>
<span class="line" id="L24"><span class="tok-kw">const</span> expectEqualStrings = std.testing.expectEqualStrings;</span>
<span class="line" id="L25"><span class="tok-kw">const</span> extension = std.fs.path.extension;</span>
<span class="line" id="L26"><span class="tok-kw">const</span> fabs = std.math.fabs;</span>
<span class="line" id="L27"><span class="tok-kw">const</span> fmtSliceEscapeUpper = std.fmt.fmtSliceEscapeUpper;</span>
<span class="line" id="L28"><span class="tok-kw">const</span> indexOfDiff = std.mem.indexOfDiff;</span>
<span class="line" id="L29"><span class="tok-kw">const</span> join = std.fs.path.join;</span>
<span class="line" id="L30"><span class="tok-kw">const</span> makeDirAbsolute = std.fs.makeDirAbsolute;</span>
<span class="line" id="L31"><span class="tok-kw">const</span> maxInt = std.math.maxInt;</span>
<span class="line" id="L32"><span class="tok-kw">const</span> parseFloat = std.fmt.parseFloat;</span>
<span class="line" id="L33"><span class="tok-kw">const</span> parseFromSliceLeaky = std.json.parseFromSliceLeaky;</span>
<span class="line" id="L34"><span class="tok-kw">const</span> realpath = std.fs.realpath;</span>
<span class="line" id="L35"><span class="tok-kw">const</span> replace = std.mem.replace;</span>
<span class="line" id="L36"><span class="tok-kw">const</span> replacementSize = std.mem.replacementSize;</span>
<span class="line" id="L37"><span class="tok-kw">const</span> tmpDir = std.testing.tmpDir;</span>
<span class="line" id="L38"><span class="tok-kw">const</span> trim = std.mem.trim;</span>
<span class="line" id="L39"><span class="tok-kw">const</span> updateFileAbsolute = std.fs.updateFileAbsolute;</span>
<span class="line" id="L40"></span>
<span class="line" id="L41"><span class="tok-comment">/// The purpose of the converter engine is to take an .ini input file like this:</span></span>
<span class="line" id="L42"><span class="tok-comment">/// /* foo1   */ /* foo2*//*foo3*/</span></span>
<span class="line" id="L43"><span class="tok-comment">/// DataModule</span></span>
<span class="line" id="L44"><span class="tok-comment">/// \tSupportedGameVersion = Pre4</span></span>
<span class="line" id="L45"><span class="tok-comment">/// \t/* bar */IconFile      = ContentFile /* baz</span></span>
<span class="line" id="L46"><span class="tok-comment">/// bee */\t\tFilePath=foo.png</span></span>
<span class="line" id="L47"><span class="tok-comment">/// \tDescription = bop</span></span>
<span class="line" id="L48"><span class="tok-comment">///</span></span>
<span class="line" id="L49"><span class="tok-comment">/// and to turn it into this .ini output file:</span></span>
<span class="line" id="L50"><span class="tok-comment">/// // foo1 foo2 foo3</span></span>
<span class="line" id="L51"><span class="tok-comment">/// DataModule</span></span>
<span class="line" id="L52"><span class="tok-comment">/// \tSupportedGameVersion = Pre4</span></span>
<span class="line" id="L53"><span class="tok-comment">/// \tIconFile = ContentFile // bar baz</span></span>
<span class="line" id="L54"><span class="tok-comment">/// \t\tFilePath = foo.png // bee</span></span>
<span class="line" id="L55"><span class="tok-comment">/// \tDescription = bop</span></span>
<span class="line" id="L56"><span class="tok-comment">///</span></span>
<span class="line" id="L57"><span class="tok-comment">/// returned in the form of this Abstract Syntax Tree:</span></span>
<span class="line" id="L58"><span class="tok-comment">/// {</span></span>
<span class="line" id="L59"><span class="tok-comment">///     {</span></span>
<span class="line" id="L60"><span class="tok-comment">///         .comments = { &quot;foo1&quot;, &quot;foo2&quot;, &quot;foo3&quot; };</span></span>
<span class="line" id="L61"><span class="tok-comment">///     },</span></span>
<span class="line" id="L62"><span class="tok-comment">///     {</span></span>
<span class="line" id="L63"><span class="tok-comment">///         .property = &quot;DataModule&quot;;</span></span>
<span class="line" id="L64"><span class="tok-comment">///         .children = {</span></span>
<span class="line" id="L65"><span class="tok-comment">///             {</span></span>
<span class="line" id="L66"><span class="tok-comment">///                 .property = &quot;SupportedGameVersion&quot;;</span></span>
<span class="line" id="L67"><span class="tok-comment">///                 .value = &quot;Pre4&quot;;</span></span>
<span class="line" id="L68"><span class="tok-comment">///             },</span></span>
<span class="line" id="L69"><span class="tok-comment">///             {</span></span>
<span class="line" id="L70"><span class="tok-comment">///                 .property = &quot;IconFile&quot;;</span></span>
<span class="line" id="L71"><span class="tok-comment">///                 .value = &quot;ContentFile&quot;;</span></span>
<span class="line" id="L72"><span class="tok-comment">///                 .comments = { &quot;bar&quot;, &quot;baz&quot; };</span></span>
<span class="line" id="L73"><span class="tok-comment">///                 .children = {</span></span>
<span class="line" id="L74"><span class="tok-comment">///                     .property = &quot;FilePath&quot;;</span></span>
<span class="line" id="L75"><span class="tok-comment">///                     .value = &quot;foo.png&quot;;</span></span>
<span class="line" id="L76"><span class="tok-comment">///                     .comments = { &quot;bee&quot; };</span></span>
<span class="line" id="L77"><span class="tok-comment">///                 }</span></span>
<span class="line" id="L78"><span class="tok-comment">///             },</span></span>
<span class="line" id="L79"><span class="tok-comment">///             {</span></span>
<span class="line" id="L80"><span class="tok-comment">///                 .property = &quot;Description&quot;;</span></span>
<span class="line" id="L81"><span class="tok-comment">///                 .value = &quot;bop&quot;;</span></span>
<span class="line" id="L82"><span class="tok-comment">///             }</span></span>
<span class="line" id="L83"><span class="tok-comment">///         }</span></span>
<span class="line" id="L84"><span class="tok-comment">///     }</span></span>
<span class="line" id="L85"><span class="tok-comment">/// }</span></span>
<span class="line" id="L86"><span class="tok-kw">const</span> Token = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L87">    <span class="tok-type">type</span>: Type,</span>
<span class="line" id="L88">    slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L89"></span>
<span class="line" id="L90">    <span class="tok-comment">// TODO: Can I turn this struct into a tagged union,</span>
</span>
<span class="line" id="L91">    <span class="tok-comment">// in order to get rid of this Type enum definition?</span>
</span>
<span class="line" id="L92">    <span class="tok-kw">const</span> Type = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L93">        Comment,</span>
<span class="line" id="L94">        Tabs,</span>
<span class="line" id="L95">        Spaces,</span>
<span class="line" id="L96">        Equals,</span>
<span class="line" id="L97">        Newline,</span>
<span class="line" id="L98">        Sentence,</span>
<span class="line" id="L99">    };</span>
<span class="line" id="L100">};</span>
<span class="line" id="L101"></span>
<span class="line" id="L102"><span class="tok-kw">const</span> Node = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L103">    property: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L104">    value: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L105">    comments: ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>),</span>
<span class="line" id="L106">    children: ArrayList(Node),</span>
<span class="line" id="L107">};</span>
<span class="line" id="L108"></span>
<span class="line" id="L109"><span class="tok-kw">const</span> Rule = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L110">    old_property: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L111">    old_value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L112">    new_property: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L113">    new_value: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L114">};</span>
<span class="line" id="L115"></span>
<span class="line" id="L116"><span class="tok-kw">const</span> IniFile = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L117">    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L118">    ast: ArrayList(Node),</span>
<span class="line" id="L119">};</span>
<span class="line" id="L120"></span>
<span class="line" id="L121"><span class="tok-kw">const</span> IniFolder = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L122">    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L123">    files: ArrayList(IniFile),</span>
<span class="line" id="L124">    folders: ArrayList(IniFolder),</span>
<span class="line" id="L125">};</span>
<span class="line" id="L126"></span>
<span class="line" id="L127"><span class="tok-comment">/// Updated by `convert()` to record what it is doing.</span></span>
<span class="line" id="L128"><span class="tok-comment">/// If `convert()` crashed, look inside this struct to see why and where it did.</span></span>
<span class="line" id="L129"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Diagnostics = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L130">    file_path: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L131">    token: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L132">    line: ?<span class="tok-type">i32</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L133">    column: ?<span class="tok-type">i32</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L134">};</span>
<span class="line" id="L135"></span>
<span class="line" id="L136"><span class="tok-kw">const</span> PropertyValuePair = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L137">    property: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L138">    value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L139">};</span>
<span class="line" id="L140"></span>
<span class="line" id="L141"><span class="tok-kw">const</span> UpdateIniFileTreeErrors = <span class="tok-kw">error</span>{</span>
<span class="line" id="L142">    ExpectedValue,</span>
<span class="line" id="L143">};</span>
<span class="line" id="L144"></span>
<span class="line" id="L145"><span class="tok-comment">// TODO: Refactor into a CLI</span>
</span>
<span class="line" id="L146"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {</span>
<span class="line" id="L147">    <span class="tok-kw">var</span> arena = ArenaAllocator.init(page_allocator);</span>
<span class="line" id="L148">    <span class="tok-kw">defer</span> arena.deinit();</span>
<span class="line" id="L149">    <span class="tok-kw">var</span> allocator = arena.allocator();</span>
<span class="line" id="L150"></span>
<span class="line" id="L151">    <span class="tok-kw">var</span> args = <span class="tok-kw">try</span> std.process.argsWithAllocator(allocator);</span>
<span class="line" id="L152">    <span class="tok-kw">defer</span> args.deinit();</span>
<span class="line" id="L153"></span>
<span class="line" id="L154">    <span class="tok-kw">const</span> program_name = args.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ExpectedProgramName;</span>
<span class="line" id="L155">    _ = program_name;</span>
<span class="line" id="L156">    <span class="tok-kw">const</span> input_folder_path = args.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ExpectedInputFolderPath;</span>
<span class="line" id="L157">    <span class="tok-kw">const</span> output_folder_path = args.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ExpectedOutputFolderPath;</span>
<span class="line" id="L158"></span>
<span class="line" id="L159">    <span class="tok-kw">var</span> diagnostics: Diagnostics = .{};</span>
<span class="line" id="L160">    convert(</span>
<span class="line" id="L161">        input_folder_path,</span>
<span class="line" id="L162">        output_folder_path,</span>
<span class="line" id="L163">        allocator,</span>
<span class="line" id="L164">        &amp;diagnostics,</span>
<span class="line" id="L165">    ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L166">        <span class="tok-kw">error</span>.UnexpectedToken =&gt; {</span>
<span class="line" id="L167">            <span class="tok-kw">const</span> token = diagnostics.token <span class="tok-kw">orelse</span> <span class="tok-str">&quot;null&quot;</span>;</span>
<span class="line" id="L168">            <span class="tok-kw">const</span> file_path = diagnostics.file_path <span class="tok-kw">orelse</span> <span class="tok-str">&quot;null&quot;</span>;</span>
<span class="line" id="L169">            <span class="tok-kw">const</span> line = diagnostics.line <span class="tok-kw">orelse</span> -<span class="tok-number">1</span>;</span>
<span class="line" id="L170">            <span class="tok-kw">const</span> column = diagnostics.column <span class="tok-kw">orelse</span> -<span class="tok-number">1</span>;</span>
<span class="line" id="L171"></span>
<span class="line" id="L172">            std.log.info(<span class="tok-str">&quot;Error: Unexpected '{s}' at {s}:{}:{}\n&quot;</span>, .{</span>
<span class="line" id="L173">                token,</span>
<span class="line" id="L174">                file_path,</span>
<span class="line" id="L175">                line,</span>
<span class="line" id="L176">                column,</span>
<span class="line" id="L177">            });</span>
<span class="line" id="L178"></span>
<span class="line" id="L179">            <span class="tok-kw">return</span> err;</span>
<span class="line" id="L180">        },</span>
<span class="line" id="L181">        <span class="tok-kw">error</span>.TooManyTabs =&gt; {</span>
<span class="line" id="L182">            <span class="tok-kw">const</span> file_path = diagnostics.file_path <span class="tok-kw">orelse</span> <span class="tok-str">&quot;null&quot;</span>;</span>
<span class="line" id="L183">            <span class="tok-kw">const</span> line = diagnostics.line <span class="tok-kw">orelse</span> -<span class="tok-number">1</span>;</span>
<span class="line" id="L184">            <span class="tok-kw">const</span> column = diagnostics.column <span class="tok-kw">orelse</span> -<span class="tok-number">1</span>;</span>
<span class="line" id="L185"></span>
<span class="line" id="L186">            std.log.info(<span class="tok-str">&quot;Error: Too many tabs at {s}:{}:{}\n&quot;</span>, .{</span>
<span class="line" id="L187">                file_path,</span>
<span class="line" id="L188">                line,</span>
<span class="line" id="L189">                column,</span>
<span class="line" id="L190">            });</span>
<span class="line" id="L191"></span>
<span class="line" id="L192">            <span class="tok-kw">return</span> err;</span>
<span class="line" id="L193">        },</span>
<span class="line" id="L194">        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L195">    };</span>
<span class="line" id="L196"></span>
<span class="line" id="L197">    <span class="tok-kw">try</span> beautifyLua(output_folder_path, allocator);</span>
<span class="line" id="L198"></span>
<span class="line" id="L199">    <span class="tok-comment">// try zipMods(input_folder_path, output_folder_path, allocator);</span>
</span>
<span class="line" id="L200">}</span>
<span class="line" id="L201"></span>
<span class="line" id="L202"><span class="tok-comment">/// For every mod directory in `input_folder_path`, it creates a copy of the mod directory in `output_folder_path` with the required changes to make it compatible with the latest version of the game.</span></span>
<span class="line" id="L203"><span class="tok-comment">/// If `convert()` crashed, the `diagnostics` argument allows you to know why and where it did.</span></span>
<span class="line" id="L204"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">convert</span>(input_folder_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, output_folder_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allocator: Allocator, diagnostics: *Diagnostics) !<span class="tok-type">void</span> {</span>
<span class="line" id="L205">    std.log.info(<span class="tok-str">&quot;Making all output dirs...\n&quot;</span>, .{});</span>
<span class="line" id="L206">    <span class="tok-kw">try</span> makeOutputDirs(input_folder_path, output_folder_path, allocator);</span>
<span class="line" id="L207"></span>
<span class="line" id="L208">    std.log.info(<span class="tok-str">&quot;Copying files...\n&quot;</span>, .{});</span>
<span class="line" id="L209">    <span class="tok-kw">try</span> copyFiles(input_folder_path, output_folder_path, allocator);</span>
<span class="line" id="L210"></span>
<span class="line" id="L211">    <span class="tok-kw">const</span> lua_rules = <span class="tok-kw">try</span> parseLuaRules(allocator);</span>
<span class="line" id="L212">    std.log.info(<span class="tok-str">&quot;Applying Lua rules...\n&quot;</span>, .{});</span>
<span class="line" id="L213">    <span class="tok-kw">try</span> applyLuaRules(lua_rules, output_folder_path, allocator);</span>
<span class="line" id="L214"></span>
<span class="line" id="L215">    std.log.info(<span class="tok-str">&quot;Getting INI file tree...\n&quot;</span>, .{});</span>
<span class="line" id="L216">    <span class="tok-kw">var</span> file_tree = <span class="tok-kw">try</span> getIniFileTree(input_folder_path, allocator, diagnostics);</span>
<span class="line" id="L217"></span>
<span class="line" id="L218">    std.log.info(<span class="tok-str">&quot;Getting the mod's game version...\n&quot;</span>, .{});</span>
<span class="line" id="L219">    <span class="tok-kw">const</span> mod_version = <span class="tok-kw">try</span> getModVersion(&amp;file_tree);</span>
<span class="line" id="L220"></span>
<span class="line" id="L221">    <span class="tok-comment">// Check the version, since people since Pre6 are able to start using magenta</span>
</span>
<span class="line" id="L222">    <span class="tok-comment">// as a regular color in their RGB pngs</span>
</span>
<span class="line" id="L223">    <span class="tok-kw">if</span> (mod_version == ModVersion.BeforePre6) {</span>
<span class="line" id="L224">        <span class="tok-kw">try</span> replaceMagentaInRgbPngsWithAlpha(output_folder_path, allocator);</span>
<span class="line" id="L225">    }</span>
<span class="line" id="L226"></span>
<span class="line" id="L227">    <span class="tok-comment">// TODO: Do we also want to throw an error if 0 are found?</span>
</span>
<span class="line" id="L228">    <span class="tok-kw">if</span> (getDataModuleCount(&amp;file_tree) &gt; <span class="tok-number">1</span>) {</span>
<span class="line" id="L229">        <span class="tok-kw">return</span> <span class="tok-kw">error</span>.MoreThanOneDataModule;</span>
<span class="line" id="L230">    }</span>
<span class="line" id="L231"></span>
<span class="line" id="L232">    <span class="tok-kw">try</span> applyOnNodes(pathToFilePath, &amp;file_tree);</span>
<span class="line" id="L233"></span>
<span class="line" id="L234">    <span class="tok-comment">// It also HAS to be called before applyIniFilePathRules(),</span>
</span>
<span class="line" id="L235">    <span class="tok-comment">// because otherwise this could happen:</span>
</span>
<span class="line" id="L236">    <span class="tok-comment">// The game reports that Base.rte/foo.png doesn't exist,</span>
</span>
<span class="line" id="L237">    <span class="tok-comment">// so the user enters this ini_file_path_rules.json rule:</span>
</span>
<span class="line" id="L238">    <span class="tok-comment">// &quot;Base.rte/foo.png&quot;: &quot;Base.rte/bar.png&quot;</span>
</span>
<span class="line" id="L239">    <span class="tok-comment">// The game reports that Base.rte/foo.png *still* doesn't exist,</span>
</span>
<span class="line" id="L240">    <span class="tok-comment">// due to the parsed input mod containing &quot;Base.rte/foo.bmp&quot;!</span>
</span>
<span class="line" id="L241">    std.log.info(<span class="tok-str">&quot;Bmp extension to png...\n&quot;</span>, .{});</span>
<span class="line" id="L242">    <span class="tok-kw">try</span> applyOnNodesAlloc(bmpExtensionToPng, &amp;file_tree, allocator);</span>
<span class="line" id="L243"></span>
<span class="line" id="L244">    std.log.info(<span class="tok-str">&quot;Wav extension to flac...\n&quot;</span>, .{});</span>
<span class="line" id="L245">    <span class="tok-kw">try</span> applyOnNodesAlloc(wavExtensionToFlac, &amp;file_tree, allocator);</span>
<span class="line" id="L246"></span>
<span class="line" id="L247">    <span class="tok-kw">const</span> ini_copy_of_rules = <span class="tok-kw">try</span> parseIniCopyOfRules(allocator);</span>
<span class="line" id="L248">    std.log.info(<span class="tok-str">&quot;Applying INI CopyOf rules...\n&quot;</span>, .{});</span>
<span class="line" id="L249">    applyIniCopyOfRules(ini_copy_of_rules, &amp;file_tree);</span>
<span class="line" id="L250"></span>
<span class="line" id="L251">    <span class="tok-kw">const</span> ini_file_path_rules = <span class="tok-kw">try</span> parseIniFilePathRules(allocator);</span>
<span class="line" id="L252">    std.log.info(<span class="tok-str">&quot;Applying INI FilePath rules...\n&quot;</span>, .{});</span>
<span class="line" id="L253">    applyIniFilePathRules(ini_file_path_rules, &amp;file_tree);</span>
<span class="line" id="L254"></span>
<span class="line" id="L255">    <span class="tok-kw">const</span> ini_script_path_rules = <span class="tok-kw">try</span> parseIniScriptPathRules(allocator);</span>
<span class="line" id="L256">    std.log.info(<span class="tok-str">&quot;Applying INI ScriptPath rules...\n&quot;</span>, .{});</span>
<span class="line" id="L257">    applyIniScriptPathRules(ini_script_path_rules, &amp;file_tree);</span>
<span class="line" id="L258"></span>
<span class="line" id="L259">    <span class="tok-kw">const</span> ini_property_rules = <span class="tok-kw">try</span> parseIniPropertyRules(allocator);</span>
<span class="line" id="L260">    std.log.info(<span class="tok-str">&quot;Applying INI property rules...\n&quot;</span>, .{});</span>
<span class="line" id="L261">    applyIniPropertyRules(ini_property_rules, &amp;file_tree);</span>
<span class="line" id="L262"></span>
<span class="line" id="L263">    <span class="tok-kw">const</span> ini_rules = <span class="tok-kw">try</span> parseIniRules(allocator);</span>
<span class="line" id="L264">    std.log.info(<span class="tok-str">&quot;Applying INI rules...\n&quot;</span>, .{});</span>
<span class="line" id="L265">    applyIniRules(ini_rules, &amp;file_tree);</span>
<span class="line" id="L266"></span>
<span class="line" id="L267">    <span class="tok-kw">const</span> ini_sound_container_rules = <span class="tok-kw">try</span> parseIniSoundContainerRules(allocator);</span>
<span class="line" id="L268">    std.log.info(<span class="tok-str">&quot;Applying INI SoundContainer rules...\n&quot;</span>, .{});</span>
<span class="line" id="L269">    applyIniSoundContainerRules(ini_sound_container_rules, &amp;file_tree);</span>
<span class="line" id="L270"></span>
<span class="line" id="L271">    std.log.info(<span class="tok-str">&quot;Updating INI file tree...\n&quot;</span>, .{});</span>
<span class="line" id="L272">    <span class="tok-kw">try</span> updateIniFileTree(&amp;file_tree, allocator);</span>
<span class="line" id="L273"></span>
<span class="line" id="L274">    std.log.info(<span class="tok-str">&quot;Writing INI file tree...\n&quot;</span>, .{});</span>
<span class="line" id="L275">    <span class="tok-kw">try</span> writeIniFileTree(&amp;file_tree, output_folder_path, allocator);</span>
<span class="line" id="L276">}</span>
<span class="line" id="L277"></span>
<span class="line" id="L278"><span class="tok-kw">fn</span> <span class="tok-fn">makeOutputDirs</span>(input_folder_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, output_folder_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L279">    makeDirAbsolute(output_folder_path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L280">        <span class="tok-kw">error</span>.PathAlreadyExists =&gt; {},</span>
<span class="line" id="L281">        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L282">    };</span>
<span class="line" id="L283"></span>
<span class="line" id="L284">    <span class="tok-kw">var</span> iterable_dir = <span class="tok-kw">try</span> std.fs.openIterableDirAbsolute(input_folder_path, .{});</span>
<span class="line" id="L285">    <span class="tok-kw">defer</span> iterable_dir.close();</span>
<span class="line" id="L286">    <span class="tok-kw">var</span> dir_iterator = iterable_dir.iterate();</span>
<span class="line" id="L287"></span>
<span class="line" id="L288">    <span class="tok-kw">while</span> (<span class="tok-kw">try</span> dir_iterator.next()) |entry| {</span>
<span class="line" id="L289">        <span class="tok-kw">if</span> (entry.kind == std.fs.File.Kind.directory) {</span>
<span class="line" id="L290">            <span class="tok-kw">const</span> child_input_folder_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ input_folder_path, entry.name });</span>
<span class="line" id="L291">            <span class="tok-kw">const</span> child_output_folder_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ output_folder_path, entry.name });</span>
<span class="line" id="L292">            <span class="tok-kw">try</span> makeOutputDirs(child_input_folder_path, child_output_folder_path, allocator);</span>
<span class="line" id="L293">        }</span>
<span class="line" id="L294">    }</span>
<span class="line" id="L295">}</span>
<span class="line" id="L296"></span>
<span class="line" id="L297"><span class="tok-comment">/// Doesn't copy .ini files</span></span>
<span class="line" id="L298"><span class="tok-kw">fn</span> <span class="tok-fn">copyFiles</span>(input_folder_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, output_folder_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L299">    <span class="tok-kw">var</span> iterable_dir = <span class="tok-kw">try</span> std.fs.openIterableDirAbsolute(input_folder_path, .{});</span>
<span class="line" id="L300">    <span class="tok-kw">defer</span> iterable_dir.close();</span>
<span class="line" id="L301">    <span class="tok-kw">var</span> dir_iterator = iterable_dir.iterate();</span>
<span class="line" id="L302"></span>
<span class="line" id="L303">    <span class="tok-kw">while</span> (<span class="tok-kw">try</span> dir_iterator.next()) |entry| {</span>
<span class="line" id="L304">        <span class="tok-kw">if</span> (entry.kind == std.fs.File.Kind.file) {</span>
<span class="line" id="L305">            <span class="tok-kw">const</span> ext = extension(entry.name);</span>
<span class="line" id="L306"></span>
<span class="line" id="L307">            <span class="tok-kw">if</span> (strEql(ext, <span class="tok-str">&quot;.bmp&quot;</span>)) {</span>
<span class="line" id="L308">                <span class="tok-kw">const</span> input_file_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ input_folder_path, entry.name });</span>
<span class="line" id="L309"></span>
<span class="line" id="L310">                <span class="tok-kw">var</span> output_name = <span class="tok-kw">try</span> allocator.dupe(<span class="tok-type">u8</span>, entry.name);</span>
<span class="line" id="L311"></span>
<span class="line" id="L312">                output_name[output_name.len - <span class="tok-number">1</span>] = <span class="tok-str">'g'</span>;</span>
<span class="line" id="L313">                output_name[output_name.len - <span class="tok-number">2</span>] = <span class="tok-str">'n'</span>;</span>
<span class="line" id="L314">                output_name[output_name.len - <span class="tok-number">3</span>] = <span class="tok-str">'p'</span>;</span>
<span class="line" id="L315"></span>
<span class="line" id="L316">                <span class="tok-kw">const</span> output_file_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ output_folder_path, output_name });</span>
<span class="line" id="L317"></span>
<span class="line" id="L318">                <span class="tok-kw">const</span> output_file_access = std.fs.accessAbsolute(output_file_path, .{});</span>
<span class="line" id="L319"></span>
<span class="line" id="L320">                <span class="tok-kw">if</span> (output_file_access == <span class="tok-kw">error</span>.FileNotFound) {</span>
<span class="line" id="L321">                    <span class="tok-kw">try</span> convertBmpToPng(input_file_path, output_file_path, allocator);</span>
<span class="line" id="L322">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (output_file_access <span class="tok-kw">catch</span> <span class="tok-null">null</span>) |_| { <span class="tok-comment">// Else if there was no access error</span>
</span>
<span class="line" id="L323">                    <span class="tok-comment">// TODO: Windows can be significantly faster if we use iterable_dir.dir.stat() manually here,</span>
</span>
<span class="line" id="L324">                    <span class="tok-comment">// if (and only if) directory mod times are updated when files change on Windows!</span>
</span>
<span class="line" id="L325"></span>
<span class="line" id="L326">                    <span class="tok-kw">const</span> input_stat = <span class="tok-kw">try</span> iterable_dir.dir.statFile(input_file_path);</span>
<span class="line" id="L327">                    <span class="tok-kw">const</span> output_stat = <span class="tok-kw">try</span> iterable_dir.dir.statFile(output_file_path);</span>
<span class="line" id="L328"></span>
<span class="line" id="L329">                    <span class="tok-kw">if</span> (input_stat.mtime &gt; output_stat.mtime) {</span>
<span class="line" id="L330">                        <span class="tok-comment">// TODO: Figure out whether a different function should be called in this case,</span>
</span>
<span class="line" id="L331">                        <span class="tok-comment">// similar to below where updateFileAbsolute() can be called instead of copyFileAbsolute()</span>
</span>
<span class="line" id="L332">                        <span class="tok-kw">try</span> convertBmpToPng(input_file_path, output_file_path, allocator);</span>
<span class="line" id="L333">                    }</span>
<span class="line" id="L334">                } <span class="tok-kw">else</span> { <span class="tok-comment">// Else return the access error</span>
</span>
<span class="line" id="L335">                    <span class="tok-kw">return</span> output_file_access;</span>
<span class="line" id="L336">                }</span>
<span class="line" id="L337">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (strEql(ext, <span class="tok-str">&quot;.wav&quot;</span>)) {</span>
<span class="line" id="L338">                <span class="tok-kw">const</span> input_file_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ input_folder_path, entry.name });</span>
<span class="line" id="L339"></span>
<span class="line" id="L340">                <span class="tok-comment">// Create a copy of the entry name that is one character longer, so the &quot;c&quot; in .flac fits</span>
</span>
<span class="line" id="L341">                <span class="tok-kw">var</span> output_name = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, entry.name.len + <span class="tok-number">1</span>);</span>
<span class="line" id="L342">                <span class="tok-builtin">@memcpy</span>(output_name[<span class="tok-number">0</span>..entry.name.len], entry.name);</span>
<span class="line" id="L343"></span>
<span class="line" id="L344">                output_name[output_name.len - <span class="tok-number">1</span>] = <span class="tok-str">'c'</span>;</span>
<span class="line" id="L345">                output_name[output_name.len - <span class="tok-number">2</span>] = <span class="tok-str">'a'</span>;</span>
<span class="line" id="L346">                output_name[output_name.len - <span class="tok-number">3</span>] = <span class="tok-str">'l'</span>;</span>
<span class="line" id="L347">                output_name[output_name.len - <span class="tok-number">4</span>] = <span class="tok-str">'f'</span>;</span>
<span class="line" id="L348"></span>
<span class="line" id="L349">                <span class="tok-kw">const</span> output_file_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ output_folder_path, output_name });</span>
<span class="line" id="L350"></span>
<span class="line" id="L351">                <span class="tok-kw">const</span> output_file_access = std.fs.accessAbsolute(output_file_path, .{});</span>
<span class="line" id="L352"></span>
<span class="line" id="L353">                <span class="tok-kw">if</span> (output_file_access == <span class="tok-kw">error</span>.FileNotFound) {</span>
<span class="line" id="L354">                    <span class="tok-kw">try</span> convertWavToFlac(input_file_path, output_file_path, allocator);</span>
<span class="line" id="L355">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (output_file_access <span class="tok-kw">catch</span> <span class="tok-null">null</span>) |_| { <span class="tok-comment">// Else if there was no access error</span>
</span>
<span class="line" id="L356">                    <span class="tok-comment">// TODO: Windows can be significantly faster if we use iterable_dir.dir.stat() manually here,</span>
</span>
<span class="line" id="L357">                    <span class="tok-comment">// if (and only if) directory mod times are updated when files change on Windows!</span>
</span>
<span class="line" id="L358"></span>
<span class="line" id="L359">                    <span class="tok-kw">const</span> input_stat = <span class="tok-kw">try</span> iterable_dir.dir.statFile(input_file_path);</span>
<span class="line" id="L360">                    <span class="tok-kw">const</span> output_stat = <span class="tok-kw">try</span> iterable_dir.dir.statFile(output_file_path);</span>
<span class="line" id="L361"></span>
<span class="line" id="L362">                    <span class="tok-kw">if</span> (input_stat.mtime &gt; output_stat.mtime) {</span>
<span class="line" id="L363">                        <span class="tok-comment">// TODO: Figure out whether a different function should be called in this case,</span>
</span>
<span class="line" id="L364">                        <span class="tok-comment">// similar to below where updateFileAbsolute() can be called instead of copyFileAbsolute()</span>
</span>
<span class="line" id="L365">                        <span class="tok-kw">try</span> convertWavToFlac(input_file_path, output_file_path, allocator);</span>
<span class="line" id="L366">                    }</span>
<span class="line" id="L367">                } <span class="tok-kw">else</span> { <span class="tok-comment">// Else return the access error</span>
</span>
<span class="line" id="L368">                    <span class="tok-kw">return</span> output_file_access;</span>
<span class="line" id="L369">                }</span>
<span class="line" id="L370">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (!strEql(ext, <span class="tok-str">&quot;.ini&quot;</span>)) { <span class="tok-comment">// This function doesn't copy .ini files</span>
</span>
<span class="line" id="L371">                <span class="tok-kw">const</span> input_file_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ input_folder_path, entry.name });</span>
<span class="line" id="L372">                <span class="tok-kw">const</span> output_file_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ output_folder_path, entry.name });</span>
<span class="line" id="L373"></span>
<span class="line" id="L374">                <span class="tok-kw">const</span> output_file_access = std.fs.accessAbsolute(output_file_path, .{});</span>
<span class="line" id="L375"></span>
<span class="line" id="L376">                <span class="tok-kw">if</span> (output_file_access == <span class="tok-kw">error</span>.FileNotFound) {</span>
<span class="line" id="L377">                    <span class="tok-kw">try</span> copyFileAbsolute(input_file_path, output_file_path, .{});</span>
<span class="line" id="L378">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (output_file_access <span class="tok-kw">catch</span> <span class="tok-null">null</span>) |_| { <span class="tok-comment">// Else if there was no access error</span>
</span>
<span class="line" id="L379">                    <span class="tok-comment">// TODO: Windows can be significantly faster if we use iterable_dir.dir.stat() manually here,</span>
</span>
<span class="line" id="L380">                    <span class="tok-comment">// if (and only if) directory mod times are updated when files change on Windows!</span>
</span>
<span class="line" id="L381"></span>
<span class="line" id="L382">                    <span class="tok-kw">const</span> input_stat = <span class="tok-kw">try</span> iterable_dir.dir.statFile(input_file_path);</span>
<span class="line" id="L383">                    <span class="tok-kw">const</span> output_stat = <span class="tok-kw">try</span> iterable_dir.dir.statFile(output_file_path);</span>
<span class="line" id="L384"></span>
<span class="line" id="L385">                    <span class="tok-kw">if</span> (input_stat.mtime &gt; output_stat.mtime) {</span>
<span class="line" id="L386">                        <span class="tok-comment">// TODO: Reverify that this is faster than the plain copyFileAbsolute()</span>
</span>
<span class="line" id="L387">                        _ = <span class="tok-kw">try</span> updateFileAbsolute(input_file_path, output_file_path, .{});</span>
<span class="line" id="L388">                    }</span>
<span class="line" id="L389">                } <span class="tok-kw">else</span> { <span class="tok-comment">// Else return the access error</span>
</span>
<span class="line" id="L390">                    <span class="tok-kw">return</span> output_file_access;</span>
<span class="line" id="L391">                }</span>
<span class="line" id="L392">            }</span>
<span class="line" id="L393">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (entry.kind == std.fs.File.Kind.directory) {</span>
<span class="line" id="L394">            <span class="tok-kw">const</span> child_input_folder_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ input_folder_path, entry.name });</span>
<span class="line" id="L395">            <span class="tok-kw">const</span> child_output_folder_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ output_folder_path, entry.name });</span>
<span class="line" id="L396">            <span class="tok-kw">try</span> copyFiles(child_input_folder_path, child_output_folder_path, allocator);</span>
<span class="line" id="L397">        }</span>
<span class="line" id="L398">    }</span>
<span class="line" id="L399">}</span>
<span class="line" id="L400"></span>
<span class="line" id="L401"><span class="tok-kw">fn</span> <span class="tok-fn">strEql</span>(str1: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, str2: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L402">    <span class="tok-kw">return</span> eql(<span class="tok-type">u8</span>, str1, str2);</span>
<span class="line" id="L403">}</span>
<span class="line" id="L404"></span>
<span class="line" id="L405"><span class="tok-kw">fn</span> <span class="tok-fn">convertBmpToPng</span>(input_file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, output_file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L406">    <span class="tok-comment">// TODO: ffmpeg won't always be available, so include its source code and call that instead</span>
</span>
<span class="line" id="L407">    <span class="tok-comment">// -y allows overwriting output files</span>
</span>
<span class="line" id="L408">    <span class="tok-kw">const</span> argv = [_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ <span class="tok-str">&quot;ffmpeg&quot;</span>, <span class="tok-str">&quot;-i&quot;</span>, input_file_path, output_file_path, <span class="tok-str">&quot;-y&quot;</span> };</span>
<span class="line" id="L409">    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> std.ChildProcess.exec(.{ .argv = &amp;argv, .allocator = allocator });</span>
<span class="line" id="L410">    _ = result;</span>
<span class="line" id="L411">}</span>
<span class="line" id="L412"></span>
<span class="line" id="L413"><span class="tok-kw">fn</span> <span class="tok-fn">convertWavToFlac</span>(input_file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, output_file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L414">    <span class="tok-comment">// TODO: ffmpeg won't always be available, so include its source code and call that instead</span>
</span>
<span class="line" id="L415">    <span class="tok-comment">// -y allows overwriting output files</span>
</span>
<span class="line" id="L416">    <span class="tok-kw">const</span> argv = [_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ <span class="tok-str">&quot;ffmpeg&quot;</span>, <span class="tok-str">&quot;-i&quot;</span>, input_file_path, output_file_path, <span class="tok-str">&quot;-y&quot;</span> };</span>
<span class="line" id="L417">    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> std.ChildProcess.exec(.{ .argv = &amp;argv, .allocator = allocator });</span>
<span class="line" id="L418">    _ = result;</span>
<span class="line" id="L419"></span>
<span class="line" id="L420">    <span class="tok-comment">// var line_iter = std.mem.split(u8, result.stderr, &quot;\n&quot;);</span>
</span>
<span class="line" id="L421">    <span class="tok-comment">// while (line_iter.next()) |line| {</span>
</span>
<span class="line" id="L422">    <span class="tok-comment">//     if (line.len == 0) continue;</span>
</span>
<span class="line" id="L423">    <span class="tok-comment">// }</span>
</span>
<span class="line" id="L424">}</span>
<span class="line" id="L425"></span>
<span class="line" id="L426"><span class="tok-kw">fn</span> <span class="tok-fn">parseLuaRules</span>(allocator: Allocator) !std.json.ArrayHashMap([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) {</span>
<span class="line" id="L427">    <span class="tok-kw">const</span> text = <span class="tok-kw">try</span> readFile(<span class="tok-str">&quot;rules/lua_rules.json&quot;</span>, allocator);</span>
<span class="line" id="L428"></span>
<span class="line" id="L429">    <span class="tok-kw">var</span> scanner = Scanner.initCompleteInput(allocator, text);</span>
<span class="line" id="L430"></span>
<span class="line" id="L431">    <span class="tok-kw">var</span> lua_rules = <span class="tok-kw">try</span> std.json.ArrayHashMap([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).jsonParse(allocator, &amp;scanner, .{ .allocate = .alloc_if_needed, .max_value_len = default_max_value_len });</span>
<span class="line" id="L432">    <span class="tok-kw">return</span> lua_rules;</span>
<span class="line" id="L433">}</span>
<span class="line" id="L434"></span>
<span class="line" id="L435"><span class="tok-kw">fn</span> <span class="tok-fn">applyLuaRules</span>(lua_rules: std.json.ArrayHashMap([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>), folder_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L436">    <span class="tok-kw">var</span> iterable_dir = <span class="tok-kw">try</span> std.fs.openIterableDirAbsolute(folder_path, .{});</span>
<span class="line" id="L437">    <span class="tok-kw">defer</span> iterable_dir.close();</span>
<span class="line" id="L438">    <span class="tok-kw">var</span> dir_iterator = iterable_dir.iterate();</span>
<span class="line" id="L439"></span>
<span class="line" id="L440">    <span class="tok-kw">while</span> (<span class="tok-kw">try</span> dir_iterator.next()) |dir_entry| {</span>
<span class="line" id="L441">        <span class="tok-kw">if</span> (dir_entry.kind == std.fs.File.Kind.file) {</span>
<span class="line" id="L442">            <span class="tok-kw">if</span> (strEql(extension(dir_entry.name), <span class="tok-str">&quot;.lua&quot;</span>)) {</span>
<span class="line" id="L443">                <span class="tok-kw">const</span> file_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ folder_path, dir_entry.name });</span>
<span class="line" id="L444">                <span class="tok-kw">var</span> text = <span class="tok-kw">try</span> readFile(file_path, allocator);</span>
<span class="line" id="L445"></span>
<span class="line" id="L446">                <span class="tok-kw">var</span> text_contains_any_key = <span class="tok-null">false</span>;</span>
<span class="line" id="L447"></span>
<span class="line" id="L448">                <span class="tok-kw">var</span> map_iterator = lua_rules.map.iterator();</span>
<span class="line" id="L449">                <span class="tok-kw">while</span> (map_iterator.next()) |map_entry| {</span>
<span class="line" id="L450">                    <span class="tok-kw">const</span> key = map_entry.key_ptr.*;</span>
<span class="line" id="L451">                    <span class="tok-kw">const</span> value = map_entry.value_ptr.*;</span>
<span class="line" id="L452"></span>
<span class="line" id="L453">                    <span class="tok-kw">const</span> text_contains_key = std.mem.indexOfPos(<span class="tok-type">u8</span>, text, <span class="tok-number">0</span>, key) != <span class="tok-null">null</span>;</span>
<span class="line" id="L454">                    <span class="tok-kw">if</span> (text_contains_key) {</span>
<span class="line" id="L455">                        text_contains_any_key = <span class="tok-null">true</span>;</span>
<span class="line" id="L456"></span>
<span class="line" id="L457">                        <span class="tok-kw">const</span> replacement_size = replacementSize(<span class="tok-type">u8</span>, text, key, value);</span>
<span class="line" id="L458">                        <span class="tok-kw">const</span> new_text = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, replacement_size);</span>
<span class="line" id="L459">                        _ = replace(<span class="tok-type">u8</span>, text, key, value, new_text);</span>
<span class="line" id="L460">                        text = new_text;</span>
<span class="line" id="L461">                    }</span>
<span class="line" id="L462">                }</span>
<span class="line" id="L463"></span>
<span class="line" id="L464">                <span class="tok-kw">if</span> (text_contains_any_key) {</span>
<span class="line" id="L465">                    <span class="tok-kw">const</span> cwd = std.fs.cwd();</span>
<span class="line" id="L466">                    <span class="tok-kw">var</span> file = <span class="tok-kw">try</span> cwd.createFile(file_path, .{});</span>
<span class="line" id="L467">                    <span class="tok-kw">defer</span> file.close();</span>
<span class="line" id="L468">                    <span class="tok-kw">try</span> file.writeAll(text);</span>
<span class="line" id="L469">                }</span>
<span class="line" id="L470">            }</span>
<span class="line" id="L471">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (dir_entry.kind == std.fs.File.Kind.directory) {</span>
<span class="line" id="L472">            <span class="tok-kw">try</span> applyLuaRules(lua_rules, <span class="tok-kw">try</span> join(allocator, &amp;.{ folder_path, dir_entry.name }), allocator);</span>
<span class="line" id="L473">        }</span>
<span class="line" id="L474">    }</span>
<span class="line" id="L475">}</span>
<span class="line" id="L476"></span>
<span class="line" id="L477"><span class="tok-kw">fn</span> <span class="tok-fn">getIniFileTree</span>(folder_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allocator: Allocator, diagnostics: *Diagnostics) !IniFolder {</span>
<span class="line" id="L478">    <span class="tok-kw">var</span> folder = IniFolder{</span>
<span class="line" id="L479">        .name = basename(folder_path),</span>
<span class="line" id="L480">        .files = ArrayList(IniFile).init(allocator),</span>
<span class="line" id="L481">        .folders = ArrayList(IniFolder).init(allocator),</span>
<span class="line" id="L482">    };</span>
<span class="line" id="L483"></span>
<span class="line" id="L484">    <span class="tok-kw">var</span> iterable_dir = <span class="tok-kw">try</span> std.fs.openIterableDirAbsolute(folder_path, .{});</span>
<span class="line" id="L485">    <span class="tok-kw">defer</span> iterable_dir.close();</span>
<span class="line" id="L486">    <span class="tok-kw">var</span> dir_iterator = iterable_dir.iterate();</span>
<span class="line" id="L487"></span>
<span class="line" id="L488">    <span class="tok-kw">while</span> (<span class="tok-kw">try</span> dir_iterator.next()) |entry| {</span>
<span class="line" id="L489">        <span class="tok-kw">if</span> (entry.kind == std.fs.File.Kind.file) {</span>
<span class="line" id="L490">            <span class="tok-kw">const</span> file_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ folder_path, entry.name });</span>
<span class="line" id="L491">            <span class="tok-kw">if</span> (strEql(extension(entry.name), <span class="tok-str">&quot;.ini&quot;</span>)) {</span>
<span class="line" id="L492">                diagnostics.file_path = file_path;</span>
<span class="line" id="L493">                <span class="tok-kw">const</span> text = <span class="tok-kw">try</span> readFile(file_path, allocator);</span>
<span class="line" id="L494"></span>
<span class="line" id="L495">                <span class="tok-kw">var</span> tokens = <span class="tok-kw">try</span> getTokens(text, allocator);</span>
<span class="line" id="L496"></span>
<span class="line" id="L497">                <span class="tok-comment">// TODO: Should I stop passing the address of tokens and ast everywhere?</span>
</span>
<span class="line" id="L498">                <span class="tok-kw">var</span> ast = <span class="tok-kw">try</span> getAstFromTokens(&amp;tokens, allocator, diagnostics);</span>
<span class="line" id="L499"></span>
<span class="line" id="L500">                <span class="tok-kw">var</span> file = IniFile{</span>
<span class="line" id="L501">                    .name = <span class="tok-kw">try</span> allocator.dupe(<span class="tok-type">u8</span>, entry.name),</span>
<span class="line" id="L502">                    .ast = ast,</span>
<span class="line" id="L503">                };</span>
<span class="line" id="L504">                <span class="tok-kw">try</span> folder.files.append(file);</span>
<span class="line" id="L505">            }</span>
<span class="line" id="L506">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (entry.kind == std.fs.File.Kind.directory) {</span>
<span class="line" id="L507">            <span class="tok-kw">var</span> child_folder = <span class="tok-kw">try</span> getIniFileTree(<span class="tok-kw">try</span> join(allocator, &amp;.{ folder_path, entry.name }), allocator, diagnostics);</span>
<span class="line" id="L508">            <span class="tok-kw">try</span> folder.folders.append(child_folder);</span>
<span class="line" id="L509">        }</span>
<span class="line" id="L510">    }</span>
<span class="line" id="L511"></span>
<span class="line" id="L512">    <span class="tok-kw">return</span> folder;</span>
<span class="line" id="L513">}</span>
<span class="line" id="L514"></span>
<span class="line" id="L515"><span class="tok-kw">fn</span> <span class="tok-fn">readFile</span>(input_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allocator: Allocator) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L516">    <span class="tok-kw">const</span> cwd = std.fs.cwd();</span>
<span class="line" id="L517"></span>
<span class="line" id="L518">    <span class="tok-kw">var</span> input_file = <span class="tok-kw">try</span> cwd.openFile(input_path, .{});</span>
<span class="line" id="L519">    <span class="tok-kw">defer</span> input_file.close();</span>
<span class="line" id="L520"></span>
<span class="line" id="L521">    <span class="tok-kw">var</span> buf_reader = bufferedReader(input_file.reader());</span>
<span class="line" id="L522">    <span class="tok-kw">var</span> in_stream = buf_reader.reader();</span>
<span class="line" id="L523"></span>
<span class="line" id="L524">    <span class="tok-kw">const</span> text = <span class="tok-kw">try</span> in_stream.readAllAlloc(allocator, maxInt(<span class="tok-type">usize</span>));</span>
<span class="line" id="L525"></span>
<span class="line" id="L526">    <span class="tok-kw">const</span> lf_text = <span class="tok-kw">try</span> crlfToLf(text, allocator);</span>
<span class="line" id="L527"></span>
<span class="line" id="L528">    <span class="tok-kw">return</span> lf_text;</span>
<span class="line" id="L529">}</span>
<span class="line" id="L530"></span>
<span class="line" id="L531"><span class="tok-kw">fn</span> <span class="tok-fn">crlfToLf</span>(text: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allocator: Allocator) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L532">    <span class="tok-kw">const</span> replacement_size = replacementSize(<span class="tok-type">u8</span>, text, <span class="tok-str">&quot;\r\n&quot;</span>, <span class="tok-str">&quot;\n&quot;</span>);</span>
<span class="line" id="L533">    <span class="tok-kw">var</span> lf_text = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, replacement_size);</span>
<span class="line" id="L534">    _ = replace(<span class="tok-type">u8</span>, text, <span class="tok-str">&quot;\r\n&quot;</span>, <span class="tok-str">&quot;\n&quot;</span>, lf_text);</span>
<span class="line" id="L535">    <span class="tok-kw">return</span> lf_text;</span>
<span class="line" id="L536">}</span>
<span class="line" id="L537"></span>
<span class="line" id="L538"><span class="tok-kw">fn</span> <span class="tok-fn">getTokens</span>(lf_text: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allocator: Allocator) !ArrayList(Token) {</span>
<span class="line" id="L539">    <span class="tok-kw">const</span> TokenError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L540">        UnclosedMultiComment,</span>
<span class="line" id="L541">    };</span>
<span class="line" id="L542"></span>
<span class="line" id="L543">    <span class="tok-kw">var</span> slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = lf_text;</span>
<span class="line" id="L544"></span>
<span class="line" id="L545">    <span class="tok-kw">var</span> tokens = ArrayList(Token).init(allocator);</span>
<span class="line" id="L546"></span>
<span class="line" id="L547">    <span class="tok-kw">var</span> multiline_comment_depth: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L548"></span>
<span class="line" id="L549">    <span class="tok-kw">var</span> seen_property = <span class="tok-null">false</span>;</span>
<span class="line" id="L550"></span>
<span class="line" id="L551">    <span class="tok-kw">while</span> (slice.len &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L552">        <span class="tok-kw">const</span> token = getToken(&amp;slice, &amp;multiline_comment_depth, &amp;seen_property);</span>
<span class="line" id="L553">        <span class="tok-kw">try</span> tokens.append(token);</span>
<span class="line" id="L554">    }</span>
<span class="line" id="L555"></span>
<span class="line" id="L556">    <span class="tok-kw">if</span> (multiline_comment_depth &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L557">        <span class="tok-kw">return</span> TokenError.UnclosedMultiComment;</span>
<span class="line" id="L558">    }</span>
<span class="line" id="L559"></span>
<span class="line" id="L560">    <span class="tok-kw">return</span> tokens;</span>
<span class="line" id="L561">}</span>
<span class="line" id="L562"></span>
<span class="line" id="L563"><span class="tok-kw">fn</span> <span class="tok-fn">getToken</span>(slice: *[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, multiline_comment_depth: *<span class="tok-type">i32</span>, seen_property: *<span class="tok-type">bool</span>) Token {</span>
<span class="line" id="L564">    <span class="tok-kw">if</span> (slice.*[<span class="tok-number">0</span>] == <span class="tok-str">'\n'</span>) {</span>
<span class="line" id="L565">        seen_property.* = <span class="tok-null">false</span>;</span>
<span class="line" id="L566">        <span class="tok-kw">const</span> token = Token{ .<span class="tok-type">type</span> = .Newline, .slice = slice.*[<span class="tok-number">0</span>..<span class="tok-number">1</span>] };</span>
<span class="line" id="L567">        slice.* = slice.*[<span class="tok-number">1</span>..];</span>
<span class="line" id="L568">        <span class="tok-kw">return</span> token;</span>
<span class="line" id="L569">    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (multiline_comment_depth.* &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L570">        <span class="tok-kw">var</span> found_comment_marker = <span class="tok-null">false</span>;</span>
<span class="line" id="L571">        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L572">        <span class="tok-kw">while</span> (i &lt; slice.len) {</span>
<span class="line" id="L573">            <span class="tok-kw">if</span> (slice.*[i] == <span class="tok-str">'\n'</span>) {</span>
<span class="line" id="L574">                <span class="tok-kw">break</span>;</span>
<span class="line" id="L575">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (slice.*[i] == <span class="tok-str">'/'</span> <span class="tok-kw">and</span> slice.*[i + <span class="tok-number">1</span>] == <span class="tok-str">'*'</span>) {</span>
<span class="line" id="L576">                multiline_comment_depth.* += <span class="tok-number">1</span>;</span>
<span class="line" id="L577">                i += <span class="tok-number">2</span>;</span>
<span class="line" id="L578">                found_comment_marker = <span class="tok-null">true</span>;</span>
<span class="line" id="L579">                <span class="tok-kw">break</span>;</span>
<span class="line" id="L580">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (slice.*[i] == <span class="tok-str">'*'</span> <span class="tok-kw">and</span> slice.*[i + <span class="tok-number">1</span>] == <span class="tok-str">'/'</span>) {</span>
<span class="line" id="L581">                multiline_comment_depth.* -= <span class="tok-number">1</span>;</span>
<span class="line" id="L582">                i += <span class="tok-number">2</span>;</span>
<span class="line" id="L583">                found_comment_marker = <span class="tok-null">true</span>;</span>
<span class="line" id="L584">                <span class="tok-kw">break</span>;</span>
<span class="line" id="L585">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L586">                i += <span class="tok-number">1</span>;</span>
<span class="line" id="L587">            }</span>
<span class="line" id="L588">        }</span>
<span class="line" id="L589"></span>
<span class="line" id="L590">        <span class="tok-kw">const</span> comment_end_index = <span class="tok-kw">if</span> (found_comment_marker) i - <span class="tok-number">2</span> <span class="tok-kw">else</span> i;</span>
<span class="line" id="L591">        <span class="tok-kw">const</span> comment = trim(<span class="tok-type">u8</span>, slice.*[<span class="tok-number">0</span>..comment_end_index], <span class="tok-str">&quot; &quot;</span>);</span>
<span class="line" id="L592">        <span class="tok-kw">const</span> token = Token{ .<span class="tok-type">type</span> = .Comment, .slice = comment };</span>
<span class="line" id="L593">        slice.* = slice.*[i..];</span>
<span class="line" id="L594">        <span class="tok-kw">return</span> token;</span>
<span class="line" id="L595">    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (slice.*[<span class="tok-number">0</span>] == <span class="tok-str">'/'</span> <span class="tok-kw">and</span> slice.*[<span class="tok-number">1</span>] == <span class="tok-str">'/'</span>) {</span>
<span class="line" id="L596">        <span class="tok-kw">const</span> index = std.mem.indexOf(<span class="tok-type">u8</span>, slice.*[<span class="tok-number">2</span>..], <span class="tok-str">&quot;\n&quot;</span>);</span>
<span class="line" id="L597">        <span class="tok-kw">const</span> newline_index = <span class="tok-kw">if</span> (index) |i| i + <span class="tok-number">2</span> <span class="tok-kw">else</span> slice.len;</span>
<span class="line" id="L598">        <span class="tok-kw">const</span> token = Token{ .<span class="tok-type">type</span> = .Comment, .slice = trim(<span class="tok-type">u8</span>, slice.*[<span class="tok-number">2</span>..newline_index], <span class="tok-str">&quot; &quot;</span>) };</span>
<span class="line" id="L599">        slice.* = slice.*[newline_index..];</span>
<span class="line" id="L600">        <span class="tok-kw">return</span> token;</span>
<span class="line" id="L601">    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (slice.*[<span class="tok-number">0</span>] == <span class="tok-str">'/'</span> <span class="tok-kw">and</span> slice.*[<span class="tok-number">1</span>] == <span class="tok-str">'*'</span>) {</span>
<span class="line" id="L602">        multiline_comment_depth.* += <span class="tok-number">1</span>;</span>
<span class="line" id="L603"></span>
<span class="line" id="L604">        <span class="tok-kw">var</span> found_comment_marker = <span class="tok-null">false</span>;</span>
<span class="line" id="L605">        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">2</span>;</span>
<span class="line" id="L606">        <span class="tok-kw">while</span> (i &lt; slice.len) {</span>
<span class="line" id="L607">            <span class="tok-kw">if</span> (slice.*[i] == <span class="tok-str">'\n'</span>) {</span>
<span class="line" id="L608">                <span class="tok-kw">break</span>;</span>
<span class="line" id="L609">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (slice.*[i] == <span class="tok-str">'/'</span> <span class="tok-kw">and</span> slice.*[i + <span class="tok-number">1</span>] == <span class="tok-str">'*'</span>) {</span>
<span class="line" id="L610">                multiline_comment_depth.* += <span class="tok-number">1</span>;</span>
<span class="line" id="L611">                i += <span class="tok-number">2</span>;</span>
<span class="line" id="L612">                found_comment_marker = <span class="tok-null">true</span>;</span>
<span class="line" id="L613">                <span class="tok-kw">break</span>;</span>
<span class="line" id="L614">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (slice.*[i] == <span class="tok-str">'*'</span> <span class="tok-kw">and</span> slice.*[i + <span class="tok-number">1</span>] == <span class="tok-str">'/'</span>) {</span>
<span class="line" id="L615">                multiline_comment_depth.* -= <span class="tok-number">1</span>;</span>
<span class="line" id="L616">                i += <span class="tok-number">2</span>;</span>
<span class="line" id="L617">                found_comment_marker = <span class="tok-null">true</span>;</span>
<span class="line" id="L618">                <span class="tok-kw">break</span>;</span>
<span class="line" id="L619">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L620">                i += <span class="tok-number">1</span>;</span>
<span class="line" id="L621">            }</span>
<span class="line" id="L622">        }</span>
<span class="line" id="L623"></span>
<span class="line" id="L624">        <span class="tok-kw">const</span> comment_end_index = <span class="tok-kw">if</span> (found_comment_marker) i - <span class="tok-number">2</span> <span class="tok-kw">else</span> i;</span>
<span class="line" id="L625">        <span class="tok-kw">const</span> comment = trim(<span class="tok-type">u8</span>, slice.*[<span class="tok-number">2</span>..comment_end_index], <span class="tok-str">&quot; &quot;</span>);</span>
<span class="line" id="L626">        <span class="tok-kw">const</span> token = Token{ .<span class="tok-type">type</span> = .Comment, .slice = comment };</span>
<span class="line" id="L627">        slice.* = slice.*[i..];</span>
<span class="line" id="L628">        <span class="tok-kw">return</span> token;</span>
<span class="line" id="L629">    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (slice.*[<span class="tok-number">0</span>] == <span class="tok-str">'\t'</span>) {</span>
<span class="line" id="L630">        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;</span>
<span class="line" id="L631">        <span class="tok-kw">for</span> (slice.*[<span class="tok-number">1</span>..]) |character| {</span>
<span class="line" id="L632">            <span class="tok-kw">if</span> (character != <span class="tok-str">'\t'</span>) {</span>
<span class="line" id="L633">                <span class="tok-kw">break</span>;</span>
<span class="line" id="L634">            }</span>
<span class="line" id="L635">            i += <span class="tok-number">1</span>;</span>
<span class="line" id="L636">        }</span>
<span class="line" id="L637"></span>
<span class="line" id="L638">        <span class="tok-kw">const</span> token = Token{ .<span class="tok-type">type</span> = .Tabs, .slice = slice.*[<span class="tok-number">0</span>..i] };</span>
<span class="line" id="L639">        slice.* = slice.*[i..];</span>
<span class="line" id="L640">        <span class="tok-kw">return</span> token;</span>
<span class="line" id="L641">    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (slice.*[<span class="tok-number">0</span>] == <span class="tok-str">' '</span>) {</span>
<span class="line" id="L642">        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;</span>
<span class="line" id="L643">        <span class="tok-kw">for</span> (slice.*[<span class="tok-number">1</span>..]) |character| {</span>
<span class="line" id="L644">            <span class="tok-kw">if</span> (character != <span class="tok-str">' '</span>) {</span>
<span class="line" id="L645">                <span class="tok-kw">break</span>;</span>
<span class="line" id="L646">            }</span>
<span class="line" id="L647">            i += <span class="tok-number">1</span>;</span>
<span class="line" id="L648">        }</span>
<span class="line" id="L649"></span>
<span class="line" id="L650">        <span class="tok-kw">const</span> token = Token{ .<span class="tok-type">type</span> = .Spaces, .slice = slice.*[<span class="tok-number">0</span>..i] };</span>
<span class="line" id="L651">        slice.* = slice.*[i..];</span>
<span class="line" id="L652">        <span class="tok-kw">return</span> token;</span>
<span class="line" id="L653">    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (slice.*[<span class="tok-number">0</span>] == <span class="tok-str">'='</span>) {</span>
<span class="line" id="L654">        <span class="tok-kw">const</span> token = Token{ .<span class="tok-type">type</span> = .Equals, .slice = slice.*[<span class="tok-number">0</span>..<span class="tok-number">1</span>] };</span>
<span class="line" id="L655">        <span class="tok-comment">// TODO: Check what happens if a line ends with an =, since I don't know if slice ends with '\0'</span>
</span>
<span class="line" id="L656">        <span class="tok-comment">// TODO: The same question goes for the comment parsing code that reads 2 characters</span>
</span>
<span class="line" id="L657">        slice.* = slice.*[<span class="tok-number">1</span>..];</span>
<span class="line" id="L658">        <span class="tok-kw">return</span> token;</span>
<span class="line" id="L659">    }</span>
<span class="line" id="L660"></span>
<span class="line" id="L661">    <span class="tok-comment">// A Sentence ends with a word, or the start of a comment</span>
</span>
<span class="line" id="L662">    <span class="tok-kw">var</span> end_index: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;</span>
<span class="line" id="L663">    <span class="tok-kw">var</span> sentence_end_index: <span class="tok-type">usize</span> = end_index;</span>
<span class="line" id="L664">    <span class="tok-kw">while</span> (end_index &lt; slice.len) {</span>
<span class="line" id="L665">        <span class="tok-kw">if</span> (slice.*[end_index] == <span class="tok-str">'='</span> <span class="tok-kw">and</span> !seen_property.*) {</span>
<span class="line" id="L666">            <span class="tok-kw">break</span>;</span>
<span class="line" id="L667">        }</span>
<span class="line" id="L668">        <span class="tok-kw">if</span> (slice.*[end_index] == <span class="tok-str">'\n'</span> <span class="tok-kw">or</span> slice.*[end_index] == <span class="tok-str">'\t'</span> <span class="tok-kw">or</span> (slice.*[end_index] == <span class="tok-str">'/'</span> <span class="tok-kw">and</span> (slice.*[end_index + <span class="tok-number">1</span>] == <span class="tok-str">'*'</span> <span class="tok-kw">or</span> slice.*[end_index + <span class="tok-number">1</span>] == <span class="tok-str">'/'</span>))) {</span>
<span class="line" id="L669">            <span class="tok-kw">break</span>;</span>
<span class="line" id="L670">        }</span>
<span class="line" id="L671">        <span class="tok-kw">if</span> (slice.*[end_index] != <span class="tok-str">' '</span>) {</span>
<span class="line" id="L672">            sentence_end_index = end_index + <span class="tok-number">1</span>;</span>
<span class="line" id="L673">        }</span>
<span class="line" id="L674">        end_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L675">    }</span>
<span class="line" id="L676"></span>
<span class="line" id="L677">    seen_property.* = <span class="tok-null">true</span>;</span>
<span class="line" id="L678">    <span class="tok-kw">const</span> token = Token{ .<span class="tok-type">type</span> = .Sentence, .slice = slice.*[<span class="tok-number">0</span>..sentence_end_index] };</span>
<span class="line" id="L679">    slice.* = slice.*[sentence_end_index..];</span>
<span class="line" id="L680">    <span class="tok-kw">return</span> token;</span>
<span class="line" id="L681">}</span>
<span class="line" id="L682"></span>
<span class="line" id="L683"><span class="tok-kw">fn</span> <span class="tok-fn">getAstFromTokens</span>(tokens: *ArrayList(Token), allocator: Allocator, diagnostics: *Diagnostics) !ArrayList(Node) {</span>
<span class="line" id="L684">    <span class="tok-kw">var</span> ast = ArrayList(Node).init(allocator);</span>
<span class="line" id="L685"></span>
<span class="line" id="L686">    <span class="tok-comment">// The game ignores the indentation of the first line of a file,</span>
</span>
<span class="line" id="L687">    <span class="tok-comment">// but we choose to trim that indentation</span>
</span>
<span class="line" id="L688">    <span class="tok-kw">var</span> token_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L689">    <span class="tok-kw">if</span> (lineHasSentence(tokens, token_index)) {</span>
<span class="line" id="L690">        token_index = leftTrimFirstLine(tokens);</span>
<span class="line" id="L691">    }</span>
<span class="line" id="L692"></span>
<span class="line" id="L693">    <span class="tok-kw">while</span> (token_index &lt; tokens.items.len) {</span>
<span class="line" id="L694">        <span class="tok-kw">const</span> node = <span class="tok-kw">try</span> getNode(tokens, &amp;token_index, <span class="tok-number">0</span>, allocator, diagnostics);</span>
<span class="line" id="L695">        <span class="tok-kw">try</span> ast.append(node);</span>
<span class="line" id="L696">    }</span>
<span class="line" id="L697"></span>
<span class="line" id="L698">    <span class="tok-kw">return</span> ast;</span>
<span class="line" id="L699">}</span>
<span class="line" id="L700"></span>
<span class="line" id="L701"><span class="tok-kw">fn</span> <span class="tok-fn">lineHasSentence</span>(tokens: *ArrayList(Token), token_index_: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L702">    <span class="tok-kw">var</span> token_index = token_index_;</span>
<span class="line" id="L703"></span>
<span class="line" id="L704">    <span class="tok-kw">while</span> (token_index &lt; tokens.items.len) {</span>
<span class="line" id="L705">        <span class="tok-kw">const</span> token = tokens.items[token_index];</span>
<span class="line" id="L706"></span>
<span class="line" id="L707">        <span class="tok-kw">if</span> (token.<span class="tok-type">type</span> == .Newline) {</span>
<span class="line" id="L708">            <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L709">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (token.<span class="tok-type">type</span> == .Sentence) {</span>
<span class="line" id="L710">            <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L711">        }</span>
<span class="line" id="L712"></span>
<span class="line" id="L713">        token_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L714">    }</span>
<span class="line" id="L715"></span>
<span class="line" id="L716">    <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L717">}</span>
<span class="line" id="L718"></span>
<span class="line" id="L719"><span class="tok-kw">fn</span> <span class="tok-fn">leftTrimFirstLine</span>(tokens: *ArrayList(Token)) <span class="tok-type">usize</span> {</span>
<span class="line" id="L720">    <span class="tok-kw">var</span> token_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L721"></span>
<span class="line" id="L722">    <span class="tok-kw">while</span> (tokens.items[token_index].<span class="tok-type">type</span> != .Sentence) {</span>
<span class="line" id="L723">        token_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L724">    }</span>
<span class="line" id="L725"></span>
<span class="line" id="L726">    <span class="tok-kw">return</span> token_index;</span>
<span class="line" id="L727">}</span>
<span class="line" id="L728"></span>
<span class="line" id="L729"><span class="tok-kw">fn</span> <span class="tok-fn">getNode</span>(tokens: *ArrayList(Token), token_index: *<span class="tok-type">usize</span>, depth: <span class="tok-type">i32</span>, allocator: Allocator, diagnostics: *Diagnostics) <span class="tok-kw">error</span>{ TooManyTabs, UnexpectedToken, OutOfMemory }!Node {</span>
<span class="line" id="L730">    <span class="tok-kw">const</span> States = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L731">        Start,</span>
<span class="line" id="L732">        Property,</span>
<span class="line" id="L733">        Equals,</span>
<span class="line" id="L734">        Value,</span>
<span class="line" id="L735">        Newline,</span>
<span class="line" id="L736">    };</span>
<span class="line" id="L737"></span>
<span class="line" id="L738">    <span class="tok-kw">const</span> NodeError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L739">        TooManyTabs,</span>
<span class="line" id="L740">        UnexpectedToken,</span>
<span class="line" id="L741">    };</span>
<span class="line" id="L742"></span>
<span class="line" id="L743">    <span class="tok-kw">var</span> seen: States = .Start;</span>
<span class="line" id="L744"></span>
<span class="line" id="L745">    <span class="tok-kw">var</span> node = Node{</span>
<span class="line" id="L746">        .comments = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(allocator),</span>
<span class="line" id="L747">        .children = ArrayList(Node).init(allocator),</span>
<span class="line" id="L748">    };</span>
<span class="line" id="L749"></span>
<span class="line" id="L750">    <span class="tok-kw">var</span> token = tokens.items[token_index.*];</span>
<span class="line" id="L751"></span>
<span class="line" id="L752">    <span class="tok-kw">var</span> line_depth = getLineDepth(tokens, token_index.*);</span>
<span class="line" id="L753">    <span class="tok-kw">if</span> (line_depth &gt; depth) {</span>
<span class="line" id="L754">        calculateLineAndColumnDiagnostics(tokens, token_index.*, diagnostics);</span>
<span class="line" id="L755">        <span class="tok-kw">return</span> NodeError.TooManyTabs;</span>
<span class="line" id="L756">    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (line_depth &lt; depth) {</span>
<span class="line" id="L757">        <span class="tok-kw">return</span> node;</span>
<span class="line" id="L758">    }</span>
<span class="line" id="L759"></span>
<span class="line" id="L760">    <span class="tok-kw">var</span> checked_line_depth = <span class="tok-null">true</span>;</span>
<span class="line" id="L761"></span>
<span class="line" id="L762">    <span class="tok-kw">while</span> (token_index.* &lt; tokens.items.len) {</span>
<span class="line" id="L763">        token = tokens.items[token_index.*];</span>
<span class="line" id="L764"></span>
<span class="line" id="L765">        <span class="tok-kw">if</span> (seen == .Start <span class="tok-kw">and</span> token.<span class="tok-type">type</span> == .Sentence) {</span>
<span class="line" id="L766">            <span class="tok-comment">// This if-statement is deliberately in a loop,</span>
</span>
<span class="line" id="L767">            <span class="tok-comment">// since whitespace and multiline comments may come before it</span>
</span>
<span class="line" id="L768">            node.property = token.slice;</span>
<span class="line" id="L769">            seen = .Property;</span>
<span class="line" id="L770">            token_index.* += <span class="tok-number">1</span>;</span>
<span class="line" id="L771">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (seen == .Newline <span class="tok-kw">and</span> !checked_line_depth) {</span>
<span class="line" id="L772">            checked_line_depth = <span class="tok-null">true</span>;</span>
<span class="line" id="L773"></span>
<span class="line" id="L774">            line_depth = getLineDepth(tokens, token_index.*);</span>
<span class="line" id="L775"></span>
<span class="line" id="L776">            <span class="tok-kw">if</span> (line_depth &gt; depth + <span class="tok-number">1</span>) {</span>
<span class="line" id="L777">                calculateLineAndColumnDiagnostics(tokens, token_index.*, diagnostics);</span>
<span class="line" id="L778">                <span class="tok-kw">return</span> NodeError.TooManyTabs;</span>
<span class="line" id="L779">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (line_depth == depth + <span class="tok-number">1</span>) {</span>
<span class="line" id="L780">                <span class="tok-kw">const</span> child_node = <span class="tok-kw">try</span> getNode(tokens, token_index, depth + <span class="tok-number">1</span>, allocator, diagnostics);</span>
<span class="line" id="L781">                <span class="tok-kw">try</span> node.children.append(child_node);</span>
<span class="line" id="L782">                checked_line_depth = <span class="tok-null">false</span>;</span>
<span class="line" id="L783">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L784">                <span class="tok-kw">return</span> node;</span>
<span class="line" id="L785">            }</span>
<span class="line" id="L786">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (seen == .Property <span class="tok-kw">and</span> token.<span class="tok-type">type</span> == .Equals) {</span>
<span class="line" id="L787">            seen = .Equals;</span>
<span class="line" id="L788">            token_index.* += <span class="tok-number">1</span>;</span>
<span class="line" id="L789">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (seen == .Equals <span class="tok-kw">and</span> token.<span class="tok-type">type</span> == .Sentence) {</span>
<span class="line" id="L790">            node.value = token.slice;</span>
<span class="line" id="L791">            seen = .Value;</span>
<span class="line" id="L792">            token_index.* += <span class="tok-number">1</span>;</span>
<span class="line" id="L793">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (token.<span class="tok-type">type</span> == .Comment) {</span>
<span class="line" id="L794">            <span class="tok-kw">if</span> (token.slice.len &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L795">                <span class="tok-kw">try</span> node.comments.append(token.slice);</span>
<span class="line" id="L796">            }</span>
<span class="line" id="L797">            token_index.* += <span class="tok-number">1</span>;</span>
<span class="line" id="L798">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (token.<span class="tok-type">type</span> == .Tabs <span class="tok-kw">or</span> token.<span class="tok-type">type</span> == .Spaces) {</span>
<span class="line" id="L799">            token_index.* += <span class="tok-number">1</span>;</span>
<span class="line" id="L800">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (token.<span class="tok-type">type</span> == .Newline) {</span>
<span class="line" id="L801">            seen = .Newline;</span>
<span class="line" id="L802">            token_index.* += <span class="tok-number">1</span>;</span>
<span class="line" id="L803">            checked_line_depth = <span class="tok-null">false</span>;</span>
<span class="line" id="L804">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L805">            diagnostics.token = token.slice;</span>
<span class="line" id="L806">            calculateLineAndColumnDiagnostics(tokens, token_index.*, diagnostics);</span>
<span class="line" id="L807">            <span class="tok-kw">return</span> NodeError.UnexpectedToken;</span>
<span class="line" id="L808">        }</span>
<span class="line" id="L809">    }</span>
<span class="line" id="L810"></span>
<span class="line" id="L811">    <span class="tok-kw">return</span> node;</span>
<span class="line" id="L812">}</span>
<span class="line" id="L813"></span>
<span class="line" id="L814"><span class="tok-kw">fn</span> <span class="tok-fn">getLineDepth</span>(tokens: *ArrayList(Token), token_index_: <span class="tok-type">usize</span>) <span class="tok-type">i32</span> {</span>
<span class="line" id="L815">    <span class="tok-kw">var</span> token_index = token_index_;</span>
<span class="line" id="L816"></span>
<span class="line" id="L817">    <span class="tok-kw">var</span> token = tokens.items[token_index];</span>
<span class="line" id="L818"></span>
<span class="line" id="L819">    <span class="tok-kw">if</span> (token.<span class="tok-type">type</span> == .Sentence) {</span>
<span class="line" id="L820">        <span class="tok-kw">return</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L821">    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (!lineHasSentence(tokens, token_index)) {</span>
<span class="line" id="L822">        <span class="tok-kw">return</span> getNextSentenceDepth(tokens, token_index);</span>
<span class="line" id="L823">    }</span>
<span class="line" id="L824"></span>
<span class="line" id="L825">    <span class="tok-kw">var</span> tabs_seen: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L826"></span>
<span class="line" id="L827">    <span class="tok-kw">while</span> (token_index &lt; tokens.items.len) {</span>
<span class="line" id="L828">        token = tokens.items[token_index];</span>
<span class="line" id="L829"></span>
<span class="line" id="L830">        <span class="tok-kw">if</span> (token.<span class="tok-type">type</span> == .Sentence) {</span>
<span class="line" id="L831">            <span class="tok-kw">return</span> tabs_seen;</span>
<span class="line" id="L832">        }</span>
<span class="line" id="L833"></span>
<span class="line" id="L834">        <span class="tok-kw">if</span> (token.<span class="tok-type">type</span> == .Tabs) {</span>
<span class="line" id="L835">            tabs_seen += <span class="tok-builtin">@intCast</span>(token.slice.len);</span>
<span class="line" id="L836">        }</span>
<span class="line" id="L837"></span>
<span class="line" id="L838">        token_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L839">    }</span>
<span class="line" id="L840"></span>
<span class="line" id="L841">    <span class="tok-comment">// If the end of the file is reached</span>
</span>
<span class="line" id="L842">    <span class="tok-comment">// TODO: Find a way to return the same depth as the previous Sentence line</span>
</span>
<span class="line" id="L843">    <span class="tok-comment">// It isn't as easy as &quot;return depth&quot;, since it can also be &quot;return depth + 1&quot;</span>
</span>
<span class="line" id="L844">    <span class="tok-kw">return</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L845">}</span>
<span class="line" id="L846"></span>
<span class="line" id="L847"><span class="tok-kw">fn</span> <span class="tok-fn">getNextSentenceDepth</span>(tokens: *ArrayList(Token), token_index_: <span class="tok-type">usize</span>) <span class="tok-type">i32</span> {</span>
<span class="line" id="L848">    <span class="tok-kw">var</span> token_index = token_index_;</span>
<span class="line" id="L849"></span>
<span class="line" id="L850">    <span class="tok-kw">var</span> tabs_seen: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L851"></span>
<span class="line" id="L852">    <span class="tok-kw">while</span> (token_index &lt; tokens.items.len) {</span>
<span class="line" id="L853">        <span class="tok-kw">const</span> token = tokens.items[token_index];</span>
<span class="line" id="L854"></span>
<span class="line" id="L855">        <span class="tok-kw">if</span> (token.<span class="tok-type">type</span> == .Newline) {</span>
<span class="line" id="L856">            tabs_seen = <span class="tok-number">0</span>;</span>
<span class="line" id="L857">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (token.<span class="tok-type">type</span> == .Sentence) {</span>
<span class="line" id="L858">            <span class="tok-kw">return</span> tabs_seen;</span>
<span class="line" id="L859">        }</span>
<span class="line" id="L860"></span>
<span class="line" id="L861">        <span class="tok-kw">if</span> (token.<span class="tok-type">type</span> == .Tabs) {</span>
<span class="line" id="L862">            tabs_seen += <span class="tok-builtin">@intCast</span>(token.slice.len);</span>
<span class="line" id="L863">        }</span>
<span class="line" id="L864"></span>
<span class="line" id="L865">        token_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L866">    }</span>
<span class="line" id="L867"></span>
<span class="line" id="L868">    <span class="tok-comment">// If the end of the file is reached</span>
</span>
<span class="line" id="L869">    <span class="tok-comment">// TODO: Find a way to return the same depth as the previous Sentence line</span>
</span>
<span class="line" id="L870">    <span class="tok-comment">// It isn't as easy as &quot;return depth&quot;, since it can also be &quot;return depth + 1&quot;</span>
</span>
<span class="line" id="L871">    <span class="tok-kw">return</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L872">}</span>
<span class="line" id="L873"></span>
<span class="line" id="L874"><span class="tok-kw">fn</span> <span class="tok-fn">calculateLineAndColumnDiagnostics</span>(tokens: *ArrayList(Token), token_index: <span class="tok-type">usize</span>, diagnostics: *Diagnostics) <span class="tok-type">void</span> {</span>
<span class="line" id="L875">    diagnostics.line = <span class="tok-number">1</span>;</span>
<span class="line" id="L876">    diagnostics.column = <span class="tok-number">1</span>;</span>
<span class="line" id="L877"></span>
<span class="line" id="L878">    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L879">    <span class="tok-kw">while</span> (i &lt; token_index) {</span>
<span class="line" id="L880">        <span class="tok-kw">var</span> token = tokens.items[i];</span>
<span class="line" id="L881"></span>
<span class="line" id="L882">        <span class="tok-kw">if</span> (token.<span class="tok-type">type</span> == .Newline) {</span>
<span class="line" id="L883">            diagnostics.line.? += <span class="tok-number">1</span>;</span>
<span class="line" id="L884">            diagnostics.column.? = <span class="tok-number">1</span>;</span>
<span class="line" id="L885">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L886">            diagnostics.column.? += <span class="tok-builtin">@intCast</span>(token.slice.len);</span>
<span class="line" id="L887">        }</span>
<span class="line" id="L888"></span>
<span class="line" id="L889">        i += <span class="tok-number">1</span>;</span>
<span class="line" id="L890">    }</span>
<span class="line" id="L891">}</span>
<span class="line" id="L892"></span>
<span class="line" id="L893"><span class="tok-kw">fn</span> <span class="tok-fn">getDataModuleCount</span>(file_tree: *IniFolder) <span class="tok-type">i32</span> {</span>
<span class="line" id="L894">    <span class="tok-kw">var</span> data_module_count: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L895">    getDataModuleCountRecursivelyFolder(file_tree, &amp;data_module_count);</span>
<span class="line" id="L896">    <span class="tok-kw">return</span> data_module_count;</span>
<span class="line" id="L897">}</span>
<span class="line" id="L898"></span>
<span class="line" id="L899"><span class="tok-kw">fn</span> <span class="tok-fn">getDataModuleCountRecursivelyFolder</span>(file_tree: *IniFolder, data_module_count: *<span class="tok-type">i32</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L900">    <span class="tok-kw">for</span> (file_tree.folders.items) |*folder| {</span>
<span class="line" id="L901">        getDataModuleCountRecursivelyFolder(folder, data_module_count);</span>
<span class="line" id="L902">    }</span>
<span class="line" id="L903"></span>
<span class="line" id="L904">    <span class="tok-kw">for</span> (file_tree.files.items) |file| {</span>
<span class="line" id="L905">        <span class="tok-kw">for</span> (file.ast.items) |*node| {</span>
<span class="line" id="L906">            getDataModuleCountRecursivelyNode(node, data_module_count);</span>
<span class="line" id="L907">        }</span>
<span class="line" id="L908">    }</span>
<span class="line" id="L909">}</span>
<span class="line" id="L910"></span>
<span class="line" id="L911"><span class="tok-kw">fn</span> <span class="tok-fn">getDataModuleCountRecursivelyNode</span>(node: *Node, data_module_count: *<span class="tok-type">i32</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L912">    <span class="tok-kw">if</span> (node.property) |node_property| {</span>
<span class="line" id="L913">        <span class="tok-kw">if</span> (strEql(node_property, <span class="tok-str">&quot;DataModule&quot;</span>)) {</span>
<span class="line" id="L914">            data_module_count.* += <span class="tok-number">1</span>;</span>
<span class="line" id="L915">        }</span>
<span class="line" id="L916">    }</span>
<span class="line" id="L917"></span>
<span class="line" id="L918">    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L919">        getDataModuleCountRecursivelyNode(child, data_module_count);</span>
<span class="line" id="L920">    }</span>
<span class="line" id="L921">}</span>
<span class="line" id="L922"></span>
<span class="line" id="L923"><span class="tok-comment">// Uninitialized is used to detect SupportedGameVersion being seen a second time</span>
</span>
<span class="line" id="L924"><span class="tok-kw">const</span> ModVersion = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L925">    Uninitialized,</span>
<span class="line" id="L926">    BeforePre6,</span>
<span class="line" id="L927">    Pre6,</span>
<span class="line" id="L928">};</span>
<span class="line" id="L929"></span>
<span class="line" id="L930"><span class="tok-kw">fn</span> <span class="tok-fn">getModVersion</span>(file_tree: *IniFolder) !ModVersion {</span>
<span class="line" id="L931">    <span class="tok-kw">var</span> mod_version = ModVersion.Uninitialized;</span>
<span class="line" id="L932"></span>
<span class="line" id="L933">    <span class="tok-kw">try</span> getModVersionRecursivelyFolder(file_tree, &amp;mod_version);</span>
<span class="line" id="L934"></span>
<span class="line" id="L935">    <span class="tok-kw">if</span> (mod_version == ModVersion.Uninitialized) {</span>
<span class="line" id="L936">        mod_version = ModVersion.BeforePre6;</span>
<span class="line" id="L937">    }</span>
<span class="line" id="L938"></span>
<span class="line" id="L939">    <span class="tok-kw">return</span> mod_version;</span>
<span class="line" id="L940">}</span>
<span class="line" id="L941"></span>
<span class="line" id="L942"><span class="tok-kw">fn</span> <span class="tok-fn">getModVersionRecursivelyFolder</span>(file_tree: *IniFolder, mod_version: *ModVersion) !<span class="tok-type">void</span> {</span>
<span class="line" id="L943">    <span class="tok-kw">for</span> (file_tree.folders.items) |*folder| {</span>
<span class="line" id="L944">        <span class="tok-kw">try</span> getModVersionRecursivelyFolder(folder, mod_version);</span>
<span class="line" id="L945">    }</span>
<span class="line" id="L946"></span>
<span class="line" id="L947">    <span class="tok-kw">for</span> (file_tree.files.items) |file| {</span>
<span class="line" id="L948">        <span class="tok-kw">for</span> (file.ast.items) |*node| {</span>
<span class="line" id="L949">            <span class="tok-kw">try</span> getModVersionRecursivelyNode(node, mod_version);</span>
<span class="line" id="L950">        }</span>
<span class="line" id="L951">    }</span>
<span class="line" id="L952">}</span>
<span class="line" id="L953"></span>
<span class="line" id="L954"><span class="tok-kw">fn</span> <span class="tok-fn">getModVersionRecursivelyNode</span>(node: *Node, mod_version: *ModVersion) !<span class="tok-type">void</span> {</span>
<span class="line" id="L955">    <span class="tok-kw">const</span> ModVersionErrors = <span class="tok-kw">error</span>{</span>
<span class="line" id="L956">        AlreadySeenASupportedGameVersion,</span>
<span class="line" id="L957">        UnrecognizedModVersion,</span>
<span class="line" id="L958">    };</span>
<span class="line" id="L959"></span>
<span class="line" id="L960">    <span class="tok-kw">if</span> (node.property) |node_property| {</span>
<span class="line" id="L961">        <span class="tok-kw">if</span> (strEql(node_property, <span class="tok-str">&quot;SupportedGameVersion&quot;</span>)) {</span>
<span class="line" id="L962">            <span class="tok-kw">if</span> (node.value) |value| {</span>
<span class="line" id="L963">                <span class="tok-kw">if</span> (mod_version.* != ModVersion.Uninitialized) {</span>
<span class="line" id="L964">                    <span class="tok-kw">return</span> ModVersionErrors.AlreadySeenASupportedGameVersion;</span>
<span class="line" id="L965">                }</span>
<span class="line" id="L966">                <span class="tok-kw">if</span> (strEql(value, <span class="tok-str">&quot;6.0.0&quot;</span>)) {</span>
<span class="line" id="L967">                    mod_version.* = ModVersion.Pre6;</span>
<span class="line" id="L968">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (strEql(value, <span class="tok-str">&quot;Pre-Release 3.0&quot;</span>) <span class="tok-kw">or</span> strEql(value, <span class="tok-str">&quot;Pre-Release 4.0&quot;</span>) <span class="tok-kw">or</span> strEql(value, <span class="tok-str">&quot;Pre-Release 5.0&quot;</span>) <span class="tok-kw">or</span> strEql(value, <span class="tok-str">&quot;5.1.0&quot;</span>)) {</span>
<span class="line" id="L969">                    mod_version.* = ModVersion.BeforePre6;</span>
<span class="line" id="L970">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L971">                    <span class="tok-kw">return</span> ModVersionErrors.UnrecognizedModVersion;</span>
<span class="line" id="L972">                }</span>
<span class="line" id="L973">            }</span>
<span class="line" id="L974">        }</span>
<span class="line" id="L975">    }</span>
<span class="line" id="L976"></span>
<span class="line" id="L977">    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L978">        <span class="tok-kw">try</span> getModVersionRecursivelyNode(child, mod_version);</span>
<span class="line" id="L979">    }</span>
<span class="line" id="L980">}</span>
<span class="line" id="L981"></span>
<span class="line" id="L982"><span class="tok-kw">fn</span> <span class="tok-fn">replaceMagentaInRgbPngsWithAlpha</span>(output_folder_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L983">    <span class="tok-kw">var</span> iterable_dir = <span class="tok-kw">try</span> std.fs.openIterableDirAbsolute(output_folder_path, .{});</span>
<span class="line" id="L984">    <span class="tok-kw">defer</span> iterable_dir.close();</span>
<span class="line" id="L985">    <span class="tok-kw">var</span> dir_iterator = iterable_dir.iterate();</span>
<span class="line" id="L986"></span>
<span class="line" id="L987">    <span class="tok-kw">while</span> (<span class="tok-kw">try</span> dir_iterator.next()) |entry| {</span>
<span class="line" id="L988">        <span class="tok-kw">if</span> (entry.kind == std.fs.File.Kind.file <span class="tok-kw">and</span> strEql(extension(entry.name), <span class="tok-str">&quot;.png&quot;</span>)) {</span>
<span class="line" id="L989">            <span class="tok-kw">const</span> output_file_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ output_folder_path, entry.name });</span>
<span class="line" id="L990"></span>
<span class="line" id="L991">            <span class="tok-kw">if</span> (<span class="tok-kw">try</span> pngIsRgb(output_file_path)) {</span>
<span class="line" id="L992">                <span class="tok-kw">var</span> tmpdir_output_folder = tmpDir(.{});</span>
<span class="line" id="L993">                <span class="tok-kw">defer</span> tmpdir_output_folder.cleanup();</span>
<span class="line" id="L994"></span>
<span class="line" id="L995">                <span class="tok-kw">var</span> tmpdir_output_folder_path_buffer: [MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L996">                <span class="tok-kw">const</span> tmpdir_output_folder_path = <span class="tok-kw">try</span> tmpdir_output_folder.dir.realpath(<span class="tok-str">&quot;.&quot;</span>, &amp;tmpdir_output_folder_path_buffer);</span>
<span class="line" id="L997"></span>
<span class="line" id="L998">                <span class="tok-comment">// This file will have (255, 0, 255) replaced with (255, 0, 255, 0)</span>
</span>
<span class="line" id="L999">                <span class="tok-kw">const</span> tmp_alpha_file_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ tmpdir_output_folder_path, <span class="tok-str">&quot;alpha.png&quot;</span> });</span>
<span class="line" id="L1000"></span>
<span class="line" id="L1001">                <span class="tok-comment">// TODO: ffmpeg won't always be available, so include its source code and call that instead</span>
</span>
<span class="line" id="L1002">                <span class="tok-comment">// This replaces magenta with transparency</span>
</span>
<span class="line" id="L1003">                <span class="tok-comment">// -y allows overwriting output files</span>
</span>
<span class="line" id="L1004">                <span class="tok-comment">//</span>
</span>
<span class="line" id="L1005">                <span class="tok-comment">// Note that &quot;colorkey&quot; its &quot;similarity&quot; value has a default, and minimum, of 0.01,</span>
</span>
<span class="line" id="L1006">                <span class="tok-comment">// which means that colors that are very close to (255, 0, 255) also turn transparent.</span>
</span>
<span class="line" id="L1007">                <span class="tok-comment">// This is fine however, since I checked that the CC palette doesn't contain other colors</span>
</span>
<span class="line" id="L1008">                <span class="tok-comment">// that are close enough to magenta to be turned transparent.</span>
</span>
<span class="line" id="L1009">                <span class="tok-kw">const</span> argv_alpha = [_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ <span class="tok-str">&quot;ffmpeg&quot;</span>, <span class="tok-str">&quot;-i&quot;</span>, output_file_path, <span class="tok-str">&quot;-vf&quot;</span>, <span class="tok-str">&quot;colorkey=magenta&quot;</span>, <span class="tok-str">&quot;-y&quot;</span>, tmp_alpha_file_path };</span>
<span class="line" id="L1010">                <span class="tok-kw">const</span> result_alpha = <span class="tok-kw">try</span> std.ChildProcess.exec(.{ .argv = &amp;argv_alpha, .allocator = allocator });</span>
<span class="line" id="L1011">                _ = result_alpha;</span>
<span class="line" id="L1012"></span>
<span class="line" id="L1013">                <span class="tok-comment">// This file will have (r=255, g=0, b=255, a=0) replaced with (r=0, g=0, b=0, a=0), as CC requires all RGB to be 0 when alpha is 0</span>
</span>
<span class="line" id="L1014">                <span class="tok-kw">const</span> tmp_zero_file_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ tmpdir_output_folder_path, <span class="tok-str">&quot;zero.png&quot;</span> });</span>
<span class="line" id="L1015"></span>
<span class="line" id="L1016">                <span class="tok-comment">// This insanity is just asking ffmpeg to replace any (r=255, g=0, b=255, a=0) with (r=0, g=0, b=0, a=0)</span>
</span>
<span class="line" id="L1017">                <span class="tok-kw">const</span> argv_zero = [_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ <span class="tok-str">&quot;ffmpeg&quot;</span>, <span class="tok-str">&quot;-i&quot;</span>, tmp_alpha_file_path, <span class="tok-str">&quot;-vf&quot;</span>, <span class="tok-str">&quot;geq=r='if(eq(r(X,Y),255)*eq(g(X,Y),0)*eq(b(X,Y),255),0,r(X,Y))':g='if(eq(r(X,Y),255)*eq(g(X,Y),0)*eq(b(X,Y),255),0,g(X,Y))':b='if(eq(r(X,Y),255)*eq(g(X,Y),0)*eq(b(X,Y),255),0,b(X,Y))':a='alpha(X,Y)'&quot;</span>, <span class="tok-str">&quot;-y&quot;</span>, tmp_zero_file_path };</span>
<span class="line" id="L1018">                <span class="tok-kw">const</span> result_zero = <span class="tok-kw">try</span> std.ChildProcess.exec(.{ .argv = &amp;argv_zero, .allocator = allocator });</span>
<span class="line" id="L1019">                _ = result_zero;</span>
<span class="line" id="L1020"></span>
<span class="line" id="L1021">                <span class="tok-comment">// Overwrite the old png with the new one that has transparency</span>
</span>
<span class="line" id="L1022">                <span class="tok-kw">try</span> copyFileAbsolute(tmp_zero_file_path, output_file_path, .{});</span>
<span class="line" id="L1023">            }</span>
<span class="line" id="L1024">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (entry.kind == std.fs.File.Kind.directory) {</span>
<span class="line" id="L1025">            <span class="tok-kw">const</span> child_output_folder_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ output_folder_path, entry.name });</span>
<span class="line" id="L1026">            <span class="tok-kw">try</span> replaceMagentaInRgbPngsWithAlpha(child_output_folder_path, allocator);</span>
<span class="line" id="L1027">        }</span>
<span class="line" id="L1028">    }</span>
<span class="line" id="L1029">}</span>
<span class="line" id="L1030"></span>
<span class="line" id="L1031"><span class="tok-comment">// RGB, as opposed to indexed with a palette</span>
</span>
<span class="line" id="L1032"><span class="tok-kw">fn</span> <span class="tok-fn">pngIsRgb</span>(output_file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">bool</span> {</span>
<span class="line" id="L1033">    <span class="tok-kw">const</span> cwd = std.fs.cwd();</span>
<span class="line" id="L1034">    <span class="tok-kw">const</span> file = <span class="tok-kw">try</span> cwd.openFile(output_file_path, .{});</span>
<span class="line" id="L1035">    <span class="tok-kw">defer</span> file.close();</span>
<span class="line" id="L1036"></span>
<span class="line" id="L1037">    <span class="tok-kw">const</span> color_type_offset = <span class="tok-number">0x19</span>;</span>
<span class="line" id="L1038">    <span class="tok-kw">try</span> file.seekTo(color_type_offset);</span>
<span class="line" id="L1039"></span>
<span class="line" id="L1040">    <span class="tok-kw">const</span> color_type = <span class="tok-kw">try</span> file.reader().readByte();</span>
<span class="line" id="L1041"></span>
<span class="line" id="L1042">    <span class="tok-comment">// Note that 2 means rgb, so we deliberately don't care about rgba,</span>
</span>
<span class="line" id="L1043">    <span class="tok-comment">// since that'd be 6:</span>
</span>
<span class="line" id="L1044">    <span class="tok-comment">// https://en.wikipedia.org/wiki/PNG#Pixel_format</span>
</span>
<span class="line" id="L1045">    <span class="tok-kw">return</span> color_type == <span class="tok-number">2</span>;</span>
<span class="line" id="L1046">}</span>
<span class="line" id="L1047"></span>
<span class="line" id="L1048"><span class="tok-kw">const</span> nodeCallbackDef = <span class="tok-kw">fn</span> (node: *Node) <span class="tok-kw">error</span>{ ExpectedValue, InvalidCharacter, OutOfMemory }!<span class="tok-type">void</span>;</span>
<span class="line" id="L1049"></span>
<span class="line" id="L1050"><span class="tok-kw">fn</span> <span class="tok-fn">applyOnNodes</span>(<span class="tok-kw">comptime</span> nodeCallbackFn: nodeCallbackDef, file_tree: *IniFolder) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1051">    <span class="tok-kw">for</span> (file_tree.folders.items) |*folder| {</span>
<span class="line" id="L1052">        <span class="tok-kw">try</span> applyOnNodes(nodeCallbackFn, folder);</span>
<span class="line" id="L1053">    }</span>
<span class="line" id="L1054"></span>
<span class="line" id="L1055">    <span class="tok-kw">for</span> (file_tree.files.items) |file| {</span>
<span class="line" id="L1056">        <span class="tok-kw">for</span> (file.ast.items) |*node| {</span>
<span class="line" id="L1057">            <span class="tok-kw">try</span> applyOnNode(nodeCallbackFn, node);</span>
<span class="line" id="L1058">        }</span>
<span class="line" id="L1059">    }</span>
<span class="line" id="L1060">}</span>
<span class="line" id="L1061"></span>
<span class="line" id="L1062"><span class="tok-kw">fn</span> <span class="tok-fn">applyOnNode</span>(<span class="tok-kw">comptime</span> nodeCallbackFn: nodeCallbackDef, node: *Node) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1063">    <span class="tok-kw">try</span> nodeCallbackFn(node);</span>
<span class="line" id="L1064"></span>
<span class="line" id="L1065">    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L1066">        <span class="tok-kw">try</span> applyOnNode(nodeCallbackFn, child);</span>
<span class="line" id="L1067">    }</span>
<span class="line" id="L1068">}</span>
<span class="line" id="L1069"></span>
<span class="line" id="L1070"><span class="tok-kw">const</span> nodeAllocCallbackDef = <span class="tok-kw">fn</span> (node: *Node, allocator: Allocator) <span class="tok-kw">error</span>{ ExpectedValue, InvalidCharacter, OutOfMemory }!<span class="tok-type">void</span>;</span>
<span class="line" id="L1071"></span>
<span class="line" id="L1072"><span class="tok-kw">fn</span> <span class="tok-fn">applyOnNodesAlloc</span>(<span class="tok-kw">comptime</span> nodeAllocCallbackFn: nodeAllocCallbackDef, file_tree: *IniFolder, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1073">    <span class="tok-kw">for</span> (file_tree.folders.items) |*folder| {</span>
<span class="line" id="L1074">        <span class="tok-kw">try</span> applyOnNodesAlloc(nodeAllocCallbackFn, folder, allocator);</span>
<span class="line" id="L1075">    }</span>
<span class="line" id="L1076"></span>
<span class="line" id="L1077">    <span class="tok-kw">for</span> (file_tree.files.items) |file| {</span>
<span class="line" id="L1078">        <span class="tok-kw">for</span> (file.ast.items) |*node| {</span>
<span class="line" id="L1079">            <span class="tok-kw">try</span> applyOnNodeAlloc(nodeAllocCallbackFn, node, allocator);</span>
<span class="line" id="L1080">        }</span>
<span class="line" id="L1081">    }</span>
<span class="line" id="L1082">}</span>
<span class="line" id="L1083"></span>
<span class="line" id="L1084"><span class="tok-kw">fn</span> <span class="tok-fn">applyOnNodeAlloc</span>(<span class="tok-kw">comptime</span> nodeAllocCallbackFn: nodeAllocCallbackDef, node: *Node, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1085">    <span class="tok-kw">try</span> nodeAllocCallbackFn(node, allocator);</span>
<span class="line" id="L1086"></span>
<span class="line" id="L1087">    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L1088">        <span class="tok-kw">try</span> applyOnNodeAlloc(nodeAllocCallbackFn, child, allocator);</span>
<span class="line" id="L1089">    }</span>
<span class="line" id="L1090">}</span>
<span class="line" id="L1091"></span>
<span class="line" id="L1092"><span class="tok-kw">fn</span> <span class="tok-fn">pathToFilePath</span>(node: *Node) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1093">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L1094">        <span class="tok-kw">if</span> (strEql(property, <span class="tok-str">&quot;Path&quot;</span>)) {</span>
<span class="line" id="L1095">            node.property = <span class="tok-str">&quot;FilePath&quot;</span>;</span>
<span class="line" id="L1096">        }</span>
<span class="line" id="L1097">    }</span>
<span class="line" id="L1098">}</span>
<span class="line" id="L1099"></span>
<span class="line" id="L1100"><span class="tok-kw">fn</span> <span class="tok-fn">bmpExtensionToPng</span>(node: *Node, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1101">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L1102">        <span class="tok-kw">if</span> (strEql(property, <span class="tok-str">&quot;FilePath&quot;</span>)) {</span>
<span class="line" id="L1103">            <span class="tok-kw">if</span> (node.value) |path| {</span>
<span class="line" id="L1104">                <span class="tok-kw">if</span> (endsWith(<span class="tok-type">u8</span>, path, <span class="tok-str">&quot;.bmp&quot;</span>) <span class="tok-kw">and</span> !strEql(path, <span class="tok-str">&quot;palette.bmp&quot;</span>) <span class="tok-kw">and</span> !strEql(path, <span class="tok-str">&quot;palettemat.bmp&quot;</span>)) {</span>
<span class="line" id="L1105">                    <span class="tok-comment">// We have to dupe, since the u8s in path are const</span>
</span>
<span class="line" id="L1106">                    <span class="tok-kw">var</span> new_path = <span class="tok-kw">try</span> allocator.dupe(<span class="tok-type">u8</span>, path);</span>
<span class="line" id="L1107"></span>
<span class="line" id="L1108">                    new_path[new_path.len - <span class="tok-number">1</span>] = <span class="tok-str">'g'</span>;</span>
<span class="line" id="L1109">                    new_path[new_path.len - <span class="tok-number">2</span>] = <span class="tok-str">'n'</span>;</span>
<span class="line" id="L1110">                    new_path[new_path.len - <span class="tok-number">3</span>] = <span class="tok-str">'p'</span>;</span>
<span class="line" id="L1111"></span>
<span class="line" id="L1112">                    node.value = new_path;</span>
<span class="line" id="L1113">                }</span>
<span class="line" id="L1114">            }</span>
<span class="line" id="L1115">        }</span>
<span class="line" id="L1116">    }</span>
<span class="line" id="L1117">}</span>
<span class="line" id="L1118"></span>
<span class="line" id="L1119"><span class="tok-kw">fn</span> <span class="tok-fn">wavExtensionToFlac</span>(node: *Node, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1120">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L1121">        <span class="tok-kw">if</span> (strEql(property, <span class="tok-str">&quot;FilePath&quot;</span>)) {</span>
<span class="line" id="L1122">            <span class="tok-kw">if</span> (node.value) |path| {</span>
<span class="line" id="L1123">                <span class="tok-kw">if</span> (endsWith(<span class="tok-type">u8</span>, path, <span class="tok-str">&quot;.wav&quot;</span>)) {</span>
<span class="line" id="L1124">                    <span class="tok-comment">// Create a copy of the entry name that is one character longer, so the &quot;c&quot; in .flac fits</span>
</span>
<span class="line" id="L1125">                    <span class="tok-kw">var</span> new_path = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, path.len + <span class="tok-number">1</span>);</span>
<span class="line" id="L1126">                    <span class="tok-builtin">@memcpy</span>(new_path[<span class="tok-number">0</span>..path.len], path);</span>
<span class="line" id="L1127"></span>
<span class="line" id="L1128">                    new_path[new_path.len - <span class="tok-number">1</span>] = <span class="tok-str">'c'</span>;</span>
<span class="line" id="L1129">                    new_path[new_path.len - <span class="tok-number">2</span>] = <span class="tok-str">'a'</span>;</span>
<span class="line" id="L1130">                    new_path[new_path.len - <span class="tok-number">3</span>] = <span class="tok-str">'l'</span>;</span>
<span class="line" id="L1131">                    new_path[new_path.len - <span class="tok-number">4</span>] = <span class="tok-str">'f'</span>;</span>
<span class="line" id="L1132"></span>
<span class="line" id="L1133">                    node.value = new_path;</span>
<span class="line" id="L1134">                }</span>
<span class="line" id="L1135">            }</span>
<span class="line" id="L1136">        }</span>
<span class="line" id="L1137">    }</span>
<span class="line" id="L1138">}</span>
<span class="line" id="L1139"></span>
<span class="line" id="L1140"><span class="tok-kw">fn</span> <span class="tok-fn">parseIniCopyOfRules</span>(allocator: Allocator) !std.json.ArrayHashMap([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) {</span>
<span class="line" id="L1141">    <span class="tok-kw">const</span> text = <span class="tok-kw">try</span> readFile(<span class="tok-str">&quot;rules/ini_copy_of_rules.json&quot;</span>, allocator);</span>
<span class="line" id="L1142"></span>
<span class="line" id="L1143">    <span class="tok-kw">var</span> scanner = Scanner.initCompleteInput(allocator, text);</span>
<span class="line" id="L1144"></span>
<span class="line" id="L1145">    <span class="tok-kw">var</span> rules = <span class="tok-kw">try</span> std.json.ArrayHashMap([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).jsonParse(allocator, &amp;scanner, .{ .allocate = .alloc_if_needed, .max_value_len = default_max_value_len });</span>
<span class="line" id="L1146">    <span class="tok-kw">return</span> rules;</span>
<span class="line" id="L1147">}</span>
<span class="line" id="L1148"></span>
<span class="line" id="L1149"><span class="tok-kw">fn</span> <span class="tok-fn">applyIniCopyOfRules</span>(rules: std.json.ArrayHashMap([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>), file_tree: *IniFolder) <span class="tok-type">void</span> {</span>
<span class="line" id="L1150">    <span class="tok-kw">var</span> map_iterator = rules.map.iterator();</span>
<span class="line" id="L1151">    <span class="tok-kw">while</span> (map_iterator.next()) |map_entry| {</span>
<span class="line" id="L1152">        <span class="tok-kw">const</span> old_value = map_entry.key_ptr.*;</span>
<span class="line" id="L1153">        <span class="tok-kw">const</span> new_value = map_entry.value_ptr.*;</span>
<span class="line" id="L1154"></span>
<span class="line" id="L1155">        applyIniValueReplacementRulesRecursivelyFolder(file_tree, <span class="tok-str">&quot;CopyOf&quot;</span>, old_value, new_value);</span>
<span class="line" id="L1156">    }</span>
<span class="line" id="L1157">}</span>
<span class="line" id="L1158"></span>
<span class="line" id="L1159"><span class="tok-kw">fn</span> <span class="tok-fn">applyIniValueReplacementRulesRecursivelyFolder</span>(file_tree: *IniFolder, <span class="tok-kw">comptime</span> property: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, old_value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L1160">    <span class="tok-kw">for</span> (file_tree.folders.items) |*folder| {</span>
<span class="line" id="L1161">        applyIniValueReplacementRulesRecursivelyFolder(folder, property, old_value, new_value);</span>
<span class="line" id="L1162">    }</span>
<span class="line" id="L1163"></span>
<span class="line" id="L1164">    <span class="tok-kw">for</span> (file_tree.files.items) |file| {</span>
<span class="line" id="L1165">        <span class="tok-kw">for</span> (file.ast.items) |*node| {</span>
<span class="line" id="L1166">            applyIniValueReplacementRulesRecursivelyNode(node, property, old_value, new_value);</span>
<span class="line" id="L1167">        }</span>
<span class="line" id="L1168">    }</span>
<span class="line" id="L1169">}</span>
<span class="line" id="L1170"></span>
<span class="line" id="L1171"><span class="tok-kw">fn</span> <span class="tok-fn">applyIniValueReplacementRulesRecursivelyNode</span>(node: *Node, <span class="tok-kw">comptime</span> property: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, old_value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L1172">    <span class="tok-kw">if</span> (node.property) |node_property| {</span>
<span class="line" id="L1173">        <span class="tok-kw">if</span> (strEql(node_property, property)) {</span>
<span class="line" id="L1174">            <span class="tok-kw">if</span> (node.value) |value| {</span>
<span class="line" id="L1175">                <span class="tok-kw">if</span> (strEql(value, old_value)) {</span>
<span class="line" id="L1176">                    node.value = new_value;</span>
<span class="line" id="L1177">                }</span>
<span class="line" id="L1178">            }</span>
<span class="line" id="L1179">        }</span>
<span class="line" id="L1180">    }</span>
<span class="line" id="L1181"></span>
<span class="line" id="L1182">    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L1183">        applyIniValueReplacementRulesRecursivelyNode(child, property, old_value, new_value);</span>
<span class="line" id="L1184">    }</span>
<span class="line" id="L1185">}</span>
<span class="line" id="L1186"></span>
<span class="line" id="L1187"><span class="tok-kw">fn</span> <span class="tok-fn">parseIniFilePathRules</span>(allocator: Allocator) !std.json.ArrayHashMap([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) {</span>
<span class="line" id="L1188">    <span class="tok-kw">const</span> text = <span class="tok-kw">try</span> readFile(<span class="tok-str">&quot;rules/ini_file_path_rules.json&quot;</span>, allocator);</span>
<span class="line" id="L1189"></span>
<span class="line" id="L1190">    <span class="tok-kw">var</span> scanner = Scanner.initCompleteInput(allocator, text);</span>
<span class="line" id="L1191"></span>
<span class="line" id="L1192">    <span class="tok-kw">var</span> rules = <span class="tok-kw">try</span> std.json.ArrayHashMap([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).jsonParse(allocator, &amp;scanner, .{ .allocate = .alloc_if_needed, .max_value_len = default_max_value_len });</span>
<span class="line" id="L1193">    <span class="tok-kw">return</span> rules;</span>
<span class="line" id="L1194">}</span>
<span class="line" id="L1195"></span>
<span class="line" id="L1196"><span class="tok-kw">fn</span> <span class="tok-fn">applyIniFilePathRules</span>(rules: std.json.ArrayHashMap([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>), file_tree: *IniFolder) <span class="tok-type">void</span> {</span>
<span class="line" id="L1197">    <span class="tok-kw">var</span> map_iterator = rules.map.iterator();</span>
<span class="line" id="L1198">    <span class="tok-kw">while</span> (map_iterator.next()) |map_entry| {</span>
<span class="line" id="L1199">        <span class="tok-kw">const</span> old_value = map_entry.key_ptr.*;</span>
<span class="line" id="L1200">        <span class="tok-kw">const</span> new_value = map_entry.value_ptr.*;</span>
<span class="line" id="L1201"></span>
<span class="line" id="L1202">        applyIniValueReplacementRulesRecursivelyFolder(file_tree, <span class="tok-str">&quot;FilePath&quot;</span>, old_value, new_value);</span>
<span class="line" id="L1203">    }</span>
<span class="line" id="L1204">}</span>
<span class="line" id="L1205"></span>
<span class="line" id="L1206"><span class="tok-kw">fn</span> <span class="tok-fn">parseIniScriptPathRules</span>(allocator: Allocator) !std.json.ArrayHashMap([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) {</span>
<span class="line" id="L1207">    <span class="tok-kw">const</span> text = <span class="tok-kw">try</span> readFile(<span class="tok-str">&quot;rules/ini_script_path_rules.json&quot;</span>, allocator);</span>
<span class="line" id="L1208"></span>
<span class="line" id="L1209">    <span class="tok-kw">var</span> scanner = Scanner.initCompleteInput(allocator, text);</span>
<span class="line" id="L1210"></span>
<span class="line" id="L1211">    <span class="tok-kw">var</span> rules = <span class="tok-kw">try</span> std.json.ArrayHashMap([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).jsonParse(allocator, &amp;scanner, .{ .allocate = .alloc_if_needed, .max_value_len = default_max_value_len });</span>
<span class="line" id="L1212">    <span class="tok-kw">return</span> rules;</span>
<span class="line" id="L1213">}</span>
<span class="line" id="L1214"></span>
<span class="line" id="L1215"><span class="tok-kw">fn</span> <span class="tok-fn">applyIniScriptPathRules</span>(rules: std.json.ArrayHashMap([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>), file_tree: *IniFolder) <span class="tok-type">void</span> {</span>
<span class="line" id="L1216">    <span class="tok-kw">var</span> map_iterator = rules.map.iterator();</span>
<span class="line" id="L1217">    <span class="tok-kw">while</span> (map_iterator.next()) |map_entry| {</span>
<span class="line" id="L1218">        <span class="tok-kw">const</span> old_value = map_entry.key_ptr.*;</span>
<span class="line" id="L1219">        <span class="tok-kw">const</span> new_value = map_entry.value_ptr.*;</span>
<span class="line" id="L1220"></span>
<span class="line" id="L1221">        applyIniValueReplacementRulesRecursivelyFolder(file_tree, <span class="tok-str">&quot;ScriptPath&quot;</span>, old_value, new_value);</span>
<span class="line" id="L1222">    }</span>
<span class="line" id="L1223">}</span>
<span class="line" id="L1224"></span>
<span class="line" id="L1225"><span class="tok-kw">fn</span> <span class="tok-fn">parseIniPropertyRules</span>(allocator: Allocator) !std.json.ArrayHashMap([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) {</span>
<span class="line" id="L1226">    <span class="tok-kw">const</span> text = <span class="tok-kw">try</span> readFile(<span class="tok-str">&quot;rules/ini_property_rules.json&quot;</span>, allocator);</span>
<span class="line" id="L1227"></span>
<span class="line" id="L1228">    <span class="tok-kw">var</span> scanner = Scanner.initCompleteInput(allocator, text);</span>
<span class="line" id="L1229"></span>
<span class="line" id="L1230">    <span class="tok-kw">var</span> ini_property_rules = <span class="tok-kw">try</span> std.json.ArrayHashMap([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).jsonParse(allocator, &amp;scanner, .{ .allocate = .alloc_if_needed, .max_value_len = default_max_value_len });</span>
<span class="line" id="L1231">    <span class="tok-kw">return</span> ini_property_rules;</span>
<span class="line" id="L1232">}</span>
<span class="line" id="L1233"></span>
<span class="line" id="L1234"><span class="tok-kw">fn</span> <span class="tok-fn">applyIniPropertyRules</span>(ini_property_rules: std.json.ArrayHashMap([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>), file_tree: *IniFolder) <span class="tok-type">void</span> {</span>
<span class="line" id="L1235">    <span class="tok-kw">var</span> map_iterator = ini_property_rules.map.iterator();</span>
<span class="line" id="L1236">    <span class="tok-kw">while</span> (map_iterator.next()) |map_entry| {</span>
<span class="line" id="L1237">        <span class="tok-kw">const</span> old_property = map_entry.key_ptr.*;</span>
<span class="line" id="L1238">        <span class="tok-kw">const</span> new_property = map_entry.value_ptr.*;</span>
<span class="line" id="L1239"></span>
<span class="line" id="L1240">        applyIniPropertyRulesRecursivelyFolder(file_tree, old_property, new_property);</span>
<span class="line" id="L1241">    }</span>
<span class="line" id="L1242">}</span>
<span class="line" id="L1243"></span>
<span class="line" id="L1244"><span class="tok-kw">fn</span> <span class="tok-fn">applyIniPropertyRulesRecursivelyFolder</span>(file_tree: *IniFolder, old_property: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_property: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L1245">    <span class="tok-kw">for</span> (file_tree.folders.items) |*folder| {</span>
<span class="line" id="L1246">        applyIniPropertyRulesRecursivelyFolder(folder, old_property, new_property);</span>
<span class="line" id="L1247">    }</span>
<span class="line" id="L1248"></span>
<span class="line" id="L1249">    <span class="tok-kw">for</span> (file_tree.files.items) |file| {</span>
<span class="line" id="L1250">        <span class="tok-kw">for</span> (file.ast.items) |*node| {</span>
<span class="line" id="L1251">            applyIniPropertyRulesRecursivelyNode(node, old_property, new_property);</span>
<span class="line" id="L1252">        }</span>
<span class="line" id="L1253">    }</span>
<span class="line" id="L1254">}</span>
<span class="line" id="L1255"></span>
<span class="line" id="L1256"><span class="tok-kw">fn</span> <span class="tok-fn">applyIniPropertyRulesRecursivelyNode</span>(node: *Node, old_property: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_property: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L1257">    <span class="tok-kw">if</span> (node.property) |node_property| {</span>
<span class="line" id="L1258">        <span class="tok-kw">if</span> (strEql(node_property, old_property)) {</span>
<span class="line" id="L1259">            node.property = new_property;</span>
<span class="line" id="L1260">        }</span>
<span class="line" id="L1261">    }</span>
<span class="line" id="L1262"></span>
<span class="line" id="L1263">    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L1264">        applyIniPropertyRulesRecursivelyNode(child, old_property, new_property);</span>
<span class="line" id="L1265">    }</span>
<span class="line" id="L1266">}</span>
<span class="line" id="L1267"></span>
<span class="line" id="L1268"><span class="tok-kw">fn</span> <span class="tok-fn">parseIniRules</span>(allocator: Allocator) ![]Rule {</span>
<span class="line" id="L1269">    <span class="tok-kw">const</span> text = <span class="tok-kw">try</span> readFile(<span class="tok-str">&quot;rules/ini_rules.json&quot;</span>, allocator);</span>
<span class="line" id="L1270">    <span class="tok-kw">return</span> <span class="tok-kw">try</span> parseFromSliceLeaky([]Rule, allocator, text, .{});</span>
<span class="line" id="L1271">}</span>
<span class="line" id="L1272"></span>
<span class="line" id="L1273"><span class="tok-kw">fn</span> <span class="tok-fn">applyIniRules</span>(ini_rules: []Rule, file_tree: *IniFolder) <span class="tok-type">void</span> {</span>
<span class="line" id="L1274">    <span class="tok-kw">for</span> (ini_rules) |*rule| {</span>
<span class="line" id="L1275">        applyIniRulesRecursivelyFolder(file_tree, rule);</span>
<span class="line" id="L1276">    }</span>
<span class="line" id="L1277">}</span>
<span class="line" id="L1278"></span>
<span class="line" id="L1279"><span class="tok-kw">fn</span> <span class="tok-fn">applyIniRulesRecursivelyFolder</span>(file_tree: *IniFolder, rule: *Rule) <span class="tok-type">void</span> {</span>
<span class="line" id="L1280">    <span class="tok-kw">for</span> (file_tree.folders.items) |*folder| {</span>
<span class="line" id="L1281">        applyIniRulesRecursivelyFolder(folder, rule);</span>
<span class="line" id="L1282">    }</span>
<span class="line" id="L1283"></span>
<span class="line" id="L1284">    <span class="tok-kw">for</span> (file_tree.files.items) |file| {</span>
<span class="line" id="L1285">        <span class="tok-kw">for</span> (file.ast.items) |*node| {</span>
<span class="line" id="L1286">            applyIniRulesRecursivelyNode(node, rule);</span>
<span class="line" id="L1287">        }</span>
<span class="line" id="L1288">    }</span>
<span class="line" id="L1289">}</span>
<span class="line" id="L1290"></span>
<span class="line" id="L1291"><span class="tok-kw">fn</span> <span class="tok-fn">applyIniRulesRecursivelyNode</span>(node: *Node, rule: *Rule) <span class="tok-type">void</span> {</span>
<span class="line" id="L1292">    <span class="tok-kw">if</span> (node.property) |node_property| {</span>
<span class="line" id="L1293">        <span class="tok-kw">if</span> (strEql(node_property, rule.old_property)) {</span>
<span class="line" id="L1294">            <span class="tok-kw">if</span> (node.value) |node_value| {</span>
<span class="line" id="L1295">                <span class="tok-kw">if</span> (strEql(node_value, rule.old_value)) {</span>
<span class="line" id="L1296">                    node.property = rule.new_property;</span>
<span class="line" id="L1297">                    node.value = rule.new_value;</span>
<span class="line" id="L1298">                }</span>
<span class="line" id="L1299">            }</span>
<span class="line" id="L1300">        }</span>
<span class="line" id="L1301">    }</span>
<span class="line" id="L1302"></span>
<span class="line" id="L1303">    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L1304">        applyIniRulesRecursivelyNode(child, rule);</span>
<span class="line" id="L1305">    }</span>
<span class="line" id="L1306">}</span>
<span class="line" id="L1307"></span>
<span class="line" id="L1308"><span class="tok-kw">fn</span> <span class="tok-fn">parseIniSoundContainerRules</span>(allocator: Allocator) ![][]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1309">    <span class="tok-kw">const</span> text = <span class="tok-kw">try</span> readFile(<span class="tok-str">&quot;rules/ini_sound_container_rules.json&quot;</span>, allocator);</span>
<span class="line" id="L1310">    <span class="tok-kw">return</span> <span class="tok-kw">try</span> parseFromSliceLeaky([][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allocator, text, .{});</span>
<span class="line" id="L1311">}</span>
<span class="line" id="L1312"></span>
<span class="line" id="L1313"><span class="tok-kw">fn</span> <span class="tok-fn">applyIniSoundContainerRules</span>(ini_sound_container_rules: [][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, file_tree: *IniFolder) <span class="tok-type">void</span> {</span>
<span class="line" id="L1314">    <span class="tok-kw">for</span> (ini_sound_container_rules) |property| {</span>
<span class="line" id="L1315">        applyIniSoundContainerRulesRecursivelyFolder(file_tree, property);</span>
<span class="line" id="L1316">    }</span>
<span class="line" id="L1317">}</span>
<span class="line" id="L1318"></span>
<span class="line" id="L1319"><span class="tok-kw">fn</span> <span class="tok-fn">applyIniSoundContainerRulesRecursivelyFolder</span>(file_tree: *IniFolder, property: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L1320">    <span class="tok-kw">for</span> (file_tree.folders.items) |*folder| {</span>
<span class="line" id="L1321">        applyIniSoundContainerRulesRecursivelyFolder(folder, property);</span>
<span class="line" id="L1322">    }</span>
<span class="line" id="L1323"></span>
<span class="line" id="L1324">    <span class="tok-kw">for</span> (file_tree.files.items) |file| {</span>
<span class="line" id="L1325">        <span class="tok-kw">for</span> (file.ast.items) |*node| {</span>
<span class="line" id="L1326">            applyIniSoundContainerRulesRecursivelyNode(node, property);</span>
<span class="line" id="L1327">        }</span>
<span class="line" id="L1328">    }</span>
<span class="line" id="L1329">}</span>
<span class="line" id="L1330"></span>
<span class="line" id="L1331"><span class="tok-kw">fn</span> <span class="tok-fn">applyIniSoundContainerRulesRecursivelyNode</span>(node: *Node, property: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L1332">    <span class="tok-kw">if</span> (node.property) |node_property| {</span>
<span class="line" id="L1333">        <span class="tok-kw">if</span> (strEql(node_property, property)) {</span>
<span class="line" id="L1334">            <span class="tok-kw">if</span> (node.value) |node_value| {</span>
<span class="line" id="L1335">                <span class="tok-kw">if</span> (strEql(node_value, <span class="tok-str">&quot;Sound&quot;</span>)) {</span>
<span class="line" id="L1336">                    node.value = <span class="tok-str">&quot;SoundContainer&quot;</span>;</span>
<span class="line" id="L1337">                }</span>
<span class="line" id="L1338">            }</span>
<span class="line" id="L1339">        }</span>
<span class="line" id="L1340">    }</span>
<span class="line" id="L1341"></span>
<span class="line" id="L1342">    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L1343">        applyIniSoundContainerRulesRecursivelyNode(child, property);</span>
<span class="line" id="L1344">    }</span>
<span class="line" id="L1345">}</span>
<span class="line" id="L1346"></span>
<span class="line" id="L1347"><span class="tok-kw">fn</span> <span class="tok-fn">updateIniFileTree</span>(file_tree: *IniFolder, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1348">    <span class="tok-kw">try</span> applyOnNodesAlloc(addGetsHitByMosWhenHeldToShields, file_tree, allocator);</span>
<span class="line" id="L1349">    <span class="tok-kw">try</span> applyOnNodesAlloc(addGripStrength, file_tree, allocator);</span>
<span class="line" id="L1350">    <span class="tok-kw">try</span> applyOnNodesAlloc(addOrUpdateSupportedGameVersion, file_tree, allocator);</span>
<span class="line" id="L1351">    <span class="tok-kw">try</span> applyOnNodes(aemitterFuelToPemitter, file_tree);</span>
<span class="line" id="L1352"></span>
<span class="line" id="L1353">    <span class="tok-comment">// Handles AEJetpacks being made first-class citizens by Causeless</span>
</span>
<span class="line" id="L1354">    {</span>
<span class="line" id="L1355">        <span class="tok-kw">try</span> aemitterToAejetpack(file_tree, file_tree, allocator);</span>
<span class="line" id="L1356">        <span class="tok-kw">try</span> moveJetpackModifiers(file_tree, file_tree, allocator);</span>
<span class="line" id="L1357">        <span class="tok-kw">try</span> copyJetpack(file_tree, file_tree, allocator);</span>
<span class="line" id="L1358">        <span class="tok-kw">try</span> moveJetpackModifiers(file_tree, file_tree, allocator);</span>
<span class="line" id="L1359">        <span class="tok-kw">try</span> removeJetpackModifiersFromActors(file_tree, file_tree, allocator);</span>
<span class="line" id="L1360">    }</span>
<span class="line" id="L1361"></span>
<span class="line" id="L1362">    <span class="tok-kw">try</span> applyOnNodesAlloc(maxLengthToOffsets, file_tree, allocator);</span>
<span class="line" id="L1363">    <span class="tok-kw">try</span> applyOnNodesAlloc(maxMassToMaxInventoryMass, file_tree, allocator);</span>
<span class="line" id="L1364">    <span class="tok-kw">try</span> applyOnNodesAlloc(maxThrottleRangeToPositiveThrottleMultiplier, file_tree, allocator);</span>
<span class="line" id="L1365">    <span class="tok-kw">try</span> applyOnNodesAlloc(minThrottleRangeToNegativeThrottleMultiplier, file_tree, allocator);</span>
<span class="line" id="L1366"></span>
<span class="line" id="L1367">    <span class="tok-kw">try</span> pieMenu(<span class="tok-str">&quot;ACDropShip&quot;</span>, <span class="tok-str">&quot;Default Craft Pie Menu&quot;</span>, <span class="tok-number">2</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, file_tree, allocator);</span>
<span class="line" id="L1368">    <span class="tok-kw">try</span> pieMenu(<span class="tok-str">&quot;ACrab&quot;</span>, <span class="tok-str">&quot;Default Crab Pie Menu&quot;</span>, <span class="tok-number">2</span>, <span class="tok-number">2</span>, <span class="tok-number">2</span>, <span class="tok-number">2</span>, file_tree, allocator);</span>
<span class="line" id="L1369">    <span class="tok-kw">try</span> pieMenu(<span class="tok-str">&quot;ACRocket&quot;</span>, <span class="tok-str">&quot;Default Craft Pie Menu&quot;</span>, <span class="tok-number">2</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, file_tree, allocator);</span>
<span class="line" id="L1370">    <span class="tok-kw">try</span> pieMenu(<span class="tok-str">&quot;Actor&quot;</span>, <span class="tok-str">&quot;Default Actor Pie Menu&quot;</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, file_tree, allocator);</span>
<span class="line" id="L1371">    <span class="tok-kw">try</span> pieMenu(<span class="tok-str">&quot;AHuman&quot;</span>, <span class="tok-str">&quot;Default Human Pie Menu&quot;</span>, <span class="tok-number">2</span>, <span class="tok-number">2</span>, <span class="tok-number">2</span>, <span class="tok-number">2</span>, file_tree, allocator);</span>
<span class="line" id="L1372">    <span class="tok-kw">try</span> pieMenu(<span class="tok-str">&quot;Turret&quot;</span>, <span class="tok-str">&quot;Default Turret Pie Menu&quot;</span>, <span class="tok-number">2</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">1</span>, file_tree, allocator);</span>
<span class="line" id="L1373"></span>
<span class="line" id="L1374">    <span class="tok-kw">try</span> applyOnNodesAlloc(removeSlTerrainProperties, file_tree, allocator);</span>
<span class="line" id="L1375">    <span class="tok-kw">try</span> applyOnNodes(shovelFlashFix, file_tree);</span>
<span class="line" id="L1376">}</span>
<span class="line" id="L1377"></span>
<span class="line" id="L1378"><span class="tok-kw">fn</span> <span class="tok-fn">addGetsHitByMosWhenHeldToShields</span>(node: *Node, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1379">    <span class="tok-kw">if</span> (node.property) |node_property| {</span>
<span class="line" id="L1380">        <span class="tok-kw">if</span> (strEql(node_property, <span class="tok-str">&quot;AddDevice&quot;</span>)) {</span>
<span class="line" id="L1381">            <span class="tok-kw">if</span> (node.value) |node_value| {</span>
<span class="line" id="L1382">                <span class="tok-kw">if</span> (strEql(node_value, <span class="tok-str">&quot;HeldDevice&quot;</span>)) {</span>
<span class="line" id="L1383">                    <span class="tok-kw">var</span> children = &amp;node.children;</span>
<span class="line" id="L1384"></span>
<span class="line" id="L1385">                    <span class="tok-kw">var</span> is_in_shield_group = <span class="tok-null">false</span>;</span>
<span class="line" id="L1386"></span>
<span class="line" id="L1387">                    <span class="tok-kw">for</span> (children.items) |child| {</span>
<span class="line" id="L1388">                        <span class="tok-kw">if</span> (child.property) |property| {</span>
<span class="line" id="L1389">                            <span class="tok-kw">if</span> (strEql(property, <span class="tok-str">&quot;GetsHitByMOsWhenHeld&quot;</span>)) {</span>
<span class="line" id="L1390">                                <span class="tok-kw">return</span>;</span>
<span class="line" id="L1391">                            }</span>
<span class="line" id="L1392">                            <span class="tok-kw">if</span> (strEql(property, <span class="tok-str">&quot;AddToGroup&quot;</span>)) {</span>
<span class="line" id="L1393">                                <span class="tok-kw">if</span> (child.value) |value| {</span>
<span class="line" id="L1394">                                    <span class="tok-kw">if</span> (strEql(value, <span class="tok-str">&quot;Shields&quot;</span>)) {</span>
<span class="line" id="L1395">                                        is_in_shield_group = <span class="tok-null">true</span>;</span>
<span class="line" id="L1396">                                    }</span>
<span class="line" id="L1397">                                }</span>
<span class="line" id="L1398">                            }</span>
<span class="line" id="L1399">                        }</span>
<span class="line" id="L1400">                    }</span>
<span class="line" id="L1401"></span>
<span class="line" id="L1402">                    <span class="tok-kw">if</span> (!is_in_shield_group) {</span>
<span class="line" id="L1403">                        <span class="tok-kw">return</span>;</span>
<span class="line" id="L1404">                    }</span>
<span class="line" id="L1405"></span>
<span class="line" id="L1406">                    <span class="tok-kw">try</span> children.append(Node{</span>
<span class="line" id="L1407">                        .property = <span class="tok-str">&quot;GetsHitByMOsWhenHeld&quot;</span>,</span>
<span class="line" id="L1408">                        .value = <span class="tok-str">&quot;1&quot;</span>,</span>
<span class="line" id="L1409">                        .comments = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(allocator),</span>
<span class="line" id="L1410">                        .children = ArrayList(Node).init(allocator),</span>
<span class="line" id="L1411">                    });</span>
<span class="line" id="L1412">                }</span>
<span class="line" id="L1413">            }</span>
<span class="line" id="L1414">        }</span>
<span class="line" id="L1415">    }</span>
<span class="line" id="L1416">}</span>
<span class="line" id="L1417"></span>
<span class="line" id="L1418"><span class="tok-kw">fn</span> <span class="tok-fn">addGripStrength</span>(node: *Node, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1419">    <span class="tok-kw">if</span> (node.property) |node_property| {</span>
<span class="line" id="L1420">        <span class="tok-kw">if</span> (strEql(node_property, <span class="tok-str">&quot;AddActor&quot;</span>)) {</span>
<span class="line" id="L1421">            <span class="tok-kw">if</span> (node.value) |node_value| {</span>
<span class="line" id="L1422">                <span class="tok-kw">if</span> (strEql(node_value, <span class="tok-str">&quot;Arm&quot;</span>)) {</span>
<span class="line" id="L1423">                    <span class="tok-kw">var</span> children = &amp;node.children;</span>
<span class="line" id="L1424"></span>
<span class="line" id="L1425">                    <span class="tok-kw">for</span> (children.items) |child| {</span>
<span class="line" id="L1426">                        <span class="tok-kw">if</span> (child.property) |property| {</span>
<span class="line" id="L1427">                            <span class="tok-kw">if</span> (strEql(property, <span class="tok-str">&quot;GripStrength&quot;</span>)) {</span>
<span class="line" id="L1428">                                <span class="tok-kw">return</span>;</span>
<span class="line" id="L1429">                            }</span>
<span class="line" id="L1430">                        }</span>
<span class="line" id="L1431">                    }</span>
<span class="line" id="L1432"></span>
<span class="line" id="L1433">                    <span class="tok-kw">try</span> children.append(Node{</span>
<span class="line" id="L1434">                        .property = <span class="tok-str">&quot;GripStrength&quot;</span>,</span>
<span class="line" id="L1435">                        .value = <span class="tok-str">&quot;424242&quot;</span>,</span>
<span class="line" id="L1436">                        .comments = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(allocator),</span>
<span class="line" id="L1437">                        .children = ArrayList(Node).init(allocator),</span>
<span class="line" id="L1438">                    });</span>
<span class="line" id="L1439">                }</span>
<span class="line" id="L1440">            }</span>
<span class="line" id="L1441">        }</span>
<span class="line" id="L1442">    }</span>
<span class="line" id="L1443">}</span>
<span class="line" id="L1444"></span>
<span class="line" id="L1445"><span class="tok-kw">fn</span> <span class="tok-fn">addOrUpdateSupportedGameVersion</span>(node: *Node, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1446">    <span class="tok-kw">const</span> converter_game_version = <span class="tok-str">&quot;6.0.0&quot;</span>;</span>
<span class="line" id="L1447"></span>
<span class="line" id="L1448">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L1449">        <span class="tok-kw">if</span> (strEql(property, <span class="tok-str">&quot;DataModule&quot;</span>)) {</span>
<span class="line" id="L1450">            <span class="tok-kw">var</span> has_supported_game_version = <span class="tok-null">false</span>;</span>
<span class="line" id="L1451"></span>
<span class="line" id="L1452">            <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L1453">                <span class="tok-kw">if</span> (child.property) |child_property| {</span>
<span class="line" id="L1454">                    <span class="tok-kw">if</span> (strEql(child_property, <span class="tok-str">&quot;SupportedGameVersion&quot;</span>)) {</span>
<span class="line" id="L1455">                        has_supported_game_version = <span class="tok-null">true</span>;</span>
<span class="line" id="L1456"></span>
<span class="line" id="L1457">                        <span class="tok-kw">if</span> (child.value) |child_value| {</span>
<span class="line" id="L1458">                            <span class="tok-kw">if</span> (!strEql(child_value, converter_game_version)) {</span>
<span class="line" id="L1459">                                child.value = converter_game_version;</span>
<span class="line" id="L1460">                            }</span>
<span class="line" id="L1461">                        }</span>
<span class="line" id="L1462"></span>
<span class="line" id="L1463">                        <span class="tok-kw">break</span>;</span>
<span class="line" id="L1464">                    }</span>
<span class="line" id="L1465">                }</span>
<span class="line" id="L1466">            }</span>
<span class="line" id="L1467"></span>
<span class="line" id="L1468">            <span class="tok-kw">if</span> (!has_supported_game_version) {</span>
<span class="line" id="L1469">                <span class="tok-kw">try</span> node.children.append(Node{</span>
<span class="line" id="L1470">                    .property = <span class="tok-str">&quot;SupportedGameVersion&quot;</span>,</span>
<span class="line" id="L1471">                    .value = converter_game_version,</span>
<span class="line" id="L1472">                    .comments = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(allocator),</span>
<span class="line" id="L1473">                    .children = ArrayList(Node).init(allocator),</span>
<span class="line" id="L1474">                });</span>
<span class="line" id="L1475">            }</span>
<span class="line" id="L1476">        }</span>
<span class="line" id="L1477">    }</span>
<span class="line" id="L1478">}</span>
<span class="line" id="L1479"></span>
<span class="line" id="L1480"><span class="tok-kw">fn</span> <span class="tok-fn">aemitterFuelToPemitter</span>(node: *Node) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1481">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L1482">        <span class="tok-kw">if</span> (strEql(property, <span class="tok-str">&quot;GibParticle&quot;</span>)) {</span>
<span class="line" id="L1483">            <span class="tok-kw">if</span> (node.value) |value| {</span>
<span class="line" id="L1484">                <span class="tok-kw">if</span> (strEql(value, <span class="tok-str">&quot;AEmitter&quot;</span>)) {</span>
<span class="line" id="L1485">                    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L1486">                        <span class="tok-kw">if</span> (child.property) |child_property| {</span>
<span class="line" id="L1487">                            <span class="tok-kw">if</span> (strEql(child_property, <span class="tok-str">&quot;CopyOf&quot;</span>)) {</span>
<span class="line" id="L1488">                                <span class="tok-kw">if</span> (child.value) |child_value| {</span>
<span class="line" id="L1489">                                    <span class="tok-kw">if</span> (strEql(child_value, <span class="tok-str">&quot;Fuel Fire Trace Black&quot;</span>)) {</span>
<span class="line" id="L1490">                                        node.value = <span class="tok-str">&quot;PEmitter&quot;</span>;</span>
<span class="line" id="L1491">                                    }</span>
<span class="line" id="L1492">                                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1493">                                    <span class="tok-kw">return</span> UpdateIniFileTreeErrors.ExpectedValue;</span>
<span class="line" id="L1494">                                }</span>
<span class="line" id="L1495">                            }</span>
<span class="line" id="L1496">                        }</span>
<span class="line" id="L1497">                    }</span>
<span class="line" id="L1498">                }</span>
<span class="line" id="L1499">            }</span>
<span class="line" id="L1500">        }</span>
<span class="line" id="L1501">    }</span>
<span class="line" id="L1502">}</span>
<span class="line" id="L1503"></span>
<span class="line" id="L1504"><span class="tok-kw">fn</span> <span class="tok-fn">aemitterToAejetpack</span>(folder: *IniFolder, file_tree: *IniFolder, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1505">    <span class="tok-kw">for</span> (folder.folders.items) |*subfolder| {</span>
<span class="line" id="L1506">        <span class="tok-kw">try</span> aemitterToAejetpack(subfolder, file_tree, allocator);</span>
<span class="line" id="L1507">    }</span>
<span class="line" id="L1508"></span>
<span class="line" id="L1509">    <span class="tok-kw">for</span> (folder.files.items) |file| {</span>
<span class="line" id="L1510">        <span class="tok-kw">for</span> (file.ast.items) |*node| {</span>
<span class="line" id="L1511">            <span class="tok-kw">try</span> aemitterToAejetpackRecursivelyNode(node, file_tree, allocator);</span>
<span class="line" id="L1512">        }</span>
<span class="line" id="L1513">    }</span>
<span class="line" id="L1514">}</span>
<span class="line" id="L1515"></span>
<span class="line" id="L1516"><span class="tok-comment">// Translate &quot;Jetpack = AEmitter&quot; to &quot;Jetpack = AEJetpack&quot;,</span>
</span>
<span class="line" id="L1517"><span class="tok-comment">// and its &quot;AddEffect = AEmitter&quot; children to &quot;AddEffect = AEJetpack&quot;</span>
</span>
<span class="line" id="L1518"><span class="tok-kw">fn</span> <span class="tok-fn">aemitterToAejetpackRecursivelyNode</span>(node: *Node, file_tree: *IniFolder, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1519">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L1520">        <span class="tok-kw">if</span> (strEql(property, <span class="tok-str">&quot;Jetpack&quot;</span>)) {</span>
<span class="line" id="L1521">            <span class="tok-kw">if</span> (node.value) |value| {</span>
<span class="line" id="L1522">                <span class="tok-kw">if</span> (strEql(value, <span class="tok-str">&quot;AEmitter&quot;</span>)) {</span>
<span class="line" id="L1523">                    node.value = <span class="tok-str">&quot;AEJetpack&quot;</span>;</span>
<span class="line" id="L1524"></span>
<span class="line" id="L1525">                    <span class="tok-kw">try</span> addEffectAemitterToAddEffectAejetpackCopyOfFinder(node, file_tree);</span>
<span class="line" id="L1526">                }</span>
<span class="line" id="L1527">            }</span>
<span class="line" id="L1528">        }</span>
<span class="line" id="L1529">    }</span>
<span class="line" id="L1530"></span>
<span class="line" id="L1531">    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L1532">        <span class="tok-kw">try</span> aemitterToAejetpackRecursivelyNode(child, file_tree, allocator);</span>
<span class="line" id="L1533">    }</span>
<span class="line" id="L1534">}</span>
<span class="line" id="L1535"></span>
<span class="line" id="L1536"><span class="tok-kw">fn</span> <span class="tok-fn">addEffectAemitterToAddEffectAejetpackCopyOfFinder</span>(node: *Node, file_tree: *IniFolder) <span class="tok-kw">error</span>{ExpectedValue}!<span class="tok-type">void</span> {</span>
<span class="line" id="L1537">    <span class="tok-kw">for</span> (node.children.items) |*node_child| {</span>
<span class="line" id="L1538">        <span class="tok-kw">if</span> (node_child.property) |node_child_property| {</span>
<span class="line" id="L1539">            <span class="tok-kw">if</span> (strEql(node_child_property, <span class="tok-str">&quot;CopyOf&quot;</span>)) {</span>
<span class="line" id="L1540">                <span class="tok-kw">if</span> (node_child.value) |preset_name| {</span>
<span class="line" id="L1541">                    <span class="tok-kw">try</span> addEffectAemitterToAddEffectAejetpackRecursivelyFolder(file_tree, file_tree, preset_name);</span>
<span class="line" id="L1542">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1543">                    <span class="tok-kw">return</span> UpdateIniFileTreeErrors.ExpectedValue;</span>
<span class="line" id="L1544">                }</span>
<span class="line" id="L1545">            }</span>
<span class="line" id="L1546">        }</span>
<span class="line" id="L1547">    }</span>
<span class="line" id="L1548">}</span>
<span class="line" id="L1549"></span>
<span class="line" id="L1550"><span class="tok-kw">fn</span> <span class="tok-fn">addEffectAemitterToAddEffectAejetpackRecursivelyFolder</span>(folder: *IniFolder, file_tree: *IniFolder, preset_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1551">    <span class="tok-kw">for</span> (folder.folders.items) |*subfolder| {</span>
<span class="line" id="L1552">        <span class="tok-kw">try</span> addEffectAemitterToAddEffectAejetpackRecursivelyFolder(subfolder, file_tree, preset_name);</span>
<span class="line" id="L1553">    }</span>
<span class="line" id="L1554"></span>
<span class="line" id="L1555">    <span class="tok-kw">for</span> (folder.files.items) |file| {</span>
<span class="line" id="L1556">        <span class="tok-kw">for</span> (file.ast.items) |*node| {</span>
<span class="line" id="L1557">            <span class="tok-kw">try</span> addEffectAemitterToAddEffectAejetpackRecursivelyNode(node, file_tree, preset_name);</span>
<span class="line" id="L1558">        }</span>
<span class="line" id="L1559">    }</span>
<span class="line" id="L1560">}</span>
<span class="line" id="L1561"></span>
<span class="line" id="L1562"><span class="tok-kw">fn</span> <span class="tok-fn">addEffectAemitterToAddEffectAejetpackRecursivelyNode</span>(node: *Node, file_tree: *IniFolder, preset_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1563">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L1564">        <span class="tok-kw">if</span> (strEql(property, <span class="tok-str">&quot;AddEffect&quot;</span>)) {</span>
<span class="line" id="L1565">            <span class="tok-kw">if</span> (node.value) |value| {</span>
<span class="line" id="L1566">                <span class="tok-kw">if</span> (strEql(value, <span class="tok-str">&quot;AEmitter&quot;</span>)) {</span>
<span class="line" id="L1567">                    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L1568">                        <span class="tok-kw">if</span> (child.property) |child_property| {</span>
<span class="line" id="L1569">                            <span class="tok-kw">if</span> (strEql(child_property, <span class="tok-str">&quot;PresetName&quot;</span>)) {</span>
<span class="line" id="L1570">                                <span class="tok-kw">if</span> (child.value) |child_value| {</span>
<span class="line" id="L1571">                                    <span class="tok-kw">if</span> (strEql(child_value, preset_name)) {</span>
<span class="line" id="L1572">                                        node.value = <span class="tok-str">&quot;AEJetpack&quot;</span>;</span>
<span class="line" id="L1573"></span>
<span class="line" id="L1574">                                        <span class="tok-kw">try</span> addEffectAemitterToAddEffectAejetpackCopyOfFinder(node, file_tree);</span>
<span class="line" id="L1575">                                    }</span>
<span class="line" id="L1576">                                }</span>
<span class="line" id="L1577">                            }</span>
<span class="line" id="L1578">                        }</span>
<span class="line" id="L1579">                    }</span>
<span class="line" id="L1580">                }</span>
<span class="line" id="L1581">            }</span>
<span class="line" id="L1582">        }</span>
<span class="line" id="L1583">    }</span>
<span class="line" id="L1584"></span>
<span class="line" id="L1585">    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L1586">        <span class="tok-kw">try</span> addEffectAemitterToAddEffectAejetpackRecursivelyNode(child, file_tree, preset_name);</span>
<span class="line" id="L1587">    }</span>
<span class="line" id="L1588">}</span>
<span class="line" id="L1589"></span>
<span class="line" id="L1590"><span class="tok-kw">fn</span> <span class="tok-fn">moveJetpackModifiers</span>(folder: *IniFolder, file_tree: *IniFolder, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1591">    <span class="tok-kw">for</span> (folder.folders.items) |*subfolder| {</span>
<span class="line" id="L1592">        <span class="tok-kw">try</span> moveJetpackModifiers(subfolder, file_tree, allocator);</span>
<span class="line" id="L1593">    }</span>
<span class="line" id="L1594"></span>
<span class="line" id="L1595">    <span class="tok-kw">for</span> (folder.files.items) |file| {</span>
<span class="line" id="L1596">        <span class="tok-kw">for</span> (file.ast.items) |*node| {</span>
<span class="line" id="L1597">            <span class="tok-kw">try</span> moveJetpackModifiersRecursivelyNode(node, file_tree, allocator);</span>
<span class="line" id="L1598">        }</span>
<span class="line" id="L1599">    }</span>
<span class="line" id="L1600">}</span>
<span class="line" id="L1601"></span>
<span class="line" id="L1602"><span class="tok-comment">/// Move the Actor's jetpack modifiers to its last &quot;Jetpack = AEJetpack&quot;,</span></span>
<span class="line" id="L1603"><span class="tok-comment">/// where the modifiers get pushed to the back of the AEJetpack if they came after it,</span></span>
<span class="line" id="L1604"><span class="tok-comment">/// and inserted to the front of it if they came before it.</span></span>
<span class="line" id="L1605"><span class="tok-comment">/// Modifiers that come after the AEJetpack are .appended() in a forwards loop.</span></span>
<span class="line" id="L1606"><span class="tok-comment">/// Modifiers that come before the AEJetpack are .inserted() in a backwards loop,</span></span>
<span class="line" id="L1607"><span class="tok-comment">/// where the loop is stopped if a CopyOf is encountered.</span></span>
<span class="line" id="L1608"><span class="tok-kw">fn</span> <span class="tok-fn">moveJetpackModifiersRecursivelyNode</span>(node: *Node, file_tree: *IniFolder, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1609">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L1610">        <span class="tok-kw">if</span> (strEql(property, <span class="tok-str">&quot;AddActor&quot;</span>)) {</span>
<span class="line" id="L1611">            <span class="tok-kw">if</span> (node.value) |value| {</span>
<span class="line" id="L1612">                <span class="tok-kw">if</span> (strEql(value, <span class="tok-str">&quot;ACrab&quot;</span>) <span class="tok-kw">or</span> strEql(value, <span class="tok-str">&quot;AHuman&quot;</span>)) {</span>
<span class="line" id="L1613">                    <span class="tok-kw">try</span> appendJetpackModifiers(node);</span>
<span class="line" id="L1614">                    <span class="tok-kw">try</span> prependJetpackModifiers(node);</span>
<span class="line" id="L1615">                }</span>
<span class="line" id="L1616">            }</span>
<span class="line" id="L1617">        }</span>
<span class="line" id="L1618">    }</span>
<span class="line" id="L1619"></span>
<span class="line" id="L1620">    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L1621">        <span class="tok-kw">try</span> moveJetpackModifiersRecursivelyNode(child, file_tree, allocator);</span>
<span class="line" id="L1622">    }</span>
<span class="line" id="L1623">}</span>
<span class="line" id="L1624"></span>
<span class="line" id="L1625"><span class="tok-kw">fn</span> <span class="tok-fn">appendJetpackModifiers</span>(node: *Node) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1626">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L1627">        <span class="tok-kw">var</span> modifier_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1628">        <span class="tok-kw">var</span> removed = <span class="tok-null">false</span>;</span>
<span class="line" id="L1629">        modifier_blk: <span class="tok-kw">while</span> (modifier_index &lt; node.children.items.len) {</span>
<span class="line" id="L1630">            <span class="tok-kw">const</span> modifier = node.children.items[modifier_index];</span>
<span class="line" id="L1631">            <span class="tok-kw">if</span> (modifier.property) |modifier_property| {</span>
<span class="line" id="L1632">                <span class="tok-kw">if</span> (isJetpackModifier(modifier_property)) {</span>
<span class="line" id="L1633">                    <span class="tok-comment">// The AEJetpack *HAS* to be refound every time,</span>
</span>
<span class="line" id="L1634">                    <span class="tok-comment">// in order for aejetpack_index to stay accurate</span>
</span>
<span class="line" id="L1635">                    <span class="tok-kw">var</span> aejetpack_index = node.children.items.len;</span>
<span class="line" id="L1636">                    aejetpack_blk: <span class="tok-kw">while</span> (aejetpack_index &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L1637">                        aejetpack_index -= <span class="tok-number">1</span>;</span>
<span class="line" id="L1638">                        <span class="tok-kw">const</span> aejetpack = &amp;node.children.items[aejetpack_index];</span>
<span class="line" id="L1639">                        <span class="tok-kw">if</span> (aejetpack.property) |aejetpack_property| {</span>
<span class="line" id="L1640">                            <span class="tok-comment">// If there is no AEJetpack for it to be copied to</span>
</span>
<span class="line" id="L1641">                            <span class="tok-kw">if</span> (strEql(aejetpack_property, <span class="tok-str">&quot;CopyOf&quot;</span>)) {</span>
<span class="line" id="L1642">                                <span class="tok-kw">return</span>;</span>
<span class="line" id="L1643">                            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (strEql(aejetpack_property, <span class="tok-str">&quot;Jetpack&quot;</span>)) {</span>
<span class="line" id="L1644">                                <span class="tok-kw">if</span> (aejetpack.value) |aejetpack_value| {</span>
<span class="line" id="L1645">                                    <span class="tok-kw">if</span> (strEql(aejetpack_value, <span class="tok-str">&quot;AEJetpack&quot;</span>)) {</span>
<span class="line" id="L1646">                                        <span class="tok-kw">if</span> (modifier_index &gt; aejetpack_index) {</span>
<span class="line" id="L1647">                                            <span class="tok-kw">try</span> aejetpack.children.append(modifier);</span>
<span class="line" id="L1648">                                            _ = node.children.orderedRemove(modifier_index);</span>
<span class="line" id="L1649">                                            removed = <span class="tok-null">true</span>;</span>
<span class="line" id="L1650">                                            <span class="tok-kw">break</span> :modifier_blk;</span>
<span class="line" id="L1651">                                        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1652">                                            <span class="tok-kw">break</span> :aejetpack_blk;</span>
<span class="line" id="L1653">                                        }</span>
<span class="line" id="L1654">                                    }</span>
<span class="line" id="L1655">                                }</span>
<span class="line" id="L1656">                            }</span>
<span class="line" id="L1657">                        }</span>
<span class="line" id="L1658">                    }</span>
<span class="line" id="L1659">                }</span>
<span class="line" id="L1660">            }</span>
<span class="line" id="L1661">            modifier_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L1662">        }</span>
<span class="line" id="L1663">        <span class="tok-kw">if</span> (!removed) {</span>
<span class="line" id="L1664">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L1665">        }</span>
<span class="line" id="L1666">    }</span>
<span class="line" id="L1667">}</span>
<span class="line" id="L1668"></span>
<span class="line" id="L1669"><span class="tok-kw">fn</span> <span class="tok-fn">prependJetpackModifiers</span>(node: *Node) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1670">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L1671">        <span class="tok-kw">var</span> modifier_index = node.children.items.len;</span>
<span class="line" id="L1672">        <span class="tok-kw">var</span> removed = <span class="tok-null">false</span>;</span>
<span class="line" id="L1673">        modifier_blk: <span class="tok-kw">while</span> (modifier_index &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L1674">            modifier_index -= <span class="tok-number">1</span>;</span>
<span class="line" id="L1675">            <span class="tok-kw">const</span> modifier = node.children.items[modifier_index];</span>
<span class="line" id="L1676">            <span class="tok-kw">if</span> (modifier.property) |modifier_property| {</span>
<span class="line" id="L1677">                <span class="tok-kw">if</span> (strEql(modifier_property, <span class="tok-str">&quot;CopyOf&quot;</span>)) {</span>
<span class="line" id="L1678">                    <span class="tok-kw">return</span>;</span>
<span class="line" id="L1679">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (isJetpackModifier(modifier_property)) {</span>
<span class="line" id="L1680">                    <span class="tok-comment">// The AEJetpack *HAS* to be refound every time,</span>
</span>
<span class="line" id="L1681">                    <span class="tok-comment">// in order for aejetpack_index to stay accurate</span>
</span>
<span class="line" id="L1682">                    <span class="tok-kw">var</span> aejetpack_index = node.children.items.len;</span>
<span class="line" id="L1683">                    aejetpack_blk: <span class="tok-kw">while</span> (aejetpack_index &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L1684">                        aejetpack_index -= <span class="tok-number">1</span>;</span>
<span class="line" id="L1685">                        <span class="tok-kw">const</span> aejetpack = &amp;node.children.items[aejetpack_index];</span>
<span class="line" id="L1686">                        <span class="tok-kw">if</span> (aejetpack.property) |aejetpack_property| {</span>
<span class="line" id="L1687">                            <span class="tok-comment">// If there is no AEJetpack for it to be copied to</span>
</span>
<span class="line" id="L1688">                            <span class="tok-kw">if</span> (strEql(aejetpack_property, <span class="tok-str">&quot;CopyOf&quot;</span>)) {</span>
<span class="line" id="L1689">                                <span class="tok-kw">return</span>;</span>
<span class="line" id="L1690">                            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (strEql(aejetpack_property, <span class="tok-str">&quot;Jetpack&quot;</span>)) {</span>
<span class="line" id="L1691">                                <span class="tok-kw">if</span> (aejetpack.value) |aejetpack_value| {</span>
<span class="line" id="L1692">                                    <span class="tok-kw">if</span> (strEql(aejetpack_value, <span class="tok-str">&quot;AEJetpack&quot;</span>)) {</span>
<span class="line" id="L1693">                                        <span class="tok-kw">if</span> (modifier_index &lt; aejetpack_index) {</span>
<span class="line" id="L1694">                                            <span class="tok-kw">try</span> aejetpack.children.insert(<span class="tok-number">0</span>, modifier);</span>
<span class="line" id="L1695">                                            _ = node.children.orderedRemove(modifier_index);</span>
<span class="line" id="L1696">                                            removed = <span class="tok-null">true</span>;</span>
<span class="line" id="L1697">                                            <span class="tok-kw">break</span> :modifier_blk;</span>
<span class="line" id="L1698">                                        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1699">                                            <span class="tok-kw">break</span> :aejetpack_blk;</span>
<span class="line" id="L1700">                                        }</span>
<span class="line" id="L1701">                                    }</span>
<span class="line" id="L1702">                                }</span>
<span class="line" id="L1703">                            }</span>
<span class="line" id="L1704">                        }</span>
<span class="line" id="L1705">                    }</span>
<span class="line" id="L1706">                }</span>
<span class="line" id="L1707">            }</span>
<span class="line" id="L1708">        }</span>
<span class="line" id="L1709">        <span class="tok-kw">if</span> (!removed) {</span>
<span class="line" id="L1710">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L1711">        }</span>
<span class="line" id="L1712">    }</span>
<span class="line" id="L1713">}</span>
<span class="line" id="L1714"></span>
<span class="line" id="L1715"><span class="tok-kw">fn</span> <span class="tok-fn">copyJetpack</span>(folder: *IniFolder, file_tree: *IniFolder, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1716">    <span class="tok-kw">for</span> (folder.folders.items) |*subfolder| {</span>
<span class="line" id="L1717">        <span class="tok-kw">try</span> copyJetpack(subfolder, file_tree, allocator);</span>
<span class="line" id="L1718">    }</span>
<span class="line" id="L1719"></span>
<span class="line" id="L1720">    <span class="tok-kw">for</span> (folder.files.items) |file| {</span>
<span class="line" id="L1721">        <span class="tok-kw">for</span> (file.ast.items) |*node| {</span>
<span class="line" id="L1722">            <span class="tok-kw">try</span> copyJetpackRecursivelyNode(node, file_tree, allocator);</span>
<span class="line" id="L1723">        }</span>
<span class="line" id="L1724">    }</span>
<span class="line" id="L1725">}</span>
<span class="line" id="L1726"></span>
<span class="line" id="L1727"><span class="tok-comment">// Looping back-to-front through every ACrab and AHuman Actor child node, if</span>
</span>
<span class="line" id="L1728"><span class="tok-comment">// 1. we first encounter the Actor containing any of the six Jetpack modifiers, and</span>
</span>
<span class="line" id="L1729"><span class="tok-comment">// 2. after that we encounter it CopyOfs an Actor that has a Jetpack with the value AEJetpack,</span>
</span>
<span class="line" id="L1730"><span class="tok-comment">// before our Actor has any &quot;Jetpack =&quot;, .insert() that Jetpack in our own Actor</span>
</span>
<span class="line" id="L1731"><span class="tok-comment">// directly after the CopyOf.</span>
</span>
<span class="line" id="L1732"><span class="tok-comment">// The CopyOf has to be searched recursively, since a copied Jetpack may be in a CopyOf of a CopyOf.</span>
</span>
<span class="line" id="L1733"><span class="tok-kw">fn</span> <span class="tok-fn">copyJetpackRecursivelyNode</span>(node: *Node, file_tree: *IniFolder, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1734">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L1735">        <span class="tok-kw">if</span> (strEql(property, <span class="tok-str">&quot;AddActor&quot;</span>)) {</span>
<span class="line" id="L1736">            <span class="tok-kw">if</span> (node.value) |value| {</span>
<span class="line" id="L1737">                <span class="tok-kw">if</span> (strEql(value, <span class="tok-str">&quot;ACrab&quot;</span>) <span class="tok-kw">or</span> strEql(value, <span class="tok-str">&quot;AHuman&quot;</span>)) {</span>
<span class="line" id="L1738">                    <span class="tok-kw">var</span> seen_jetpack_modifier = <span class="tok-null">false</span>;</span>
<span class="line" id="L1739">                    <span class="tok-kw">var</span> i = node.children.items.len;</span>
<span class="line" id="L1740">                    <span class="tok-kw">while</span> (i &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L1741">                        i -= <span class="tok-number">1</span>;</span>
<span class="line" id="L1742">                        <span class="tok-kw">const</span> child = node.children.items[i];</span>
<span class="line" id="L1743">                        <span class="tok-kw">if</span> (child.property) |child_property| {</span>
<span class="line" id="L1744">                            <span class="tok-kw">if</span> (strEql(child_property, <span class="tok-str">&quot;Jetpack&quot;</span>)) {</span>
<span class="line" id="L1745">                                <span class="tok-kw">break</span>;</span>
<span class="line" id="L1746">                            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (isJetpackModifier(child_property)) {</span>
<span class="line" id="L1747">                                seen_jetpack_modifier = <span class="tok-null">true</span>;</span>
<span class="line" id="L1748">                            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (seen_jetpack_modifier <span class="tok-kw">and</span> strEql(child_property, <span class="tok-str">&quot;CopyOf&quot;</span>)) {</span>
<span class="line" id="L1749">                                <span class="tok-kw">if</span> (child.value) |preset_name| {</span>
<span class="line" id="L1750">                                    <span class="tok-kw">if</span> (findJetpackRecursivelyFolder(file_tree, file_tree, preset_name)) |jetpack| {</span>
<span class="line" id="L1751">                                        <span class="tok-kw">const</span> jetpack_deepcopy = <span class="tok-kw">try</span> deepCopyNode(jetpack, allocator);</span>
<span class="line" id="L1752">                                        <span class="tok-kw">try</span> node.children.insert(i + <span class="tok-number">1</span>, jetpack_deepcopy);</span>
<span class="line" id="L1753">                                        <span class="tok-kw">break</span>;</span>
<span class="line" id="L1754">                                    }</span>
<span class="line" id="L1755">                                }</span>
<span class="line" id="L1756">                            }</span>
<span class="line" id="L1757">                        }</span>
<span class="line" id="L1758">                    }</span>
<span class="line" id="L1759">                }</span>
<span class="line" id="L1760">            }</span>
<span class="line" id="L1761">        }</span>
<span class="line" id="L1762">    }</span>
<span class="line" id="L1763"></span>
<span class="line" id="L1764">    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L1765">        <span class="tok-kw">try</span> copyJetpackRecursivelyNode(child, file_tree, allocator);</span>
<span class="line" id="L1766">    }</span>
<span class="line" id="L1767">}</span>
<span class="line" id="L1768"></span>
<span class="line" id="L1769"><span class="tok-kw">fn</span> <span class="tok-fn">deepCopyNode</span>(input_node: *Node, allocator: Allocator) !Node {</span>
<span class="line" id="L1770">    <span class="tok-kw">var</span> returned_node = Node{</span>
<span class="line" id="L1771">        .property = <span class="tok-kw">if</span> (input_node.property) |property| <span class="tok-kw">try</span> allocator.dupe(<span class="tok-type">u8</span>, property) <span class="tok-kw">else</span> <span class="tok-null">null</span>,</span>
<span class="line" id="L1772">        .value = <span class="tok-kw">if</span> (input_node.value) |value| <span class="tok-kw">try</span> allocator.dupe(<span class="tok-type">u8</span>, value) <span class="tok-kw">else</span> <span class="tok-null">null</span>,</span>
<span class="line" id="L1773">        .comments = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(allocator),</span>
<span class="line" id="L1774">        .children = ArrayList(Node).init(allocator),</span>
<span class="line" id="L1775">    };</span>
<span class="line" id="L1776"></span>
<span class="line" id="L1777">    <span class="tok-kw">for</span> (input_node.comments.items) |comment| {</span>
<span class="line" id="L1778">        <span class="tok-kw">try</span> returned_node.comments.append(<span class="tok-kw">try</span> allocator.dupe(<span class="tok-type">u8</span>, comment));</span>
<span class="line" id="L1779">    }</span>
<span class="line" id="L1780"></span>
<span class="line" id="L1781">    <span class="tok-kw">for</span> (input_node.children.items) |*child| {</span>
<span class="line" id="L1782">        <span class="tok-kw">try</span> returned_node.children.append(<span class="tok-kw">try</span> deepCopyNode(child, allocator));</span>
<span class="line" id="L1783">    }</span>
<span class="line" id="L1784"></span>
<span class="line" id="L1785">    <span class="tok-kw">return</span> returned_node;</span>
<span class="line" id="L1786">}</span>
<span class="line" id="L1787"></span>
<span class="line" id="L1788"><span class="tok-kw">fn</span> <span class="tok-fn">removeJetpackModifiersFromActors</span>(folder: *IniFolder, file_tree: *IniFolder, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1789">    <span class="tok-kw">for</span> (folder.folders.items) |*subfolder| {</span>
<span class="line" id="L1790">        <span class="tok-kw">try</span> removeJetpackModifiersFromActors(subfolder, file_tree, allocator);</span>
<span class="line" id="L1791">    }</span>
<span class="line" id="L1792"></span>
<span class="line" id="L1793">    <span class="tok-kw">for</span> (folder.files.items) |file| {</span>
<span class="line" id="L1794">        <span class="tok-kw">for</span> (file.ast.items) |*node| {</span>
<span class="line" id="L1795">            <span class="tok-kw">try</span> removeJetpackModifiersFromActorsRecursivelyNode(node, file_tree, allocator);</span>
<span class="line" id="L1796">        }</span>
<span class="line" id="L1797">    }</span>
<span class="line" id="L1798">}</span>
<span class="line" id="L1799"></span>
<span class="line" id="L1800"><span class="tok-kw">fn</span> <span class="tok-fn">removeJetpackModifiersFromActorsRecursivelyNode</span>(node: *Node, file_tree: *IniFolder, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1801">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L1802">        <span class="tok-kw">if</span> (strEql(property, <span class="tok-str">&quot;AddActor&quot;</span>)) {</span>
<span class="line" id="L1803">            <span class="tok-kw">if</span> (node.value) |value| {</span>
<span class="line" id="L1804">                <span class="tok-kw">if</span> (strEql(value, <span class="tok-str">&quot;ACrab&quot;</span>) <span class="tok-kw">or</span> strEql(value, <span class="tok-str">&quot;AHuman&quot;</span>)) {</span>
<span class="line" id="L1805">                    <span class="tok-kw">var</span> i = node.children.items.len;</span>
<span class="line" id="L1806">                    <span class="tok-kw">while</span> (i &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L1807">                        i -= <span class="tok-number">1</span>;</span>
<span class="line" id="L1808">                        <span class="tok-kw">const</span> child = node.children.items[i];</span>
<span class="line" id="L1809">                        <span class="tok-kw">if</span> (child.property) |child_property| {</span>
<span class="line" id="L1810">                            <span class="tok-kw">if</span> (isJetpackModifier(child_property)) {</span>
<span class="line" id="L1811">                                _ = node.children.orderedRemove(i);</span>
<span class="line" id="L1812">                            }</span>
<span class="line" id="L1813">                        }</span>
<span class="line" id="L1814">                    }</span>
<span class="line" id="L1815">                }</span>
<span class="line" id="L1816">            }</span>
<span class="line" id="L1817">        }</span>
<span class="line" id="L1818">    }</span>
<span class="line" id="L1819"></span>
<span class="line" id="L1820">    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L1821">        <span class="tok-kw">try</span> removeJetpackModifiersFromActorsRecursivelyNode(child, file_tree, allocator);</span>
<span class="line" id="L1822">    }</span>
<span class="line" id="L1823">}</span>
<span class="line" id="L1824"></span>
<span class="line" id="L1825"><span class="tok-kw">fn</span> <span class="tok-fn">isJetpackModifier</span>(property: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L1826">    <span class="tok-kw">return</span> strEql(property, <span class="tok-str">&quot;JumpTime&quot;</span>) <span class="tok-kw">or</span> strEql(property, <span class="tok-str">&quot;JetTime&quot;</span>) <span class="tok-kw">or</span> strEql(property, <span class="tok-str">&quot;JumpReplenishRate&quot;</span>) <span class="tok-kw">or</span> strEql(property, <span class="tok-str">&quot;JetReplenishRate&quot;</span>) <span class="tok-kw">or</span> strEql(property, <span class="tok-str">&quot;JumpAngleRange&quot;</span>) <span class="tok-kw">or</span> strEql(property, <span class="tok-str">&quot;JetAngleRange&quot;</span>);</span>
<span class="line" id="L1827">}</span>
<span class="line" id="L1828"></span>
<span class="line" id="L1829"><span class="tok-kw">fn</span> <span class="tok-fn">findJetpackRecursivelyFolder</span>(folder: *IniFolder, file_tree: *IniFolder, preset_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?*Node {</span>
<span class="line" id="L1830">    <span class="tok-kw">for</span> (folder.folders.items) |*subfolder| {</span>
<span class="line" id="L1831">        <span class="tok-kw">if</span> (findJetpackRecursivelyFolder(subfolder, file_tree, preset_name)) |returned| {</span>
<span class="line" id="L1832">            <span class="tok-kw">return</span> returned;</span>
<span class="line" id="L1833">        }</span>
<span class="line" id="L1834">    }</span>
<span class="line" id="L1835"></span>
<span class="line" id="L1836">    <span class="tok-kw">for</span> (folder.files.items) |file| {</span>
<span class="line" id="L1837">        <span class="tok-kw">for</span> (file.ast.items) |*node| {</span>
<span class="line" id="L1838">            <span class="tok-kw">if</span> (findJetpackRecursivelyNode(node, file_tree, preset_name)) |returned| {</span>
<span class="line" id="L1839">                <span class="tok-kw">return</span> returned;</span>
<span class="line" id="L1840">            }</span>
<span class="line" id="L1841">        }</span>
<span class="line" id="L1842">    }</span>
<span class="line" id="L1843"></span>
<span class="line" id="L1844">    <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1845">}</span>
<span class="line" id="L1846"></span>
<span class="line" id="L1847"><span class="tok-kw">fn</span> <span class="tok-fn">findJetpackRecursivelyNode</span>(node: *Node, file_tree: *IniFolder, preset_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?*Node {</span>
<span class="line" id="L1848">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L1849">        <span class="tok-kw">if</span> (strEql(property, <span class="tok-str">&quot;AddActor&quot;</span>)) {</span>
<span class="line" id="L1850">            <span class="tok-kw">if</span> (node.value) |value| {</span>
<span class="line" id="L1851">                <span class="tok-kw">if</span> (strEql(value, <span class="tok-str">&quot;ACrab&quot;</span>) <span class="tok-kw">or</span> strEql(value, <span class="tok-str">&quot;AHuman&quot;</span>)) {</span>
<span class="line" id="L1852">                    <span class="tok-kw">var</span> found_searched_for_preset_name = <span class="tok-null">false</span>;</span>
<span class="line" id="L1853">                    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L1854">                        <span class="tok-kw">if</span> (child.property) |child_property| {</span>
<span class="line" id="L1855">                            <span class="tok-kw">if</span> (strEql(child_property, <span class="tok-str">&quot;PresetName&quot;</span>)) {</span>
<span class="line" id="L1856">                                <span class="tok-kw">if</span> (child.value) |child_value| {</span>
<span class="line" id="L1857">                                    <span class="tok-kw">if</span> (strEql(child_value, preset_name)) {</span>
<span class="line" id="L1858">                                        found_searched_for_preset_name = <span class="tok-null">true</span>;</span>
<span class="line" id="L1859">                                    }</span>
<span class="line" id="L1860">                                    <span class="tok-kw">break</span>;</span>
<span class="line" id="L1861">                                }</span>
<span class="line" id="L1862">                            }</span>
<span class="line" id="L1863">                        }</span>
<span class="line" id="L1864">                    }</span>
<span class="line" id="L1865"></span>
<span class="line" id="L1866">                    <span class="tok-kw">if</span> (found_searched_for_preset_name) {</span>
<span class="line" id="L1867">                        <span class="tok-kw">var</span> i = node.children.items.len;</span>
<span class="line" id="L1868">                        <span class="tok-kw">while</span> (i &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L1869">                            i -= <span class="tok-number">1</span>;</span>
<span class="line" id="L1870">                            <span class="tok-kw">const</span> child = &amp;node.children.items[i];</span>
<span class="line" id="L1871">                            <span class="tok-kw">if</span> (child.property) |child_property| {</span>
<span class="line" id="L1872">                                <span class="tok-kw">if</span> (strEql(child_property, <span class="tok-str">&quot;Jetpack&quot;</span>)) {</span>
<span class="line" id="L1873">                                    <span class="tok-kw">if</span> (child.value) |child_value| {</span>
<span class="line" id="L1874">                                        <span class="tok-kw">if</span> (strEql(child_value, <span class="tok-str">&quot;AEJetpack&quot;</span>)) {</span>
<span class="line" id="L1875">                                            <span class="tok-kw">return</span> child;</span>
<span class="line" id="L1876">                                        }</span>
<span class="line" id="L1877">                                    }</span>
<span class="line" id="L1878">                                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (strEql(child_property, <span class="tok-str">&quot;CopyOf&quot;</span>)) {</span>
<span class="line" id="L1879">                                    <span class="tok-kw">if</span> (child.value) |child_preset_name| {</span>
<span class="line" id="L1880">                                        <span class="tok-kw">return</span> findJetpackRecursivelyFolder(file_tree, file_tree, child_preset_name);</span>
<span class="line" id="L1881">                                    }</span>
<span class="line" id="L1882">                                }</span>
<span class="line" id="L1883">                            }</span>
<span class="line" id="L1884">                        }</span>
<span class="line" id="L1885">                    }</span>
<span class="line" id="L1886">                }</span>
<span class="line" id="L1887">            }</span>
<span class="line" id="L1888">        }</span>
<span class="line" id="L1889">    }</span>
<span class="line" id="L1890"></span>
<span class="line" id="L1891">    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L1892">        <span class="tok-kw">if</span> (findJetpackRecursivelyNode(child, file_tree, preset_name)) |returned| {</span>
<span class="line" id="L1893">            <span class="tok-kw">return</span> returned;</span>
<span class="line" id="L1894">        }</span>
<span class="line" id="L1895">    }</span>
<span class="line" id="L1896"></span>
<span class="line" id="L1897">    <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1898">}</span>
<span class="line" id="L1899"></span>
<span class="line" id="L1900"><span class="tok-kw">fn</span> <span class="tok-fn">maxLengthToOffsets</span>(node: *Node, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1901">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L1902">        <span class="tok-kw">if</span> (strEql(property, <span class="tok-str">&quot;AddActor&quot;</span>)) {</span>
<span class="line" id="L1903">            <span class="tok-kw">if</span> (node.value) |value| {</span>
<span class="line" id="L1904">                <span class="tok-kw">if</span> (strEql(value, <span class="tok-str">&quot;Leg&quot;</span>)) {</span>
<span class="line" id="L1905">                    <span class="tok-kw">var</span> children = &amp;node.children;</span>
<span class="line" id="L1906"></span>
<span class="line" id="L1907">                    <span class="tok-kw">for</span> (children.items) |*child| {</span>
<span class="line" id="L1908">                        <span class="tok-kw">if</span> (child.property) |child_property| {</span>
<span class="line" id="L1909">                            <span class="tok-kw">if</span> (strEql(child_property, <span class="tok-str">&quot;MaxLength&quot;</span>)) {</span>
<span class="line" id="L1910">                                <span class="tok-kw">if</span> (child.value) |child_value| {</span>
<span class="line" id="L1911">                                    child.property = <span class="tok-str">&quot;ContractedOffset&quot;</span>;</span>
<span class="line" id="L1912">                                    child.value = <span class="tok-str">&quot;Vector&quot;</span>;</span>
<span class="line" id="L1913">                                    <span class="tok-kw">try</span> child.children.append(Node{</span>
<span class="line" id="L1914">                                        .property = <span class="tok-str">&quot;X&quot;</span>,</span>
<span class="line" id="L1915">                                        .value = <span class="tok-kw">try</span> allocPrint(allocator, <span class="tok-str">&quot;{d}&quot;</span>, .{<span class="tok-kw">try</span> parseFloat(<span class="tok-type">f32</span>, child_value) / <span class="tok-number">2</span>}),</span>
<span class="line" id="L1916">                                        .comments = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(allocator),</span>
<span class="line" id="L1917">                                        .children = ArrayList(Node).init(allocator),</span>
<span class="line" id="L1918">                                    });</span>
<span class="line" id="L1919">                                    <span class="tok-kw">try</span> child.children.append(Node{</span>
<span class="line" id="L1920">                                        .property = <span class="tok-str">&quot;Y&quot;</span>,</span>
<span class="line" id="L1921">                                        .value = <span class="tok-str">&quot;0&quot;</span>,</span>
<span class="line" id="L1922">                                        .comments = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(allocator),</span>
<span class="line" id="L1923">                                        .children = ArrayList(Node).init(allocator),</span>
<span class="line" id="L1924">                                    });</span>
<span class="line" id="L1925"></span>
<span class="line" id="L1926">                                    <span class="tok-kw">var</span> extended_offset = Node{</span>
<span class="line" id="L1927">                                        .property = <span class="tok-str">&quot;ExtendedOffset&quot;</span>,</span>
<span class="line" id="L1928">                                        .value = <span class="tok-str">&quot;Vector&quot;</span>,</span>
<span class="line" id="L1929">                                        .comments = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(allocator),</span>
<span class="line" id="L1930">                                        .children = ArrayList(Node).init(allocator),</span>
<span class="line" id="L1931">                                    };</span>
<span class="line" id="L1932">                                    <span class="tok-kw">try</span> extended_offset.children.append(Node{</span>
<span class="line" id="L1933">                                        .property = <span class="tok-str">&quot;X&quot;</span>,</span>
<span class="line" id="L1934">                                        .value = child_value,</span>
<span class="line" id="L1935">                                        .comments = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(allocator),</span>
<span class="line" id="L1936">                                        .children = ArrayList(Node).init(allocator),</span>
<span class="line" id="L1937">                                    });</span>
<span class="line" id="L1938">                                    <span class="tok-kw">try</span> extended_offset.children.append(Node{</span>
<span class="line" id="L1939">                                        .property = <span class="tok-str">&quot;Y&quot;</span>,</span>
<span class="line" id="L1940">                                        .value = <span class="tok-str">&quot;0&quot;</span>,</span>
<span class="line" id="L1941">                                        .comments = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(allocator),</span>
<span class="line" id="L1942">                                        .children = ArrayList(Node).init(allocator),</span>
<span class="line" id="L1943">                                    });</span>
<span class="line" id="L1944">                                    <span class="tok-kw">try</span> children.append(extended_offset);</span>
<span class="line" id="L1945">                                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1946">                                    <span class="tok-kw">return</span> UpdateIniFileTreeErrors.ExpectedValue;</span>
<span class="line" id="L1947">                                }</span>
<span class="line" id="L1948">                            }</span>
<span class="line" id="L1949">                        }</span>
<span class="line" id="L1950">                    }</span>
<span class="line" id="L1951">                }</span>
<span class="line" id="L1952">            }</span>
<span class="line" id="L1953">        }</span>
<span class="line" id="L1954">    }</span>
<span class="line" id="L1955">}</span>
<span class="line" id="L1956"></span>
<span class="line" id="L1957"><span class="tok-kw">fn</span> <span class="tok-fn">maxMassToMaxInventoryMass</span>(node: *Node, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1958">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L1959">        <span class="tok-kw">if</span> (strEql(property, <span class="tok-str">&quot;AddActor&quot;</span>)) {</span>
<span class="line" id="L1960">            <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L1961">                <span class="tok-kw">if</span> (child.property) |child_property| {</span>
<span class="line" id="L1962">                    <span class="tok-kw">if</span> (strEql(child_property, <span class="tok-str">&quot;MaxMass&quot;</span>)) {</span>
<span class="line" id="L1963">                        <span class="tok-kw">if</span> (child.value) |v| {</span>
<span class="line" id="L1964">                            <span class="tok-kw">const</span> max_mass = <span class="tok-kw">try</span> parseFloat(<span class="tok-type">f32</span>, v);</span>
<span class="line" id="L1965"></span>
<span class="line" id="L1966">                            <span class="tok-kw">for</span> (node.children.items) |child2| {</span>
<span class="line" id="L1967">                                <span class="tok-kw">if</span> (child2.property) |child_property2| {</span>
<span class="line" id="L1968">                                    <span class="tok-kw">if</span> (strEql(child_property2, <span class="tok-str">&quot;Mass&quot;</span>)) {</span>
<span class="line" id="L1969">                                        <span class="tok-kw">if</span> (child2.value) |v2| {</span>
<span class="line" id="L1970">                                            child.property = <span class="tok-str">&quot;MaxInventoryMass&quot;</span>;</span>
<span class="line" id="L1971"></span>
<span class="line" id="L1972">                                            <span class="tok-kw">const</span> mass = <span class="tok-kw">try</span> parseFloat(<span class="tok-type">f32</span>, v2);</span>
<span class="line" id="L1973">                                            <span class="tok-kw">const</span> max_inventory_mass = max_mass - mass;</span>
<span class="line" id="L1974">                                            child.value = <span class="tok-kw">try</span> allocPrint(allocator, <span class="tok-str">&quot;{d}&quot;</span>, .{max_inventory_mass});</span>
<span class="line" id="L1975">                                        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1976">                                            <span class="tok-kw">return</span> UpdateIniFileTreeErrors.ExpectedValue;</span>
<span class="line" id="L1977">                                        }</span>
<span class="line" id="L1978">                                    }</span>
<span class="line" id="L1979">                                }</span>
<span class="line" id="L1980">                            }</span>
<span class="line" id="L1981">                        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1982">                            <span class="tok-kw">return</span> UpdateIniFileTreeErrors.ExpectedValue;</span>
<span class="line" id="L1983">                        }</span>
<span class="line" id="L1984">                    }</span>
<span class="line" id="L1985">                }</span>
<span class="line" id="L1986">            }</span>
<span class="line" id="L1987">        }</span>
<span class="line" id="L1988">    }</span>
<span class="line" id="L1989">}</span>
<span class="line" id="L1990"></span>
<span class="line" id="L1991"><span class="tok-kw">fn</span> <span class="tok-fn">maxThrottleRangeToPositiveThrottleMultiplier</span>(node: *Node, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1992">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L1993">        <span class="tok-kw">if</span> (strEql(property, <span class="tok-str">&quot;MaxThrottleRange&quot;</span>)) {</span>
<span class="line" id="L1994">            node.property = <span class="tok-str">&quot;PositiveThrottleMultiplier&quot;</span>;</span>
<span class="line" id="L1995">            <span class="tok-kw">if</span> (node.value) |v| {</span>
<span class="line" id="L1996">                <span class="tok-kw">const</span> old_value = <span class="tok-kw">try</span> parseFloat(<span class="tok-type">f32</span>, v);</span>
<span class="line" id="L1997">                <span class="tok-kw">const</span> new_value = fabs(<span class="tok-number">1</span> + fabs(old_value));</span>
<span class="line" id="L1998">                node.value = <span class="tok-kw">try</span> allocPrint(allocator, <span class="tok-str">&quot;{d}&quot;</span>, .{new_value});</span>
<span class="line" id="L1999">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2000">                <span class="tok-kw">return</span> UpdateIniFileTreeErrors.ExpectedValue;</span>
<span class="line" id="L2001">            }</span>
<span class="line" id="L2002">        }</span>
<span class="line" id="L2003">    }</span>
<span class="line" id="L2004">}</span>
<span class="line" id="L2005"></span>
<span class="line" id="L2006"><span class="tok-kw">fn</span> <span class="tok-fn">minThrottleRangeToNegativeThrottleMultiplier</span>(node: *Node, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2007">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L2008">        <span class="tok-kw">if</span> (strEql(property, <span class="tok-str">&quot;MinThrottleRange&quot;</span>)) {</span>
<span class="line" id="L2009">            node.property = <span class="tok-str">&quot;NegativeThrottleMultiplier&quot;</span>;</span>
<span class="line" id="L2010">            <span class="tok-kw">if</span> (node.value) |v| {</span>
<span class="line" id="L2011">                <span class="tok-kw">const</span> old_value = <span class="tok-kw">try</span> parseFloat(<span class="tok-type">f32</span>, v);</span>
<span class="line" id="L2012">                <span class="tok-kw">const</span> new_value = fabs(<span class="tok-number">1</span> - fabs(old_value));</span>
<span class="line" id="L2013">                node.value = <span class="tok-kw">try</span> allocPrint(allocator, <span class="tok-str">&quot;{d}&quot;</span>, .{new_value});</span>
<span class="line" id="L2014">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2015">                <span class="tok-kw">return</span> UpdateIniFileTreeErrors.ExpectedValue;</span>
<span class="line" id="L2016">            }</span>
<span class="line" id="L2017">        }</span>
<span class="line" id="L2018">    }</span>
<span class="line" id="L2019">}</span>
<span class="line" id="L2020"></span>
<span class="line" id="L2021"><span class="tok-kw">fn</span> <span class="tok-fn">pieMenu</span>(actor_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, default_copy_of_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, starting_direction_count_up: <span class="tok-type">u32</span>, starting_direction_count_down: <span class="tok-type">u32</span>, starting_direction_count_left: <span class="tok-type">u32</span>, starting_direction_count_right: <span class="tok-type">u32</span>, file_tree: *IniFolder, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2022">    <span class="tok-kw">for</span> (file_tree.folders.items) |*folder| {</span>
<span class="line" id="L2023">        <span class="tok-kw">try</span> pieMenu(actor_name, default_copy_of_name, starting_direction_count_up, starting_direction_count_down, starting_direction_count_left, starting_direction_count_right, folder, allocator);</span>
<span class="line" id="L2024">    }</span>
<span class="line" id="L2025"></span>
<span class="line" id="L2026">    <span class="tok-kw">for</span> (file_tree.files.items) |file| {</span>
<span class="line" id="L2027">        <span class="tok-kw">for</span> (file.ast.items) |*node| {</span>
<span class="line" id="L2028">            <span class="tok-kw">try</span> pieMenuRecursivelyNode(node, actor_name, default_copy_of_name, starting_direction_count_up, starting_direction_count_down, starting_direction_count_left, starting_direction_count_right, allocator);</span>
<span class="line" id="L2029">        }</span>
<span class="line" id="L2030">    }</span>
<span class="line" id="L2031">}</span>
<span class="line" id="L2032"></span>
<span class="line" id="L2033"><span class="tok-kw">fn</span> <span class="tok-fn">pieMenuRecursivelyNode</span>(node: *Node, actor_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, default_copy_of_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, starting_direction_count_up: <span class="tok-type">u32</span>, starting_direction_count_down: <span class="tok-type">u32</span>, starting_direction_count_left: <span class="tok-type">u32</span>, starting_direction_count_right: <span class="tok-type">u32</span>, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2034">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L2035">        <span class="tok-kw">if</span> (strEql(property, <span class="tok-str">&quot;AddActor&quot;</span>)) {</span>
<span class="line" id="L2036">            <span class="tok-kw">if</span> (node.value) |value| {</span>
<span class="line" id="L2037">                <span class="tok-kw">if</span> (strEql(value, actor_name)) {</span>
<span class="line" id="L2038">                    <span class="tok-kw">var</span> children = &amp;node.children;</span>
<span class="line" id="L2039"></span>
<span class="line" id="L2040">                    <span class="tok-kw">var</span> contains_pie_slice = <span class="tok-null">false</span>;</span>
<span class="line" id="L2041">                    <span class="tok-kw">for</span> (children.items) |*child| {</span>
<span class="line" id="L2042">                        <span class="tok-kw">if</span> (child.property) |child_property| {</span>
<span class="line" id="L2043">                            <span class="tok-kw">if</span> (strEql(child_property, <span class="tok-str">&quot;AddPieSlice&quot;</span>)) {</span>
<span class="line" id="L2044">                                <span class="tok-kw">if</span> (child.value) |child_value| {</span>
<span class="line" id="L2045">                                    <span class="tok-kw">if</span> (strEql(child_value, <span class="tok-str">&quot;PieSlice&quot;</span>)) {</span>
<span class="line" id="L2046">                                        contains_pie_slice = <span class="tok-null">true</span>;</span>
<span class="line" id="L2047">                                    }</span>
<span class="line" id="L2048">                                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2049">                                    <span class="tok-kw">return</span> UpdateIniFileTreeErrors.ExpectedValue;</span>
<span class="line" id="L2050">                                }</span>
<span class="line" id="L2051">                            }</span>
<span class="line" id="L2052">                        }</span>
<span class="line" id="L2053">                    }</span>
<span class="line" id="L2054"></span>
<span class="line" id="L2055">                    <span class="tok-kw">if</span> (contains_pie_slice) {</span>
<span class="line" id="L2056">                        <span class="tok-kw">var</span> pie_menu = Node{</span>
<span class="line" id="L2057">                            .property = <span class="tok-str">&quot;PieMenu&quot;</span>,</span>
<span class="line" id="L2058">                            .value = <span class="tok-str">&quot;PieMenu&quot;</span>,</span>
<span class="line" id="L2059">                            .comments = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(allocator),</span>
<span class="line" id="L2060">                            .children = ArrayList(Node).init(allocator),</span>
<span class="line" id="L2061">                        };</span>
<span class="line" id="L2062"></span>
<span class="line" id="L2063">                        <span class="tok-kw">try</span> pie_menu.children.append(Node{</span>
<span class="line" id="L2064">                            .property = <span class="tok-str">&quot;CopyOf&quot;</span>,</span>
<span class="line" id="L2065">                            .value = default_copy_of_name,</span>
<span class="line" id="L2066">                            .comments = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(allocator),</span>
<span class="line" id="L2067">                            .children = ArrayList(Node).init(allocator),</span>
<span class="line" id="L2068">                        });</span>
<span class="line" id="L2069"></span>
<span class="line" id="L2070">                        <span class="tok-kw">for</span> (children.items) |*child| {</span>
<span class="line" id="L2071">                            <span class="tok-kw">if</span> (child.property) |child_property| {</span>
<span class="line" id="L2072">                                <span class="tok-kw">if</span> (strEql(child_property, <span class="tok-str">&quot;AddPieSlice&quot;</span>)) {</span>
<span class="line" id="L2073">                                    <span class="tok-kw">if</span> (child.value) |child_value| {</span>
<span class="line" id="L2074">                                        <span class="tok-kw">if</span> (strEql(child_value, <span class="tok-str">&quot;PieSlice&quot;</span>)) {</span>
<span class="line" id="L2075">                                            <span class="tok-comment">// Make a copy of the PieSlice in the PieMenu</span>
</span>
<span class="line" id="L2076">                                            <span class="tok-kw">try</span> pie_menu.children.append(Node{</span>
<span class="line" id="L2077">                                                .property = <span class="tok-str">&quot;AddPieSlice&quot;</span>,</span>
<span class="line" id="L2078">                                                .value = <span class="tok-str">&quot;PieSlice&quot;</span>,</span>
<span class="line" id="L2079">                                                .comments = child.comments,</span>
<span class="line" id="L2080">                                                .children = child.children,</span>
<span class="line" id="L2081">                                            });</span>
<span class="line" id="L2082"></span>
<span class="line" id="L2083">                                            <span class="tok-comment">// Remove the PieSlice from the root of the Actor</span>
</span>
<span class="line" id="L2084">                                            child.property = <span class="tok-null">null</span>;</span>
<span class="line" id="L2085">                                            child.value = <span class="tok-null">null</span>;</span>
<span class="line" id="L2086">                                            child.comments = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(allocator);</span>
<span class="line" id="L2087">                                            child.children = ArrayList(Node).init(allocator);</span>
<span class="line" id="L2088">                                        }</span>
<span class="line" id="L2089">                                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2090">                                        <span class="tok-kw">return</span> UpdateIniFileTreeErrors.ExpectedValue;</span>
<span class="line" id="L2091">                                    }</span>
<span class="line" id="L2092">                                }</span>
<span class="line" id="L2093">                            }</span>
<span class="line" id="L2094">                        }</span>
<span class="line" id="L2095"></span>
<span class="line" id="L2096">                        <span class="tok-kw">try</span> applyPieQuadrantSlotLimit(&amp;pie_menu, <span class="tok-str">&quot;Up&quot;</span>, starting_direction_count_up);</span>
<span class="line" id="L2097">                        <span class="tok-kw">try</span> applyPieQuadrantSlotLimit(&amp;pie_menu, <span class="tok-str">&quot;Down&quot;</span>, starting_direction_count_down);</span>
<span class="line" id="L2098">                        <span class="tok-kw">try</span> applyPieQuadrantSlotLimit(&amp;pie_menu, <span class="tok-str">&quot;Left&quot;</span>, starting_direction_count_left);</span>
<span class="line" id="L2099">                        <span class="tok-kw">try</span> applyPieQuadrantSlotLimit(&amp;pie_menu, <span class="tok-str">&quot;Right&quot;</span>, starting_direction_count_right);</span>
<span class="line" id="L2100"></span>
<span class="line" id="L2101">                        <span class="tok-kw">try</span> children.append(pie_menu);</span>
<span class="line" id="L2102">                    }</span>
<span class="line" id="L2103">                }</span>
<span class="line" id="L2104">            }</span>
<span class="line" id="L2105">        }</span>
<span class="line" id="L2106">    }</span>
<span class="line" id="L2107"></span>
<span class="line" id="L2108">    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L2109">        <span class="tok-kw">try</span> pieMenuRecursivelyNode(child, actor_name, default_copy_of_name, starting_direction_count_up, starting_direction_count_down, starting_direction_count_left, starting_direction_count_right, allocator);</span>
<span class="line" id="L2110">    }</span>
<span class="line" id="L2111">}</span>
<span class="line" id="L2112"></span>
<span class="line" id="L2113"><span class="tok-kw">fn</span> <span class="tok-fn">applyPieQuadrantSlotLimit</span>(pie_menu: *Node, direction: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, starting_direction_count: <span class="tok-type">u32</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2114">    <span class="tok-kw">var</span> direction_count = starting_direction_count;</span>
<span class="line" id="L2115"></span>
<span class="line" id="L2116">    <span class="tok-comment">// From the Source repo in System/PieQuadrant.h, under the name c_PieQuadrantSlotCount</span>
</span>
<span class="line" id="L2117">    <span class="tok-kw">const</span> PieQuadrantSlotCount = <span class="tok-number">5</span>;</span>
<span class="line" id="L2118"></span>
<span class="line" id="L2119">    <span class="tok-kw">for</span> (pie_menu.children.items) |menu_child| {</span>
<span class="line" id="L2120">        <span class="tok-kw">if</span> (menu_child.property) |meny_child_property| {</span>
<span class="line" id="L2121">            <span class="tok-kw">if</span> (strEql(meny_child_property, <span class="tok-str">&quot;AddPieSlice&quot;</span>)) {</span>
<span class="line" id="L2122">                <span class="tok-kw">if</span> (menu_child.value) |value| {</span>
<span class="line" id="L2123">                    <span class="tok-kw">if</span> (strEql(value, <span class="tok-str">&quot;PieSlice&quot;</span>)) {</span>
<span class="line" id="L2124">                        <span class="tok-kw">for</span> (menu_child.children.items) |*slice_child| {</span>
<span class="line" id="L2125">                            <span class="tok-kw">if</span> (slice_child.property) |slice_child_property| {</span>
<span class="line" id="L2126">                                <span class="tok-kw">if</span> (strEql(slice_child_property, <span class="tok-str">&quot;Direction&quot;</span>)) {</span>
<span class="line" id="L2127">                                    <span class="tok-kw">if</span> (slice_child.value) |slice_child_value| {</span>
<span class="line" id="L2128">                                        <span class="tok-kw">if</span> (strEql(slice_child_value, direction)) {</span>
<span class="line" id="L2129">                                            <span class="tok-kw">if</span> (direction_count == PieQuadrantSlotCount) {</span>
<span class="line" id="L2130">                                                slice_child.value = <span class="tok-str">&quot;Any&quot;</span>;</span>
<span class="line" id="L2131">                                            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2132">                                                direction_count += <span class="tok-number">1</span>;</span>
<span class="line" id="L2133">                                            }</span>
<span class="line" id="L2134">                                        }</span>
<span class="line" id="L2135">                                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2136">                                        <span class="tok-kw">return</span> UpdateIniFileTreeErrors.ExpectedValue;</span>
<span class="line" id="L2137">                                    }</span>
<span class="line" id="L2138">                                }</span>
<span class="line" id="L2139">                            }</span>
<span class="line" id="L2140">                        }</span>
<span class="line" id="L2141">                    }</span>
<span class="line" id="L2142">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2143">                    <span class="tok-kw">return</span> UpdateIniFileTreeErrors.ExpectedValue;</span>
<span class="line" id="L2144">                }</span>
<span class="line" id="L2145">            }</span>
<span class="line" id="L2146">        }</span>
<span class="line" id="L2147">    }</span>
<span class="line" id="L2148">}</span>
<span class="line" id="L2149"></span>
<span class="line" id="L2150"><span class="tok-kw">fn</span> <span class="tok-fn">removeSlTerrainProperties</span>(node: *Node, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2151">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L2152">        <span class="tok-kw">if</span> (strEql(property, <span class="tok-str">&quot;Terrain&quot;</span>) <span class="tok-kw">or</span> strEql(property, <span class="tok-str">&quot;AddTerrain&quot;</span>)) {</span>
<span class="line" id="L2153">            <span class="tok-kw">if</span> (node.value) |value| {</span>
<span class="line" id="L2154">                <span class="tok-kw">if</span> (strEql(value, <span class="tok-str">&quot;SLTerrain&quot;</span>)) {</span>
<span class="line" id="L2155">                    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L2156">                        <span class="tok-kw">if</span> (child.property) |child_property| {</span>
<span class="line" id="L2157">                            <span class="tok-comment">// Remove DrawTransparent from the Terrain</span>
</span>
<span class="line" id="L2158">                            <span class="tok-kw">if</span> (strEql(child_property, <span class="tok-str">&quot;DrawTransparent&quot;</span>)) {</span>
<span class="line" id="L2159">                                child.property = <span class="tok-null">null</span>;</span>
<span class="line" id="L2160">                                child.value = <span class="tok-null">null</span>;</span>
<span class="line" id="L2161">                                child.comments = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(allocator);</span>
<span class="line" id="L2162">                                child.children = ArrayList(Node).init(allocator);</span>
<span class="line" id="L2163">                            }</span>
<span class="line" id="L2164"></span>
<span class="line" id="L2165">                            <span class="tok-comment">// Remove Offset and ScrollRatio and ScaleFactor from the Terrain</span>
</span>
<span class="line" id="L2166">                            <span class="tok-kw">if</span> (strEql(child_property, <span class="tok-str">&quot;Offset&quot;</span>) <span class="tok-kw">or</span> strEql(child_property, <span class="tok-str">&quot;ScrollRatio&quot;</span>) <span class="tok-kw">or</span> strEql(child_property, <span class="tok-str">&quot;ScaleFactor&quot;</span>)) {</span>
<span class="line" id="L2167">                                <span class="tok-kw">if</span> (child.value) |child_value| {</span>
<span class="line" id="L2168">                                    <span class="tok-kw">if</span> (strEql(child_value, <span class="tok-str">&quot;Vector&quot;</span>)) {</span>
<span class="line" id="L2169">                                        child.property = <span class="tok-null">null</span>;</span>
<span class="line" id="L2170">                                        child.value = <span class="tok-null">null</span>;</span>
<span class="line" id="L2171">                                        child.comments = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(allocator);</span>
<span class="line" id="L2172">                                        child.children = ArrayList(Node).init(allocator);</span>
<span class="line" id="L2173">                                    }</span>
<span class="line" id="L2174">                                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2175">                                    <span class="tok-kw">return</span> UpdateIniFileTreeErrors.ExpectedValue;</span>
<span class="line" id="L2176">                                }</span>
<span class="line" id="L2177">                            }</span>
<span class="line" id="L2178">                        }</span>
<span class="line" id="L2179">                    }</span>
<span class="line" id="L2180">                }</span>
<span class="line" id="L2181">            }</span>
<span class="line" id="L2182">        }</span>
<span class="line" id="L2183">    }</span>
<span class="line" id="L2184">}</span>
<span class="line" id="L2185"></span>
<span class="line" id="L2186"><span class="tok-kw">fn</span> <span class="tok-fn">shovelFlashFix</span>(node: *Node) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2187">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L2188">        <span class="tok-kw">if</span> (strEql(property, <span class="tok-str">&quot;AddDevice&quot;</span>)) {</span>
<span class="line" id="L2189">            <span class="tok-kw">if</span> (node.value) |value| {</span>
<span class="line" id="L2190">                <span class="tok-kw">if</span> (strEql(value, <span class="tok-str">&quot;HDFirearm&quot;</span>)) {</span>
<span class="line" id="L2191">                    <span class="tok-kw">var</span> changed_shovel_sprite = <span class="tok-null">false</span>;</span>
<span class="line" id="L2192"></span>
<span class="line" id="L2193">                    <span class="tok-kw">for</span> (node.children.items) |firearm_child| {</span>
<span class="line" id="L2194">                        <span class="tok-kw">if</span> (firearm_child.property) |firearm_child_property| {</span>
<span class="line" id="L2195">                            <span class="tok-kw">if</span> (strEql(firearm_child_property, <span class="tok-str">&quot;SpriteFile&quot;</span>)) {</span>
<span class="line" id="L2196">                                <span class="tok-kw">if</span> (firearm_child.value) |firearm_child_value| {</span>
<span class="line" id="L2197">                                    <span class="tok-kw">if</span> (strEql(firearm_child_value, <span class="tok-str">&quot;ContentFile&quot;</span>)) {</span>
<span class="line" id="L2198">                                        <span class="tok-kw">for</span> (firearm_child.children.items) |*content_file_child| {</span>
<span class="line" id="L2199">                                            <span class="tok-kw">if</span> (content_file_child.property) |content_file_child_property| {</span>
<span class="line" id="L2200">                                                <span class="tok-kw">if</span> (strEql(content_file_child_property, <span class="tok-str">&quot;FilePath&quot;</span>)) {</span>
<span class="line" id="L2201">                                                    <span class="tok-kw">if</span> (content_file_child.value) |content_file_child_value| {</span>
<span class="line" id="L2202">                                                        <span class="tok-kw">if</span> (strEql(content_file_child_value, <span class="tok-str">&quot;Ronin.rte/Effects/Pyro/Flashes/ShovelFlash.png&quot;</span>)) {</span>
<span class="line" id="L2203">                                                            content_file_child.value = <span class="tok-str">&quot;Ronin.rte/Devices/Tools/Shovel/Effects/ShovelFlash.png&quot;</span>;</span>
<span class="line" id="L2204"></span>
<span class="line" id="L2205">                                                            changed_shovel_sprite = <span class="tok-null">true</span>;</span>
<span class="line" id="L2206">                                                        }</span>
<span class="line" id="L2207">                                                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2208">                                                        <span class="tok-kw">return</span> UpdateIniFileTreeErrors.ExpectedValue;</span>
<span class="line" id="L2209">                                                    }</span>
<span class="line" id="L2210">                                                }</span>
<span class="line" id="L2211">                                            }</span>
<span class="line" id="L2212">                                        }</span>
<span class="line" id="L2213">                                    }</span>
<span class="line" id="L2214">                                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2215">                                    <span class="tok-kw">return</span> UpdateIniFileTreeErrors.ExpectedValue;</span>
<span class="line" id="L2216">                                }</span>
<span class="line" id="L2217">                            }</span>
<span class="line" id="L2218">                        }</span>
<span class="line" id="L2219">                    }</span>
<span class="line" id="L2220"></span>
<span class="line" id="L2221">                    <span class="tok-kw">if</span> (changed_shovel_sprite) {</span>
<span class="line" id="L2222">                        <span class="tok-kw">for</span> (node.children.items) |*firearm_child| {</span>
<span class="line" id="L2223">                            <span class="tok-kw">if</span> (firearm_child.property) |firearm_child_property| {</span>
<span class="line" id="L2224">                                <span class="tok-kw">if</span> (strEql(firearm_child_property, <span class="tok-str">&quot;FrameCount&quot;</span>)) {</span>
<span class="line" id="L2225">                                    <span class="tok-kw">if</span> (firearm_child.value) |firearm_child_value| {</span>
<span class="line" id="L2226">                                        <span class="tok-kw">if</span> (strEql(firearm_child_value, <span class="tok-str">&quot;2&quot;</span>)) {</span>
<span class="line" id="L2227">                                            firearm_child.value = <span class="tok-str">&quot;1&quot;</span>;</span>
<span class="line" id="L2228">                                        }</span>
<span class="line" id="L2229">                                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2230">                                        <span class="tok-kw">return</span> UpdateIniFileTreeErrors.ExpectedValue;</span>
<span class="line" id="L2231">                                    }</span>
<span class="line" id="L2232">                                }</span>
<span class="line" id="L2233">                            }</span>
<span class="line" id="L2234">                        }</span>
<span class="line" id="L2235">                    }</span>
<span class="line" id="L2236">                }</span>
<span class="line" id="L2237">            }</span>
<span class="line" id="L2238">        }</span>
<span class="line" id="L2239">    }</span>
<span class="line" id="L2240">}</span>
<span class="line" id="L2241"></span>
<span class="line" id="L2242"><span class="tok-kw">fn</span> <span class="tok-fn">writeIniFileTree</span>(file_tree: *<span class="tok-kw">const</span> IniFolder, output_folder_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2243">    <span class="tok-kw">for</span> (file_tree.files.items) |file| {</span>
<span class="line" id="L2244">        <span class="tok-kw">const</span> file_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ output_folder_path, file.name });</span>
<span class="line" id="L2245">        <span class="tok-kw">try</span> writeAst(&amp;file.ast, file_path);</span>
<span class="line" id="L2246">    }</span>
<span class="line" id="L2247"></span>
<span class="line" id="L2248">    <span class="tok-kw">for</span> (file_tree.folders.items) |folder| {</span>
<span class="line" id="L2249">        <span class="tok-kw">const</span> child_output_folder_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ output_folder_path, folder.name });</span>
<span class="line" id="L2250">        <span class="tok-kw">try</span> writeIniFileTree(&amp;folder, child_output_folder_path, allocator);</span>
<span class="line" id="L2251">    }</span>
<span class="line" id="L2252">}</span>
<span class="line" id="L2253"></span>
<span class="line" id="L2254"><span class="tok-kw">fn</span> <span class="tok-fn">writeAst</span>(ast: *<span class="tok-kw">const</span> ArrayList(Node), output_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2255">    <span class="tok-kw">const</span> cwd = std.fs.cwd();</span>
<span class="line" id="L2256">    <span class="tok-kw">const</span> output_file = <span class="tok-kw">try</span> cwd.createFile(output_path, .{});</span>
<span class="line" id="L2257">    <span class="tok-kw">defer</span> output_file.close();</span>
<span class="line" id="L2258"></span>
<span class="line" id="L2259">    <span class="tok-kw">var</span> buffered = bufferedWriter(output_file.writer());</span>
<span class="line" id="L2260">    <span class="tok-kw">const</span> buffered_writer = buffered.writer();</span>
<span class="line" id="L2261"></span>
<span class="line" id="L2262">    <span class="tok-kw">for</span> (ast.items, <span class="tok-number">0</span>..) |*node, index| {</span>
<span class="line" id="L2263">        <span class="tok-kw">try</span> writeAstRecursively(node, buffered_writer, <span class="tok-number">0</span>);</span>
<span class="line" id="L2264"></span>
<span class="line" id="L2265">        <span class="tok-comment">// Don't add a trailing newline,</span>
</span>
<span class="line" id="L2266">        <span class="tok-comment">// since writeAstRecursively() already adds it</span>
</span>
<span class="line" id="L2267">        <span class="tok-kw">if</span> (node.property != <span class="tok-null">null</span> <span class="tok-kw">and</span> index &lt; ast.items.len - <span class="tok-number">1</span>) {</span>
<span class="line" id="L2268">            <span class="tok-kw">try</span> writeBuffered(buffered_writer, <span class="tok-str">&quot;\n&quot;</span>);</span>
<span class="line" id="L2269">        }</span>
<span class="line" id="L2270">    }</span>
<span class="line" id="L2271"></span>
<span class="line" id="L2272">    <span class="tok-kw">try</span> buffered.flush();</span>
<span class="line" id="L2273">}</span>
<span class="line" id="L2274"></span>
<span class="line" id="L2275"><span class="tok-kw">fn</span> <span class="tok-fn">writeAstRecursively</span>(node: *Node, buffered_writer: <span class="tok-kw">anytype</span>, depth: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2276">    <span class="tok-comment">// Don't add an empty line</span>
</span>
<span class="line" id="L2277">    <span class="tok-kw">if</span> (node.property == <span class="tok-null">null</span> <span class="tok-kw">and</span> node.comments.items.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L2278">        <span class="tok-kw">return</span>;</span>
<span class="line" id="L2279">    }</span>
<span class="line" id="L2280"></span>
<span class="line" id="L2281">    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2282">    <span class="tok-kw">while</span> (i &lt; depth) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L2283">        <span class="tok-kw">try</span> writeBuffered(buffered_writer, <span class="tok-str">&quot;\t&quot;</span>);</span>
<span class="line" id="L2284">    }</span>
<span class="line" id="L2285"></span>
<span class="line" id="L2286">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L2287">        <span class="tok-kw">try</span> writeBuffered(buffered_writer, property);</span>
<span class="line" id="L2288">    }</span>
<span class="line" id="L2289"></span>
<span class="line" id="L2290">    <span class="tok-kw">if</span> (node.value) |value| {</span>
<span class="line" id="L2291">        <span class="tok-kw">try</span> writeBuffered(buffered_writer, <span class="tok-str">&quot; = &quot;</span>);</span>
<span class="line" id="L2292">        <span class="tok-kw">try</span> writeBuffered(buffered_writer, value);</span>
<span class="line" id="L2293">    }</span>
<span class="line" id="L2294"></span>
<span class="line" id="L2295">    <span class="tok-kw">if</span> (node.comments.items.len &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L2296">        <span class="tok-kw">if</span> (node.property != <span class="tok-null">null</span>) {</span>
<span class="line" id="L2297">            <span class="tok-kw">try</span> writeBuffered(buffered_writer, <span class="tok-str">&quot; &quot;</span>);</span>
<span class="line" id="L2298">        }</span>
<span class="line" id="L2299"></span>
<span class="line" id="L2300">        <span class="tok-kw">try</span> writeBuffered(buffered_writer, <span class="tok-str">&quot;//&quot;</span>);</span>
<span class="line" id="L2301"></span>
<span class="line" id="L2302">        <span class="tok-kw">for</span> (node.comments.items) |comment| {</span>
<span class="line" id="L2303">            <span class="tok-kw">try</span> writeBuffered(buffered_writer, <span class="tok-str">&quot; &quot;</span>);</span>
<span class="line" id="L2304">            <span class="tok-kw">try</span> writeBuffered(buffered_writer, comment);</span>
<span class="line" id="L2305">        }</span>
<span class="line" id="L2306">    }</span>
<span class="line" id="L2307"></span>
<span class="line" id="L2308">    <span class="tok-kw">try</span> writeBuffered(buffered_writer, <span class="tok-str">&quot;\n&quot;</span>);</span>
<span class="line" id="L2309"></span>
<span class="line" id="L2310">    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L2311">        <span class="tok-kw">try</span> writeAstRecursively(child, buffered_writer, depth + <span class="tok-number">1</span>);</span>
<span class="line" id="L2312">    }</span>
<span class="line" id="L2313">}</span>
<span class="line" id="L2314"></span>
<span class="line" id="L2315"><span class="tok-kw">fn</span> <span class="tok-fn">writeBuffered</span>(buffered_writer: <span class="tok-kw">anytype</span>, string: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2316">    <span class="tok-kw">try</span> buffered_writer.print(<span class="tok-str">&quot;{s}&quot;</span>, .{string});</span>
<span class="line" id="L2317">}</span>
<span class="line" id="L2318"></span>
<span class="line" id="L2319"><span class="tok-kw">test</span> <span class="tok-str">&quot;general&quot;</span> {</span>
<span class="line" id="L2320">    <span class="tok-kw">try</span> testDirectory(<span class="tok-str">&quot;general&quot;</span>, <span class="tok-null">false</span>);</span>
<span class="line" id="L2321">}</span>
<span class="line" id="L2322"></span>
<span class="line" id="L2323"><span class="tok-kw">test</span> <span class="tok-str">&quot;ini_rules&quot;</span> {</span>
<span class="line" id="L2324">    <span class="tok-kw">try</span> testDirectory(<span class="tok-str">&quot;ini_rules&quot;</span>, <span class="tok-null">false</span>);</span>
<span class="line" id="L2325">}</span>
<span class="line" id="L2326"></span>
<span class="line" id="L2327"><span class="tok-kw">test</span> <span class="tok-str">&quot;invalid&quot;</span> {</span>
<span class="line" id="L2328">    <span class="tok-kw">try</span> testDirectory(<span class="tok-str">&quot;invalid&quot;</span>, <span class="tok-null">true</span>);</span>
<span class="line" id="L2329">}</span>
<span class="line" id="L2330"></span>
<span class="line" id="L2331"><span class="tok-kw">test</span> <span class="tok-str">&quot;lua_rules&quot;</span> {</span>
<span class="line" id="L2332">    <span class="tok-kw">try</span> testDirectory(<span class="tok-str">&quot;lua_rules&quot;</span>, <span class="tok-null">false</span>);</span>
<span class="line" id="L2333">}</span>
<span class="line" id="L2334"></span>
<span class="line" id="L2335"><span class="tok-kw">test</span> <span class="tok-str">&quot;mod&quot;</span> {</span>
<span class="line" id="L2336">    <span class="tok-kw">try</span> testDirectory(<span class="tok-str">&quot;mod&quot;</span>, <span class="tok-null">false</span>);</span>
<span class="line" id="L2337">}</span>
<span class="line" id="L2338"></span>
<span class="line" id="L2339"><span class="tok-kw">test</span> <span class="tok-str">&quot;updated&quot;</span> {</span>
<span class="line" id="L2340">    <span class="tok-kw">try</span> testDirectory(<span class="tok-str">&quot;updated&quot;</span>, <span class="tok-null">false</span>);</span>
<span class="line" id="L2341">}</span>
<span class="line" id="L2342"></span>
<span class="line" id="L2343"><span class="tok-kw">fn</span> <span class="tok-fn">testDirectory</span>(<span class="tok-kw">comptime</span> directory_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, is_invalid_test: <span class="tok-type">bool</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2344">    <span class="tok-kw">var</span> iterable_tests = <span class="tok-kw">try</span> std.fs.cwd().openIterableDir(<span class="tok-str">&quot;tests/&quot;</span> ++ directory_name, .{});</span>
<span class="line" id="L2345">    <span class="tok-kw">defer</span> iterable_tests.close();</span>
<span class="line" id="L2346"></span>
<span class="line" id="L2347">    <span class="tok-kw">var</span> arena = ArenaAllocator.init(page_allocator);</span>
<span class="line" id="L2348">    <span class="tok-kw">defer</span> arena.deinit();</span>
<span class="line" id="L2349">    <span class="tok-kw">const</span> allocator = arena.allocator();</span>
<span class="line" id="L2350"></span>
<span class="line" id="L2351">    <span class="tok-kw">var</span> tests_walker = <span class="tok-kw">try</span> iterable_tests.walk(allocator);</span>
<span class="line" id="L2352">    <span class="tok-kw">defer</span> tests_walker.deinit();</span>
<span class="line" id="L2353"></span>
<span class="line" id="L2354">    <span class="tok-kw">while</span> (<span class="tok-kw">try</span> tests_walker.next()) |entry| {</span>
<span class="line" id="L2355">        <span class="tok-kw">if</span> (entry.kind == std.fs.File.Kind.directory <span class="tok-kw">and</span> strEql(entry.basename, <span class="tok-str">&quot;input&quot;</span>)) {</span>
<span class="line" id="L2356">            std.debug.print(<span class="tok-str">&quot;\nSubtest '&quot;</span> ++ directory_name ++ <span class="tok-str">&quot;/{s}'&quot;</span>, .{std.fs.path.dirname(entry.path) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;null&quot;</span>});</span>
<span class="line" id="L2357"></span>
<span class="line" id="L2358">            <span class="tok-kw">var</span> test_folder_path_buffer: [MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L2359">            <span class="tok-kw">const</span> test_folder_path = <span class="tok-kw">try</span> entry.dir.realpath(<span class="tok-str">&quot;.&quot;</span>, &amp;test_folder_path_buffer);</span>
<span class="line" id="L2360"></span>
<span class="line" id="L2361">            <span class="tok-kw">const</span> input_folder_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ test_folder_path, <span class="tok-str">&quot;input&quot;</span> });</span>
<span class="line" id="L2362"></span>
<span class="line" id="L2363">            <span class="tok-kw">var</span> tmpdir_output_folder = tmpDir(.{});</span>
<span class="line" id="L2364">            <span class="tok-kw">defer</span> tmpdir_output_folder.cleanup();</span>
<span class="line" id="L2365">            <span class="tok-kw">var</span> tmpdir_output_folder_path_buffer: [MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L2366">            <span class="tok-kw">const</span> tmpdir_output_folder_path = <span class="tok-kw">try</span> tmpdir_output_folder.dir.realpath(<span class="tok-str">&quot;.&quot;</span>, &amp;tmpdir_output_folder_path_buffer);</span>
<span class="line" id="L2367"></span>
<span class="line" id="L2368">            <span class="tok-kw">var</span> diagnostics: Diagnostics = .{};</span>
<span class="line" id="L2369">            convert(input_folder_path, tmpdir_output_folder_path, allocator, &amp;diagnostics) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L2370">                <span class="tok-kw">if</span> (is_invalid_test) {</span>
<span class="line" id="L2371">                    <span class="tok-kw">const</span> error_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ test_folder_path, <span class="tok-str">&quot;expected_error.txt&quot;</span> });</span>
<span class="line" id="L2372"></span>
<span class="line" id="L2373">                    <span class="tok-kw">const</span> cwd = std.fs.cwd();</span>
<span class="line" id="L2374">                    <span class="tok-kw">const</span> error_file = <span class="tok-kw">try</span> cwd.openFile(error_path, .{});</span>
<span class="line" id="L2375">                    <span class="tok-kw">defer</span> error_file.close();</span>
<span class="line" id="L2376"></span>
<span class="line" id="L2377">                    <span class="tok-kw">var</span> error_buf_reader = bufferedReader(error_file.reader());</span>
<span class="line" id="L2378">                    <span class="tok-kw">const</span> error_stream = error_buf_reader.reader();</span>
<span class="line" id="L2379">                    <span class="tok-kw">const</span> error_text_crlf = <span class="tok-kw">try</span> error_stream.readAllAlloc(allocator, maxInt(<span class="tok-type">usize</span>));</span>
<span class="line" id="L2380">                    <span class="tok-kw">const</span> error_text = <span class="tok-kw">try</span> crlfToLf(error_text_crlf, allocator);</span>
<span class="line" id="L2381"></span>
<span class="line" id="L2382">                    <span class="tok-kw">try</span> expectEqualStrings(error_text, <span class="tok-builtin">@errorName</span>(err));</span>
<span class="line" id="L2383">                    std.debug.print(<span class="tok-str">&quot; passed&quot;</span>, .{});</span>
<span class="line" id="L2384"></span>
<span class="line" id="L2385">                    <span class="tok-kw">continue</span>;</span>
<span class="line" id="L2386">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2387">                    <span class="tok-kw">return</span> err;</span>
<span class="line" id="L2388">                }</span>
<span class="line" id="L2389">            };</span>
<span class="line" id="L2390"></span>
<span class="line" id="L2391">            <span class="tok-kw">if</span> (is_invalid_test) {</span>
<span class="line" id="L2392">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidTestDidntReturnError;</span>
<span class="line" id="L2393">            }</span>
<span class="line" id="L2394"></span>
<span class="line" id="L2395">            <span class="tok-kw">const</span> expected_result_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ test_folder_path, <span class="tok-str">&quot;expected_result&quot;</span> });</span>
<span class="line" id="L2396">            <span class="tok-kw">try</span> testDirectoryFiles(test_folder_path, expected_result_path, tmpdir_output_folder_path, allocator);</span>
<span class="line" id="L2397"></span>
<span class="line" id="L2398">            std.debug.print(<span class="tok-str">&quot; passed&quot;</span>, .{});</span>
<span class="line" id="L2399">        }</span>
<span class="line" id="L2400">    }</span>
<span class="line" id="L2401"></span>
<span class="line" id="L2402">    std.debug.print(<span class="tok-str">&quot;\n\n&quot;</span>, .{});</span>
<span class="line" id="L2403">}</span>
<span class="line" id="L2404"></span>
<span class="line" id="L2405"><span class="tok-kw">fn</span> <span class="tok-fn">testDirectoryFiles</span>(test_folder_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, expected_result_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, tmpdir_output_folder_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2406">    <span class="tok-kw">var</span> iterable_expected_result = <span class="tok-kw">try</span> std.fs.cwd().openIterableDir(expected_result_path, .{});</span>
<span class="line" id="L2407">    <span class="tok-kw">defer</span> iterable_expected_result.close();</span>
<span class="line" id="L2408"></span>
<span class="line" id="L2409">    <span class="tok-kw">var</span> expected_result_walker = <span class="tok-kw">try</span> iterable_expected_result.walk(allocator);</span>
<span class="line" id="L2410">    <span class="tok-kw">defer</span> expected_result_walker.deinit();</span>
<span class="line" id="L2411"></span>
<span class="line" id="L2412">    <span class="tok-kw">while</span> (<span class="tok-kw">try</span> expected_result_walker.next()) |expected_result_entry| {</span>
<span class="line" id="L2413">        <span class="tok-kw">if</span> (expected_result_entry.kind == std.fs.File.Kind.file) {</span>
<span class="line" id="L2414">            <span class="tok-kw">const</span> expected_file_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ expected_result_path, expected_result_entry.path });</span>
<span class="line" id="L2415"></span>
<span class="line" id="L2416">            <span class="tok-kw">const</span> cwd = std.fs.cwd();</span>
<span class="line" id="L2417">            <span class="tok-kw">const</span> expected_file = <span class="tok-kw">try</span> cwd.openFile(expected_file_path, .{});</span>
<span class="line" id="L2418">            <span class="tok-kw">defer</span> expected_file.close();</span>
<span class="line" id="L2419"></span>
<span class="line" id="L2420">            <span class="tok-kw">var</span> expected_buf_reader = bufferedReader(expected_file.reader());</span>
<span class="line" id="L2421">            <span class="tok-kw">const</span> expected_stream = expected_buf_reader.reader();</span>
<span class="line" id="L2422">            <span class="tok-kw">const</span> expected_text_crlf = <span class="tok-kw">try</span> expected_stream.readAllAlloc(allocator, maxInt(<span class="tok-type">usize</span>));</span>
<span class="line" id="L2423">            <span class="tok-kw">const</span> expected_text = <span class="tok-kw">try</span> crlfToLf(expected_text_crlf, allocator);</span>
<span class="line" id="L2424"></span>
<span class="line" id="L2425">            <span class="tok-kw">const</span> output_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ tmpdir_output_folder_path, expected_result_entry.path });</span>
<span class="line" id="L2426">            <span class="tok-kw">const</span> output_file = <span class="tok-kw">try</span> cwd.openFile(output_path, .{});</span>
<span class="line" id="L2427">            <span class="tok-kw">defer</span> output_file.close();</span>
<span class="line" id="L2428"></span>
<span class="line" id="L2429">            <span class="tok-kw">var</span> output_buf_reader = bufferedReader(output_file.reader());</span>
<span class="line" id="L2430">            <span class="tok-kw">const</span> output_stream = output_buf_reader.reader();</span>
<span class="line" id="L2431">            <span class="tok-kw">const</span> output_text_crlf = <span class="tok-kw">try</span> output_stream.readAllAlloc(allocator, maxInt(<span class="tok-type">usize</span>));</span>
<span class="line" id="L2432">            <span class="tok-kw">const</span> output_text = <span class="tok-kw">try</span> crlfToLf(output_text_crlf, allocator);</span>
<span class="line" id="L2433"></span>
<span class="line" id="L2434">            <span class="tok-kw">const</span> ext = extension(expected_result_entry.basename);</span>
<span class="line" id="L2435">            <span class="tok-kw">if</span> (strEql(ext, <span class="tok-str">&quot;.png&quot;</span>) <span class="tok-kw">or</span> strEql(ext, <span class="tok-str">&quot;.flac&quot;</span>)) {</span>
<span class="line" id="L2436">                <span class="tok-kw">if</span> (indexOfDiff(<span class="tok-type">u8</span>, expected_text, output_text)) |diff_index| {</span>
<span class="line" id="L2437">                    <span class="tok-kw">const</span> unequal_copy_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ test_folder_path, expected_result_entry.basename });</span>
<span class="line" id="L2438"></span>
<span class="line" id="L2439">                    std.debug.print(<span class="tok-str">&quot;\nUnequal file at index {} is '{s}'; copying it to `{s}`\n&quot;</span>, .{ diff_index, output_path, unequal_copy_path });</span>
<span class="line" id="L2440">                    <span class="tok-kw">try</span> copyFileAbsolute(output_path, unequal_copy_path, .{});</span>
<span class="line" id="L2441"></span>
<span class="line" id="L2442">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.unequalFiles;</span>
<span class="line" id="L2443">                }</span>
<span class="line" id="L2444">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2445">                <span class="tok-kw">try</span> expectEqualStrings(expected_text, output_text);</span>
<span class="line" id="L2446">            }</span>
<span class="line" id="L2447">        }</span>
<span class="line" id="L2448">    }</span>
<span class="line" id="L2449">}</span>
<span class="line" id="L2450"></span>
<span class="line" id="L2451"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">beautifyLua</span>(output_folder_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2452">    std.log.info(<span class="tok-str">&quot;Beautifying Lua...\n&quot;</span>, .{});</span>
<span class="line" id="L2453">    <span class="tok-comment">// TODO: Do we want to compile this from source?</span>
</span>
<span class="line" id="L2454">    <span class="tok-kw">const</span> argv = [_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ <span class="tok-str">&quot;stylua&quot;</span>, output_folder_path };</span>
<span class="line" id="L2455">    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> std.ChildProcess.exec(.{ .argv = &amp;argv, .allocator = allocator });</span>
<span class="line" id="L2456">    _ = result;</span>
<span class="line" id="L2457">}</span>
<span class="line" id="L2458"></span>
<span class="line" id="L2459"><span class="tok-comment">// TODO: Turn these // into ///, to turn it into documentation again</span>
</span>
<span class="line" id="L2460"><span class="tok-comment">// For every directory name in `input_folder_path`, it looks in `output_folder_path` for a directory with the same name.</span>
</span>
<span class="line" id="L2461"><span class="tok-comment">// If there is a directory with the same name, it creates a zip of that directory next to it.</span>
</span>
<span class="line" id="L2462"><span class="tok-comment">// pub fn zipMods(input_folder_path: []const u8, output_folder_path: []const u8, allocator: Allocator) !void {</span>
</span>
<span class="line" id="L2463"><span class="tok-comment">//     var iterable_dir = try std.fs.openIterableDirAbsolute(input_folder_path, .{});</span>
</span>
<span class="line" id="L2464"><span class="tok-comment">//     defer iterable_dir.close();</span>
</span>
<span class="line" id="L2465"><span class="tok-comment">//     var dir_iterator = iterable_dir.iterate();</span>
</span>
<span class="line" id="L2466"></span>
<span class="line" id="L2467"><span class="tok-comment">//     while (try dir_iterator.next()) |entry| {</span>
</span>
<span class="line" id="L2468"><span class="tok-comment">//         if (entry.kind == std.fs.File.Kind.directory) {</span>
</span>
<span class="line" id="L2469"><span class="tok-comment">//             const mod_folder_path = try join(allocator, &amp;.{ output_folder_path, entry.name });</span>
</span>
<span class="line" id="L2470"></span>
<span class="line" id="L2471"><span class="tok-comment">//             const needle = &quot;.rte&quot;;</span>
</span>
<span class="line" id="L2472"><span class="tok-comment">//             const replacement = &quot;-pre5.2-v1.0.zip&quot;;</span>
</span>
<span class="line" id="L2473"><span class="tok-comment">//             const name = try allocator.alloc(u8, replacementSize(u8, entry.name, needle, replacement));</span>
</span>
<span class="line" id="L2474"><span class="tok-comment">//             _ = replace(u8, entry.name, needle, replacement, name);</span>
</span>
<span class="line" id="L2475"></span>
<span class="line" id="L2476"><span class="tok-comment">//             const mod_zip_path = try allocator.dupeZ(u8, try join(allocator, &amp;.{ output_folder_path, name }));</span>
</span>
<span class="line" id="L2477"></span>
<span class="line" id="L2478"><span class="tok-comment">//             var zip = ziplib.zip_open(mod_zip_path.ptr, ziplib.ZIP_DEFAULT_COMPRESSION_LEVEL, 'w') orelse return error.ZipOpen;</span>
</span>
<span class="line" id="L2479"></span>
<span class="line" id="L2480"><span class="tok-comment">//             try zipModRecursively(zip, mod_folder_path, entry.name);</span>
</span>
<span class="line" id="L2481"></span>
<span class="line" id="L2482"><span class="tok-comment">//             ziplib.zip_close(zip);</span>
</span>
<span class="line" id="L2483"><span class="tok-comment">//         }</span>
</span>
<span class="line" id="L2484"><span class="tok-comment">//     }</span>
</span>
<span class="line" id="L2485"><span class="tok-comment">// }</span>
</span>
<span class="line" id="L2486"></span>
<span class="line" id="L2487"><span class="tok-comment">// fn zipModRecursively(zip: *ziplib.zip_t, full_path: []const u8, sub_path: []const u8) !void {</span>
</span>
<span class="line" id="L2488"><span class="tok-comment">//     var child_full_path_buffer: [std.fs.MAX_PATH_BYTES]u8 = undefined;</span>
</span>
<span class="line" id="L2489"><span class="tok-comment">//     var child_sub_path_buffer: [std.fs.MAX_PATH_BYTES]u8 = undefined;</span>
</span>
<span class="line" id="L2490"></span>
<span class="line" id="L2491"><span class="tok-comment">//     var iterable_dir = try std.fs.openIterableDirAbsolute(full_path, .{});</span>
</span>
<span class="line" id="L2492"><span class="tok-comment">//     defer iterable_dir.close();</span>
</span>
<span class="line" id="L2493"><span class="tok-comment">//     var dir_iterator = iterable_dir.iterate();</span>
</span>
<span class="line" id="L2494"></span>
<span class="line" id="L2495"><span class="tok-comment">//     while (try dir_iterator.next()) |entry| {</span>
</span>
<span class="line" id="L2496"><span class="tok-comment">//         const child_full_path = try std.fmt.bufPrintZ(&amp;child_full_path_buffer, &quot;{s}/{s}&quot;, .{ full_path, entry.name });</span>
</span>
<span class="line" id="L2497"><span class="tok-comment">//         const child_sub_path = try std.fmt.bufPrintZ(&amp;child_sub_path_buffer, &quot;{s}/{s}&quot;, .{ sub_path, entry.name });</span>
</span>
<span class="line" id="L2498"></span>
<span class="line" id="L2499"><span class="tok-comment">//         if (entry.kind == std.fs.File.Kind.file) {</span>
</span>
<span class="line" id="L2500"><span class="tok-comment">//             // TODO: Not sure whether these files are ever actually returned by Zig's dir iterator</span>
</span>
<span class="line" id="L2501"><span class="tok-comment">//             if (strEql(entry.name, &quot;.&quot;) or strEql(entry.name, &quot;..&quot;))</span>
</span>
<span class="line" id="L2502"><span class="tok-comment">//                 continue;</span>
</span>
<span class="line" id="L2503"></span>
<span class="line" id="L2504"><span class="tok-comment">//             if (ziplib.zip_entry_open(zip, child_sub_path) &lt; 0) return error.ZipEntryOpen;</span>
</span>
<span class="line" id="L2505"><span class="tok-comment">//             if (ziplib.zip_entry_fwrite(zip, child_full_path) &lt; 0) return error.ZipEntryFwrite;</span>
</span>
<span class="line" id="L2506"><span class="tok-comment">//             if (ziplib.zip_entry_close(zip) &lt; 0) return error.ZipEntryClose;</span>
</span>
<span class="line" id="L2507"><span class="tok-comment">//         } else if (entry.kind == std.fs.File.Kind.directory) {</span>
</span>
<span class="line" id="L2508"><span class="tok-comment">//             try zipModRecursively(zip, child_full_path, child_sub_path);</span>
</span>
<span class="line" id="L2509"><span class="tok-comment">//         }</span>
</span>
<span class="line" id="L2510"><span class="tok-comment">//     }</span>
</span>
<span class="line" id="L2511"><span class="tok-comment">// }</span>
</span>
<span class="line" id="L2512"></span>
</code></pre></body>
</html>