<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>main.zig - source view</title>
    <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAPNJREFUeNpi/P//PwMlgOXHUjly9E0G4hwgZmQiQZMqEK8H4v9QzUEgQSaoADK+zhH9iAGL+C0gDoAaNg9mGLoLfgA1awK9hS9gzgJxA9RQBmQDrgMxJzRMGKE4HYj/Ial5A8QmQLwCJoBsgBYW2+TR1ChDaWt4LOBxKsi/VUh8XiD+gq4IVyzwQAMJBoKwacZlAB8Qf0bi96IZhtOAe1D6LpqaEiz6rmEzQAeIzwGxCJpieFqApo/vQKyJboAaEBsAsSEupwI1MwKjGBTVHOhegMX5UajYRqiBjMgYmj400cVh0XgTiKdC0zhJgJHS7AwQYABm9EAdCKrEfAAAAABJRU5ErkJggg=="/>
    <style>
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }

      pre > code {
        display: block;
        overflow: auto;
        line-height: normal;
        margin: 0em;
      }
      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }
      pre {
        counter-reset: line;
      }
      pre .line:before {
        counter-increment: line;
        content: counter(line);
        display: inline-block;
        padding-right: 1em;
        width: 2em;
        text-align: right;
        color: #999;
      }
      
      .line {
        width: 100%;
        display: inline-block;
      }
      .line:target {
        border-top: 1px solid #ccc;
        border-bottom: 1px solid #ccc;
        background: #fafafa;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#222;
            color: #ccc;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        .line:target {
            border-top: 1px solid #444;
            border-bottom: 1px solid #444;
            background: #333;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
      }
    </style>
</head>
<body>
<pre><code><span class="line" id="L1"><span class="tok-kw">const</span> std = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;std&quot;</span>);</span>
<span class="line" id="L2"><span class="tok-kw">const</span> builtin = <span class="tok-builtin">@import</span>(<span class="tok-str">&quot;builtin&quot;</span>);</span>
<span class="line" id="L3"></span>
<span class="line" id="L4"><span class="tok-kw">const</span> default_max_load_percentage = std.hash_map.default_max_load_percentage;</span>
<span class="line" id="L5"><span class="tok-kw">const</span> default_max_value_len = std.json.default_max_value_len;</span>
<span class="line" id="L6"><span class="tok-kw">const</span> MAX_PATH_BYTES = std.fs.MAX_PATH_BYTES;</span>
<span class="line" id="L7"><span class="tok-kw">const</span> page_allocator = std.heap.page_allocator;</span>
<span class="line" id="L8"></span>
<span class="line" id="L9"><span class="tok-kw">const</span> Allocator = std.mem.Allocator;</span>
<span class="line" id="L10"><span class="tok-kw">const</span> ArenaAllocator = std.heap.ArenaAllocator;</span>
<span class="line" id="L11"><span class="tok-kw">const</span> ArrayList = std.ArrayList;</span>
<span class="line" id="L12"><span class="tok-kw">const</span> HashMap = std.hash_map.HashMap;</span>
<span class="line" id="L13"><span class="tok-kw">const</span> MultiArrayList = std.MultiArrayList;</span>
<span class="line" id="L14"><span class="tok-kw">const</span> Scanner = std.json.Scanner;</span>
<span class="line" id="L15"><span class="tok-kw">const</span> StringHashMap = std.hash_map.StringHashMap;</span>
<span class="line" id="L16"></span>
<span class="line" id="L17"><span class="tok-kw">const</span> allocPrint = std.fmt.allocPrint;</span>
<span class="line" id="L18"><span class="tok-kw">const</span> basename = std.fs.path.basename;</span>
<span class="line" id="L19"><span class="tok-kw">const</span> bufferedReader = std.io.bufferedReader;</span>
<span class="line" id="L20"><span class="tok-kw">const</span> bufferedWriter = std.io.bufferedWriter;</span>
<span class="line" id="L21"><span class="tok-kw">const</span> copyFileAbsolute = std.fs.copyFileAbsolute;</span>
<span class="line" id="L22"><span class="tok-kw">const</span> endsWith = std.mem.endsWith;</span>
<span class="line" id="L23"><span class="tok-kw">const</span> eql = std.mem.eql;</span>
<span class="line" id="L24"><span class="tok-kw">const</span> expectEqualStrings = std.testing.expectEqualStrings;</span>
<span class="line" id="L25"><span class="tok-kw">const</span> extension = std.fs.path.extension;</span>
<span class="line" id="L26"><span class="tok-kw">const</span> fabs = std.math.fabs;</span>
<span class="line" id="L27"><span class="tok-kw">const</span> fmtSliceEscapeUpper = std.fmt.fmtSliceEscapeUpper;</span>
<span class="line" id="L28"><span class="tok-kw">const</span> indexOfDiff = std.mem.indexOfDiff;</span>
<span class="line" id="L29"><span class="tok-kw">const</span> join = std.fs.path.join;</span>
<span class="line" id="L30"><span class="tok-kw">const</span> makeDirAbsolute = std.fs.makeDirAbsolute;</span>
<span class="line" id="L31"><span class="tok-kw">const</span> maxInt = std.math.maxInt;</span>
<span class="line" id="L32"><span class="tok-kw">const</span> parseFloat = std.fmt.parseFloat;</span>
<span class="line" id="L33"><span class="tok-kw">const</span> parseFromSliceLeaky = std.json.parseFromSliceLeaky;</span>
<span class="line" id="L34"><span class="tok-kw">const</span> realpath = std.fs.realpath;</span>
<span class="line" id="L35"><span class="tok-kw">const</span> replace = std.mem.replace;</span>
<span class="line" id="L36"><span class="tok-kw">const</span> replacementSize = std.mem.replacementSize;</span>
<span class="line" id="L37"><span class="tok-kw">const</span> tmpDir = std.testing.tmpDir;</span>
<span class="line" id="L38"><span class="tok-kw">const</span> trim = std.mem.trim;</span>
<span class="line" id="L39"><span class="tok-kw">const</span> updateFileAbsolute = std.fs.updateFileAbsolute;</span>
<span class="line" id="L40"></span>
<span class="line" id="L41"><span class="tok-comment">/// The purpose of the converter engine is to take an .ini input file like this:</span></span>
<span class="line" id="L42"><span class="tok-comment">/// /* foo1   */ /* foo2*//*foo3*/</span></span>
<span class="line" id="L43"><span class="tok-comment">/// DataModule</span></span>
<span class="line" id="L44"><span class="tok-comment">/// \tSupportedGameVersion = Pre4</span></span>
<span class="line" id="L45"><span class="tok-comment">/// \t/* bar */IconFile      = ContentFile /* baz</span></span>
<span class="line" id="L46"><span class="tok-comment">/// bee */\t\tFilePath=foo.png</span></span>
<span class="line" id="L47"><span class="tok-comment">/// \tDescription = bop</span></span>
<span class="line" id="L48"><span class="tok-comment">///</span></span>
<span class="line" id="L49"><span class="tok-comment">/// and to turn it into this .ini output file:</span></span>
<span class="line" id="L50"><span class="tok-comment">/// // foo1 foo2 foo3</span></span>
<span class="line" id="L51"><span class="tok-comment">/// DataModule</span></span>
<span class="line" id="L52"><span class="tok-comment">/// \tSupportedGameVersion = Pre4</span></span>
<span class="line" id="L53"><span class="tok-comment">/// \tIconFile = ContentFile // bar baz</span></span>
<span class="line" id="L54"><span class="tok-comment">/// \t\tFilePath = foo.png // bee</span></span>
<span class="line" id="L55"><span class="tok-comment">/// \tDescription = bop</span></span>
<span class="line" id="L56"><span class="tok-comment">///</span></span>
<span class="line" id="L57"><span class="tok-comment">/// returned in the form of this Abstract Syntax Tree:</span></span>
<span class="line" id="L58"><span class="tok-comment">/// {</span></span>
<span class="line" id="L59"><span class="tok-comment">///     {</span></span>
<span class="line" id="L60"><span class="tok-comment">///         .comments = { &quot;foo1&quot;, &quot;foo2&quot;, &quot;foo3&quot; };</span></span>
<span class="line" id="L61"><span class="tok-comment">///     },</span></span>
<span class="line" id="L62"><span class="tok-comment">///     {</span></span>
<span class="line" id="L63"><span class="tok-comment">///         .property = &quot;DataModule&quot;;</span></span>
<span class="line" id="L64"><span class="tok-comment">///         .children = {</span></span>
<span class="line" id="L65"><span class="tok-comment">///             {</span></span>
<span class="line" id="L66"><span class="tok-comment">///                 .property = &quot;SupportedGameVersion&quot;;</span></span>
<span class="line" id="L67"><span class="tok-comment">///                 .value = &quot;Pre4&quot;;</span></span>
<span class="line" id="L68"><span class="tok-comment">///             },</span></span>
<span class="line" id="L69"><span class="tok-comment">///             {</span></span>
<span class="line" id="L70"><span class="tok-comment">///                 .property = &quot;IconFile&quot;;</span></span>
<span class="line" id="L71"><span class="tok-comment">///                 .value = &quot;ContentFile&quot;;</span></span>
<span class="line" id="L72"><span class="tok-comment">///                 .comments = { &quot;bar&quot;, &quot;baz&quot; };</span></span>
<span class="line" id="L73"><span class="tok-comment">///                 .children = {</span></span>
<span class="line" id="L74"><span class="tok-comment">///                     .property = &quot;FilePath&quot;;</span></span>
<span class="line" id="L75"><span class="tok-comment">///                     .value = &quot;foo.png&quot;;</span></span>
<span class="line" id="L76"><span class="tok-comment">///                     .comments = { &quot;bee&quot; };</span></span>
<span class="line" id="L77"><span class="tok-comment">///                 }</span></span>
<span class="line" id="L78"><span class="tok-comment">///             },</span></span>
<span class="line" id="L79"><span class="tok-comment">///             {</span></span>
<span class="line" id="L80"><span class="tok-comment">///                 .property = &quot;Description&quot;;</span></span>
<span class="line" id="L81"><span class="tok-comment">///                 .value = &quot;bop&quot;;</span></span>
<span class="line" id="L82"><span class="tok-comment">///             }</span></span>
<span class="line" id="L83"><span class="tok-comment">///         }</span></span>
<span class="line" id="L84"><span class="tok-comment">///     }</span></span>
<span class="line" id="L85"><span class="tok-comment">/// }</span></span>
<span class="line" id="L86"><span class="tok-kw">const</span> Token = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L87">    <span class="tok-type">type</span>: Type,</span>
<span class="line" id="L88">    slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L89"></span>
<span class="line" id="L90">    <span class="tok-comment">// TODO: Can I turn this struct into a tagged union,</span>
</span>
<span class="line" id="L91">    <span class="tok-comment">// in order to get rid of this Type enum definition?</span>
</span>
<span class="line" id="L92">    <span class="tok-kw">const</span> Type = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L93">        Comment,</span>
<span class="line" id="L94">        Tabs,</span>
<span class="line" id="L95">        Spaces,</span>
<span class="line" id="L96">        Equals,</span>
<span class="line" id="L97">        Newline,</span>
<span class="line" id="L98">        Sentence,</span>
<span class="line" id="L99">    };</span>
<span class="line" id="L100">};</span>
<span class="line" id="L101"></span>
<span class="line" id="L102"><span class="tok-kw">const</span> Node = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L103">    property: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L104">    value: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L105">    comments: ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>),</span>
<span class="line" id="L106">    children: ArrayList(Node),</span>
<span class="line" id="L107">};</span>
<span class="line" id="L108"></span>
<span class="line" id="L109"><span class="tok-kw">const</span> Rule = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L110">    old_property: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L111">    old_value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L112">    new_property: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L113">    new_value: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L114">};</span>
<span class="line" id="L115"></span>
<span class="line" id="L116"><span class="tok-kw">const</span> IniFile = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L117">    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L118">    ast: ArrayList(Node),</span>
<span class="line" id="L119">};</span>
<span class="line" id="L120"></span>
<span class="line" id="L121"><span class="tok-kw">const</span> IniFolder = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L122">    name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L123">    files: ArrayList(IniFile),</span>
<span class="line" id="L124">    folders: ArrayList(IniFolder),</span>
<span class="line" id="L125">};</span>
<span class="line" id="L126"></span>
<span class="line" id="L127"><span class="tok-comment">/// Updated by `convert()` to record what it is doing.</span></span>
<span class="line" id="L128"><span class="tok-comment">/// If `convert()` crashed, look inside this struct to see why and where it did.</span></span>
<span class="line" id="L129"><span class="tok-kw">pub</span> <span class="tok-kw">const</span> Diagnostics = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L130">    file_path: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L131">    token: ?[]<span class="tok-kw">const</span> <span class="tok-type">u8</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L132">    line: ?<span class="tok-type">i32</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L133">    column: ?<span class="tok-type">i32</span> = <span class="tok-null">null</span>,</span>
<span class="line" id="L134">};</span>
<span class="line" id="L135"></span>
<span class="line" id="L136"><span class="tok-kw">const</span> PropertyValuePair = <span class="tok-kw">struct</span> {</span>
<span class="line" id="L137">    property: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L138">    value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>,</span>
<span class="line" id="L139">};</span>
<span class="line" id="L140"></span>
<span class="line" id="L141"><span class="tok-kw">const</span> UpdateIniFileTreeErrors = <span class="tok-kw">error</span>{</span>
<span class="line" id="L142">    ExpectedValue,</span>
<span class="line" id="L143">};</span>
<span class="line" id="L144"></span>
<span class="line" id="L145"><span class="tok-comment">// TODO: Refactor into a CLI</span>
</span>
<span class="line" id="L146"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">main</span>() !<span class="tok-type">void</span> {</span>
<span class="line" id="L147">    <span class="tok-kw">var</span> arena = ArenaAllocator.init(page_allocator);</span>
<span class="line" id="L148">    <span class="tok-kw">defer</span> arena.deinit();</span>
<span class="line" id="L149">    <span class="tok-kw">var</span> allocator = arena.allocator();</span>
<span class="line" id="L150"></span>
<span class="line" id="L151">    <span class="tok-kw">var</span> args = <span class="tok-kw">try</span> std.process.argsWithAllocator(allocator);</span>
<span class="line" id="L152">    <span class="tok-kw">defer</span> args.deinit();</span>
<span class="line" id="L153"></span>
<span class="line" id="L154">    <span class="tok-kw">const</span> program_name = args.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ExpectedProgramName;</span>
<span class="line" id="L155">    _ = program_name;</span>
<span class="line" id="L156">    <span class="tok-kw">const</span> input_folder_path = args.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ExpectedInputFolderPath;</span>
<span class="line" id="L157">    <span class="tok-kw">const</span> output_folder_path = args.next() <span class="tok-kw">orelse</span> <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ExpectedOutputFolderPath;</span>
<span class="line" id="L158"></span>
<span class="line" id="L159">    <span class="tok-kw">var</span> diagnostics: Diagnostics = .{};</span>
<span class="line" id="L160">    convert(</span>
<span class="line" id="L161">        input_folder_path,</span>
<span class="line" id="L162">        output_folder_path,</span>
<span class="line" id="L163">        allocator,</span>
<span class="line" id="L164">        &amp;diagnostics,</span>
<span class="line" id="L165">    ) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L166">        <span class="tok-kw">error</span>.InvalidInputPath =&gt; {</span>
<span class="line" id="L167">            std.log.info(<span class="tok-str">&quot;Error: Invalid input path&quot;</span>, .{});</span>
<span class="line" id="L168">            <span class="tok-kw">return</span> err;</span>
<span class="line" id="L169">        },</span>
<span class="line" id="L170">        <span class="tok-kw">error</span>.InvalidOutputPath =&gt; {</span>
<span class="line" id="L171">            std.log.info(<span class="tok-str">&quot;Error: Invalid output path&quot;</span>, .{});</span>
<span class="line" id="L172">            <span class="tok-kw">return</span> err;</span>
<span class="line" id="L173">        },</span>
<span class="line" id="L174">        <span class="tok-kw">error</span>.UnexpectedToken =&gt; {</span>
<span class="line" id="L175">            std.log.info(<span class="tok-str">&quot;Error: Unexpected '{s}' at {s}:{}:{}\n&quot;</span>, .{</span>
<span class="line" id="L176">                diagnostics.token <span class="tok-kw">orelse</span> <span class="tok-str">&quot;null&quot;</span>,</span>
<span class="line" id="L177">                diagnostics.file_path <span class="tok-kw">orelse</span> <span class="tok-str">&quot;null&quot;</span>,</span>
<span class="line" id="L178">                diagnostics.line <span class="tok-kw">orelse</span> -<span class="tok-number">1</span>,</span>
<span class="line" id="L179">                diagnostics.column <span class="tok-kw">orelse</span> -<span class="tok-number">1</span>,</span>
<span class="line" id="L180">            });</span>
<span class="line" id="L181">            <span class="tok-kw">return</span> err;</span>
<span class="line" id="L182">        },</span>
<span class="line" id="L183">        <span class="tok-kw">error</span>.UnclosedMultiComment =&gt; {</span>
<span class="line" id="L184">            std.log.info(<span class="tok-str">&quot;Error: Unclosed multi-line comment in file {s}\n&quot;</span>, .{</span>
<span class="line" id="L185">                diagnostics.file_path <span class="tok-kw">orelse</span> <span class="tok-str">&quot;null&quot;</span>,</span>
<span class="line" id="L186">            });</span>
<span class="line" id="L187">            <span class="tok-kw">return</span> err;</span>
<span class="line" id="L188">        },</span>
<span class="line" id="L189">        <span class="tok-kw">error</span>.TooManyTabs =&gt; {</span>
<span class="line" id="L190">            std.log.info(<span class="tok-str">&quot;Error: Too many tabs at {s}:{}:{}\n&quot;</span>, .{</span>
<span class="line" id="L191">                diagnostics.file_path <span class="tok-kw">orelse</span> <span class="tok-str">&quot;null&quot;</span>,</span>
<span class="line" id="L192">                diagnostics.line <span class="tok-kw">orelse</span> -<span class="tok-number">1</span>,</span>
<span class="line" id="L193">                diagnostics.column <span class="tok-kw">orelse</span> -<span class="tok-number">1</span>,</span>
<span class="line" id="L194">            });</span>
<span class="line" id="L195">            <span class="tok-kw">return</span> err;</span>
<span class="line" id="L196">        },</span>
<span class="line" id="L197">        <span class="tok-kw">error</span>.ExpectedADataModule =&gt; {</span>
<span class="line" id="L198">            std.log.info(<span class="tok-str">&quot;Error: Expected a DataModule\n&quot;</span>, .{});</span>
<span class="line" id="L199">            <span class="tok-kw">return</span> err;</span>
<span class="line" id="L200">        },</span>
<span class="line" id="L201">        <span class="tok-kw">error</span>.ContainsMoreThanOneDataModule =&gt; {</span>
<span class="line" id="L202">            std.log.info(<span class="tok-str">&quot;Error: The mod contains more than one DataModule\n&quot;</span>, .{});</span>
<span class="line" id="L203">            <span class="tok-kw">return</span> err;</span>
<span class="line" id="L204">        },</span>
<span class="line" id="L205">        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L206">    };</span>
<span class="line" id="L207"></span>
<span class="line" id="L208">    <span class="tok-kw">try</span> beautifyLua(output_folder_path, allocator);</span>
<span class="line" id="L209">}</span>
<span class="line" id="L210"></span>
<span class="line" id="L211"><span class="tok-comment">/// For every mod directory in `input_folder_path`, it creates a copy of the mod directory in `output_folder_path` with the required changes to make it compatible with the latest version of the game.</span></span>
<span class="line" id="L212"><span class="tok-comment">/// If `convert()` crashed, the `diagnostics` argument allows you to know why and where it did.</span></span>
<span class="line" id="L213"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">convert</span>(input_folder_path_: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, output_folder_path_: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allocator: Allocator, diagnostics: *Diagnostics) !<span class="tok-type">void</span> {</span>
<span class="line" id="L214">    <span class="tok-comment">// Necessary solely because of .OBJECT_NAME_INVALID =&gt; unreachable in the std lib:</span>
</span>
<span class="line" id="L215">    <span class="tok-comment">// https://github.com/ziglang/zig/issues/15607#issue-1698930560</span>
</span>
<span class="line" id="L216">    <span class="tok-kw">if</span> (!<span class="tok-kw">try</span> isValidDirPath(input_folder_path_)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidInputPath;</span>
<span class="line" id="L217">    <span class="tok-kw">if</span> (!<span class="tok-kw">try</span> isValidDirPath(output_folder_path_)) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidOutputPath;</span>
<span class="line" id="L218"></span>
<span class="line" id="L219">    <span class="tok-kw">const</span> input_folder_path = <span class="tok-kw">try</span> std.fs.realpathAlloc(allocator, input_folder_path_);</span>
<span class="line" id="L220">    <span class="tok-kw">const</span> output_folder_path = <span class="tok-kw">try</span> std.fs.realpathAlloc(allocator, output_folder_path_);</span>
<span class="line" id="L221"></span>
<span class="line" id="L222">    std.log.info(<span class="tok-str">&quot;Making all output dirs...\n&quot;</span>, .{});</span>
<span class="line" id="L223">    <span class="tok-kw">try</span> makeOutputDirs(input_folder_path, output_folder_path, allocator);</span>
<span class="line" id="L224"></span>
<span class="line" id="L225">    std.log.info(<span class="tok-str">&quot;Copying files...\n&quot;</span>, .{});</span>
<span class="line" id="L226">    <span class="tok-kw">try</span> copyFiles(input_folder_path, output_folder_path, allocator);</span>
<span class="line" id="L227"></span>
<span class="line" id="L228">    <span class="tok-kw">const</span> lua_rules = <span class="tok-kw">try</span> parseLuaRules(allocator);</span>
<span class="line" id="L229">    std.log.info(<span class="tok-str">&quot;Applying Lua rules...\n&quot;</span>, .{});</span>
<span class="line" id="L230">    <span class="tok-kw">try</span> applyLuaRules(lua_rules, output_folder_path, allocator);</span>
<span class="line" id="L231"></span>
<span class="line" id="L232">    std.log.info(<span class="tok-str">&quot;Getting INI file tree...\n&quot;</span>, .{});</span>
<span class="line" id="L233">    <span class="tok-kw">var</span> file_tree = <span class="tok-kw">try</span> getIniFileTree(input_folder_path, allocator, diagnostics);</span>
<span class="line" id="L234"></span>
<span class="line" id="L235">    std.log.info(<span class="tok-str">&quot;Getting the mod's game version...\n&quot;</span>, .{});</span>
<span class="line" id="L236">    <span class="tok-kw">const</span> mod_version = <span class="tok-kw">try</span> getModVersion(&amp;file_tree);</span>
<span class="line" id="L237"></span>
<span class="line" id="L238">    <span class="tok-comment">// Check the version, since people since Pre6 are able to start using magenta</span>
</span>
<span class="line" id="L239">    <span class="tok-comment">// as a regular color in their RGB pngs</span>
</span>
<span class="line" id="L240">    <span class="tok-kw">if</span> (mod_version == ModVersion.BeforePre6) {</span>
<span class="line" id="L241">        std.log.info(<span class="tok-str">&quot;Replacing magenta in RGB .pngs with alpha...\n&quot;</span>, .{});</span>
<span class="line" id="L242">        <span class="tok-kw">try</span> replaceMagentaInRgbPngsWithAlpha(output_folder_path, allocator);</span>
<span class="line" id="L243">    }</span>
<span class="line" id="L244"></span>
<span class="line" id="L245">    std.log.info(<span class="tok-str">&quot;Replacing Path with FilePath...\n&quot;</span>, .{});</span>
<span class="line" id="L246">    <span class="tok-kw">try</span> applyOnNodes(pathToFilePath, &amp;file_tree);</span>
<span class="line" id="L247"></span>
<span class="line" id="L248">    <span class="tok-comment">// It also HAS to be called before applyIniFilePathRules(),</span>
</span>
<span class="line" id="L249">    <span class="tok-comment">// because otherwise this could happen:</span>
</span>
<span class="line" id="L250">    <span class="tok-comment">// The game reports that Base.rte/foo.png doesn't exist,</span>
</span>
<span class="line" id="L251">    <span class="tok-comment">// so the user enters this ini_file_path_rules.json rule:</span>
</span>
<span class="line" id="L252">    <span class="tok-comment">// &quot;Base.rte/foo.png&quot;: &quot;Base.rte/bar.png&quot;</span>
</span>
<span class="line" id="L253">    <span class="tok-comment">// The game reports that Base.rte/foo.png *still* doesn't exist,</span>
</span>
<span class="line" id="L254">    <span class="tok-comment">// due to the parsed input mod containing &quot;Base.rte/foo.bmp&quot;!</span>
</span>
<span class="line" id="L255">    std.log.info(<span class="tok-str">&quot;Bmp extension to png...\n&quot;</span>, .{});</span>
<span class="line" id="L256">    <span class="tok-kw">try</span> applyOnNodesAlloc(bmpExtensionToPng, &amp;file_tree, allocator);</span>
<span class="line" id="L257"></span>
<span class="line" id="L258">    std.log.info(<span class="tok-str">&quot;Wav extension to flac...\n&quot;</span>, .{});</span>
<span class="line" id="L259">    <span class="tok-kw">try</span> applyOnNodesAlloc(wavExtensionToFlac, &amp;file_tree, allocator);</span>
<span class="line" id="L260"></span>
<span class="line" id="L261">    <span class="tok-kw">const</span> ini_copy_of_rules = <span class="tok-kw">try</span> parseIniCopyOfRules(allocator);</span>
<span class="line" id="L262">    std.log.info(<span class="tok-str">&quot;Applying INI CopyOf rules...\n&quot;</span>, .{});</span>
<span class="line" id="L263">    applyIniCopyOfRules(ini_copy_of_rules, &amp;file_tree);</span>
<span class="line" id="L264"></span>
<span class="line" id="L265">    <span class="tok-kw">const</span> ini_file_path_rules = <span class="tok-kw">try</span> parseIniFilePathRules(allocator);</span>
<span class="line" id="L266">    std.log.info(<span class="tok-str">&quot;Applying INI FilePath rules...\n&quot;</span>, .{});</span>
<span class="line" id="L267">    applyIniFilePathRules(ini_file_path_rules, &amp;file_tree);</span>
<span class="line" id="L268"></span>
<span class="line" id="L269">    <span class="tok-kw">const</span> ini_script_path_rules = <span class="tok-kw">try</span> parseIniScriptPathRules(allocator);</span>
<span class="line" id="L270">    std.log.info(<span class="tok-str">&quot;Applying INI ScriptPath rules...\n&quot;</span>, .{});</span>
<span class="line" id="L271">    applyIniScriptPathRules(ini_script_path_rules, &amp;file_tree);</span>
<span class="line" id="L272"></span>
<span class="line" id="L273">    <span class="tok-kw">const</span> ini_property_rules = <span class="tok-kw">try</span> parseIniPropertyRules(allocator);</span>
<span class="line" id="L274">    std.log.info(<span class="tok-str">&quot;Applying INI property rules...\n&quot;</span>, .{});</span>
<span class="line" id="L275">    applyIniPropertyRules(ini_property_rules, &amp;file_tree);</span>
<span class="line" id="L276"></span>
<span class="line" id="L277">    <span class="tok-kw">const</span> ini_rules = <span class="tok-kw">try</span> parseIniRules(allocator);</span>
<span class="line" id="L278">    std.log.info(<span class="tok-str">&quot;Applying INI rules...\n&quot;</span>, .{});</span>
<span class="line" id="L279">    applyIniRules(ini_rules, &amp;file_tree);</span>
<span class="line" id="L280"></span>
<span class="line" id="L281">    <span class="tok-kw">const</span> ini_sound_container_rules = <span class="tok-kw">try</span> parseIniSoundContainerRules(allocator);</span>
<span class="line" id="L282">    std.log.info(<span class="tok-str">&quot;Applying INI SoundContainer rules...\n&quot;</span>, .{});</span>
<span class="line" id="L283">    applyIniSoundContainerRules(ini_sound_container_rules, &amp;file_tree);</span>
<span class="line" id="L284"></span>
<span class="line" id="L285">    std.log.info(<span class="tok-str">&quot;Updating INI file tree...\n&quot;</span>, .{});</span>
<span class="line" id="L286">    <span class="tok-kw">try</span> updateIniFileTree(&amp;file_tree, allocator);</span>
<span class="line" id="L287"></span>
<span class="line" id="L288">    std.log.info(<span class="tok-str">&quot;Writing INI file tree...\n&quot;</span>, .{});</span>
<span class="line" id="L289">    <span class="tok-kw">try</span> writeIniFileTree(&amp;file_tree, output_folder_path, allocator);</span>
<span class="line" id="L290">}</span>
<span class="line" id="L291"></span>
<span class="line" id="L292"><span class="tok-kw">fn</span> <span class="tok-fn">isValidDirPath</span>(path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">bool</span> {</span>
<span class="line" id="L293">    <span class="tok-kw">if</span> (builtin.os.tag != .windows) <span class="tok-kw">return</span> <span class="tok-kw">error</span>.OnlySupportingWindowsSowwy;</span>
<span class="line" id="L294"></span>
<span class="line" id="L295">    <span class="tok-kw">const</span> d = std.fs.cwd();</span>
<span class="line" id="L296">    <span class="tok-kw">const</span> path_w_slice = <span class="tok-kw">try</span> std.os.windows.sliceToPrefixedFileW(d.fd, path);</span>
<span class="line" id="L297">    <span class="tok-kw">const</span> path_w = path_w_slice.span().ptr;</span>
<span class="line" id="L298"></span>
<span class="line" id="L299">    <span class="tok-kw">const</span> w = std.os.windows;</span>
<span class="line" id="L300">    <span class="tok-kw">const</span> access_mask = w.STANDARD_RIGHTS_READ | w.FILE_READ_ATTRIBUTES | w.FILE_READ_EA |</span>
<span class="line" id="L301">        w.SYNCHRONIZE | w.FILE_TRAVERSE;</span>
<span class="line" id="L302"></span>
<span class="line" id="L303">    <span class="tok-kw">var</span> result = std.fs.Dir{</span>
<span class="line" id="L304">        .fd = <span class="tok-null">undefined</span>,</span>
<span class="line" id="L305">    };</span>
<span class="line" id="L306">    <span class="tok-kw">const</span> path_len_bytes = <span class="tok-builtin">@as</span>(<span class="tok-type">u16</span>, <span class="tok-builtin">@intCast</span>(std.mem.sliceTo(path_w, <span class="tok-number">0</span>).len * <span class="tok-number">2</span>));</span>
<span class="line" id="L307">    <span class="tok-kw">var</span> nt_name = w.UNICODE_STRING{</span>
<span class="line" id="L308">        .Length = path_len_bytes,</span>
<span class="line" id="L309">        .MaximumLength = path_len_bytes,</span>
<span class="line" id="L310">        .Buffer = <span class="tok-builtin">@constCast</span>(path_w),</span>
<span class="line" id="L311">    };</span>
<span class="line" id="L312">    <span class="tok-kw">var</span> attr = w.OBJECT_ATTRIBUTES{</span>
<span class="line" id="L313">        .Length = <span class="tok-builtin">@sizeOf</span>(w.OBJECT_ATTRIBUTES),</span>
<span class="line" id="L314">        .RootDirectory = <span class="tok-kw">if</span> (std.fs.path.isAbsoluteWindowsW(path_w)) <span class="tok-null">null</span> <span class="tok-kw">else</span> d.fd,</span>
<span class="line" id="L315">        .Attributes = <span class="tok-number">0</span>, <span class="tok-comment">// Note we do not use OBJ_CASE_INSENSITIVE here.</span>
</span>
<span class="line" id="L316">        .ObjectName = &amp;nt_name,</span>
<span class="line" id="L317">        .SecurityDescriptor = <span class="tok-null">null</span>,</span>
<span class="line" id="L318">        .SecurityQualityOfService = <span class="tok-null">null</span>,</span>
<span class="line" id="L319">    };</span>
<span class="line" id="L320"></span>
<span class="line" id="L321">    <span class="tok-kw">const</span> no_follow = <span class="tok-null">false</span>;</span>
<span class="line" id="L322">    <span class="tok-kw">const</span> open_reparse_point: w.DWORD = <span class="tok-kw">if</span> (no_follow) w.FILE_OPEN_REPARSE_POINT <span class="tok-kw">else</span> <span class="tok-number">0x0</span>;</span>
<span class="line" id="L323">    <span class="tok-kw">var</span> io: w.IO_STATUS_BLOCK = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L324"></span>
<span class="line" id="L325">    <span class="tok-kw">const</span> rc = w.ntdll.NtCreateFile(</span>
<span class="line" id="L326">        &amp;result.fd,</span>
<span class="line" id="L327">        access_mask,</span>
<span class="line" id="L328">        &amp;attr,</span>
<span class="line" id="L329">        &amp;io,</span>
<span class="line" id="L330">        <span class="tok-null">null</span>,</span>
<span class="line" id="L331">        <span class="tok-number">0</span>,</span>
<span class="line" id="L332">        w.FILE_SHARE_READ | w.FILE_SHARE_WRITE,</span>
<span class="line" id="L333">        w.FILE_OPEN,</span>
<span class="line" id="L334">        w.FILE_DIRECTORY_FILE | w.FILE_SYNCHRONOUS_IO_NONALERT | w.FILE_OPEN_FOR_BACKUP_INTENT | open_reparse_point,</span>
<span class="line" id="L335">        <span class="tok-null">null</span>,</span>
<span class="line" id="L336">        <span class="tok-number">0</span>,</span>
<span class="line" id="L337">    );</span>
<span class="line" id="L338">    <span class="tok-kw">return</span> rc == .SUCCESS;</span>
<span class="line" id="L339">}</span>
<span class="line" id="L340"></span>
<span class="line" id="L341"><span class="tok-kw">fn</span> <span class="tok-fn">makeOutputDirs</span>(input_folder_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, output_folder_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L342">    makeDirAbsolute(output_folder_path) <span class="tok-kw">catch</span> |err| <span class="tok-kw">switch</span> (err) {</span>
<span class="line" id="L343">        <span class="tok-kw">error</span>.PathAlreadyExists =&gt; {},</span>
<span class="line" id="L344">        <span class="tok-kw">else</span> =&gt; |e| <span class="tok-kw">return</span> e,</span>
<span class="line" id="L345">    };</span>
<span class="line" id="L346"></span>
<span class="line" id="L347">    <span class="tok-kw">var</span> iterable_dir = <span class="tok-kw">try</span> std.fs.openIterableDirAbsolute(input_folder_path, .{});</span>
<span class="line" id="L348">    <span class="tok-kw">defer</span> iterable_dir.close();</span>
<span class="line" id="L349">    <span class="tok-kw">var</span> dir_iterator = iterable_dir.iterate();</span>
<span class="line" id="L350"></span>
<span class="line" id="L351">    <span class="tok-kw">while</span> (<span class="tok-kw">try</span> dir_iterator.next()) |entry| {</span>
<span class="line" id="L352">        <span class="tok-kw">if</span> (entry.kind == std.fs.File.Kind.directory) {</span>
<span class="line" id="L353">            <span class="tok-kw">const</span> child_input_folder_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ input_folder_path, entry.name });</span>
<span class="line" id="L354">            <span class="tok-kw">const</span> child_output_folder_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ output_folder_path, entry.name });</span>
<span class="line" id="L355">            <span class="tok-kw">try</span> makeOutputDirs(child_input_folder_path, child_output_folder_path, allocator);</span>
<span class="line" id="L356">        }</span>
<span class="line" id="L357">    }</span>
<span class="line" id="L358">}</span>
<span class="line" id="L359"></span>
<span class="line" id="L360"><span class="tok-comment">/// Doesn't copy .ini files</span></span>
<span class="line" id="L361"><span class="tok-kw">fn</span> <span class="tok-fn">copyFiles</span>(input_folder_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, output_folder_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L362">    <span class="tok-kw">var</span> iterable_dir = <span class="tok-kw">try</span> std.fs.openIterableDirAbsolute(input_folder_path, .{});</span>
<span class="line" id="L363">    <span class="tok-kw">defer</span> iterable_dir.close();</span>
<span class="line" id="L364">    <span class="tok-kw">var</span> dir_iterator = iterable_dir.iterate();</span>
<span class="line" id="L365"></span>
<span class="line" id="L366">    <span class="tok-kw">while</span> (<span class="tok-kw">try</span> dir_iterator.next()) |entry| {</span>
<span class="line" id="L367">        <span class="tok-kw">if</span> (entry.kind == std.fs.File.Kind.file) {</span>
<span class="line" id="L368">            <span class="tok-kw">const</span> ext = extension(entry.name);</span>
<span class="line" id="L369"></span>
<span class="line" id="L370">            <span class="tok-kw">if</span> (strEql(ext, <span class="tok-str">&quot;.bmp&quot;</span>)) {</span>
<span class="line" id="L371">                <span class="tok-kw">const</span> input_file_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ input_folder_path, entry.name });</span>
<span class="line" id="L372"></span>
<span class="line" id="L373">                <span class="tok-kw">var</span> output_name = <span class="tok-kw">try</span> allocator.dupe(<span class="tok-type">u8</span>, entry.name);</span>
<span class="line" id="L374"></span>
<span class="line" id="L375">                output_name[output_name.len - <span class="tok-number">1</span>] = <span class="tok-str">'g'</span>;</span>
<span class="line" id="L376">                output_name[output_name.len - <span class="tok-number">2</span>] = <span class="tok-str">'n'</span>;</span>
<span class="line" id="L377">                output_name[output_name.len - <span class="tok-number">3</span>] = <span class="tok-str">'p'</span>;</span>
<span class="line" id="L378"></span>
<span class="line" id="L379">                <span class="tok-kw">const</span> output_file_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ output_folder_path, output_name });</span>
<span class="line" id="L380"></span>
<span class="line" id="L381">                <span class="tok-kw">const</span> output_file_access = std.fs.accessAbsolute(output_file_path, .{});</span>
<span class="line" id="L382"></span>
<span class="line" id="L383">                <span class="tok-kw">if</span> (output_file_access == <span class="tok-kw">error</span>.FileNotFound) {</span>
<span class="line" id="L384">                    <span class="tok-kw">try</span> convertBmpToPng(input_file_path, output_file_path, allocator);</span>
<span class="line" id="L385">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (output_file_access <span class="tok-kw">catch</span> <span class="tok-null">null</span>) |_| { <span class="tok-comment">// Else if there was no access error</span>
</span>
<span class="line" id="L386">                    <span class="tok-comment">// TODO: Windows can be significantly faster if we use iterable_dir.dir.stat() manually here,</span>
</span>
<span class="line" id="L387">                    <span class="tok-comment">// if (and only if) directory mod times are updated when files change on Windows!</span>
</span>
<span class="line" id="L388"></span>
<span class="line" id="L389">                    <span class="tok-kw">const</span> input_stat = <span class="tok-kw">try</span> iterable_dir.dir.statFile(input_file_path);</span>
<span class="line" id="L390">                    <span class="tok-kw">const</span> output_stat = <span class="tok-kw">try</span> iterable_dir.dir.statFile(output_file_path);</span>
<span class="line" id="L391"></span>
<span class="line" id="L392">                    <span class="tok-kw">if</span> (input_stat.mtime &gt; output_stat.mtime) {</span>
<span class="line" id="L393">                        <span class="tok-comment">// TODO: Figure out whether a different function should be called in this case,</span>
</span>
<span class="line" id="L394">                        <span class="tok-comment">// similar to below where updateFileAbsolute() can be called instead of copyFileAbsolute()</span>
</span>
<span class="line" id="L395">                        <span class="tok-kw">try</span> convertBmpToPng(input_file_path, output_file_path, allocator);</span>
<span class="line" id="L396">                    }</span>
<span class="line" id="L397">                } <span class="tok-kw">else</span> { <span class="tok-comment">// Else return the access error</span>
</span>
<span class="line" id="L398">                    <span class="tok-kw">return</span> output_file_access;</span>
<span class="line" id="L399">                }</span>
<span class="line" id="L400">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (strEql(ext, <span class="tok-str">&quot;.wav&quot;</span>)) {</span>
<span class="line" id="L401">                <span class="tok-kw">const</span> input_file_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ input_folder_path, entry.name });</span>
<span class="line" id="L402"></span>
<span class="line" id="L403">                <span class="tok-comment">// Create a copy of the entry name that is one character longer, so the &quot;c&quot; in .flac fits</span>
</span>
<span class="line" id="L404">                <span class="tok-kw">var</span> output_name = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, entry.name.len + <span class="tok-number">1</span>);</span>
<span class="line" id="L405">                <span class="tok-builtin">@memcpy</span>(output_name[<span class="tok-number">0</span>..entry.name.len], entry.name);</span>
<span class="line" id="L406"></span>
<span class="line" id="L407">                output_name[output_name.len - <span class="tok-number">1</span>] = <span class="tok-str">'c'</span>;</span>
<span class="line" id="L408">                output_name[output_name.len - <span class="tok-number">2</span>] = <span class="tok-str">'a'</span>;</span>
<span class="line" id="L409">                output_name[output_name.len - <span class="tok-number">3</span>] = <span class="tok-str">'l'</span>;</span>
<span class="line" id="L410">                output_name[output_name.len - <span class="tok-number">4</span>] = <span class="tok-str">'f'</span>;</span>
<span class="line" id="L411"></span>
<span class="line" id="L412">                <span class="tok-kw">const</span> output_file_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ output_folder_path, output_name });</span>
<span class="line" id="L413"></span>
<span class="line" id="L414">                <span class="tok-kw">const</span> output_file_access = std.fs.accessAbsolute(output_file_path, .{});</span>
<span class="line" id="L415"></span>
<span class="line" id="L416">                <span class="tok-kw">if</span> (output_file_access == <span class="tok-kw">error</span>.FileNotFound) {</span>
<span class="line" id="L417">                    <span class="tok-kw">try</span> convertWavToFlac(input_file_path, output_file_path, allocator);</span>
<span class="line" id="L418">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (output_file_access <span class="tok-kw">catch</span> <span class="tok-null">null</span>) |_| { <span class="tok-comment">// Else if there was no access error</span>
</span>
<span class="line" id="L419">                    <span class="tok-comment">// TODO: Windows can be significantly faster if we use iterable_dir.dir.stat() manually here,</span>
</span>
<span class="line" id="L420">                    <span class="tok-comment">// if (and only if) directory mod times are updated when files change on Windows!</span>
</span>
<span class="line" id="L421"></span>
<span class="line" id="L422">                    <span class="tok-kw">const</span> input_stat = <span class="tok-kw">try</span> iterable_dir.dir.statFile(input_file_path);</span>
<span class="line" id="L423">                    <span class="tok-kw">const</span> output_stat = <span class="tok-kw">try</span> iterable_dir.dir.statFile(output_file_path);</span>
<span class="line" id="L424"></span>
<span class="line" id="L425">                    <span class="tok-kw">if</span> (input_stat.mtime &gt; output_stat.mtime) {</span>
<span class="line" id="L426">                        <span class="tok-comment">// TODO: Figure out whether a different function should be called in this case,</span>
</span>
<span class="line" id="L427">                        <span class="tok-comment">// similar to below where updateFileAbsolute() can be called instead of copyFileAbsolute()</span>
</span>
<span class="line" id="L428">                        <span class="tok-kw">try</span> convertWavToFlac(input_file_path, output_file_path, allocator);</span>
<span class="line" id="L429">                    }</span>
<span class="line" id="L430">                } <span class="tok-kw">else</span> { <span class="tok-comment">// Else return the access error</span>
</span>
<span class="line" id="L431">                    <span class="tok-kw">return</span> output_file_access;</span>
<span class="line" id="L432">                }</span>
<span class="line" id="L433">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (!strEql(ext, <span class="tok-str">&quot;.ini&quot;</span>)) { <span class="tok-comment">// This function doesn't copy .ini files</span>
</span>
<span class="line" id="L434">                <span class="tok-kw">const</span> input_file_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ input_folder_path, entry.name });</span>
<span class="line" id="L435">                <span class="tok-kw">const</span> output_file_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ output_folder_path, entry.name });</span>
<span class="line" id="L436"></span>
<span class="line" id="L437">                <span class="tok-kw">const</span> output_file_access = std.fs.accessAbsolute(output_file_path, .{});</span>
<span class="line" id="L438"></span>
<span class="line" id="L439">                <span class="tok-kw">if</span> (output_file_access == <span class="tok-kw">error</span>.FileNotFound) {</span>
<span class="line" id="L440">                    <span class="tok-kw">try</span> copyFileAbsolute(input_file_path, output_file_path, .{});</span>
<span class="line" id="L441">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (output_file_access <span class="tok-kw">catch</span> <span class="tok-null">null</span>) |_| { <span class="tok-comment">// Else if there was no access error</span>
</span>
<span class="line" id="L442">                    <span class="tok-comment">// TODO: Windows can be significantly faster if we use iterable_dir.dir.stat() manually here,</span>
</span>
<span class="line" id="L443">                    <span class="tok-comment">// if (and only if) directory mod times are updated when files change on Windows!</span>
</span>
<span class="line" id="L444"></span>
<span class="line" id="L445">                    <span class="tok-kw">const</span> input_stat = <span class="tok-kw">try</span> iterable_dir.dir.statFile(input_file_path);</span>
<span class="line" id="L446">                    <span class="tok-kw">const</span> output_stat = <span class="tok-kw">try</span> iterable_dir.dir.statFile(output_file_path);</span>
<span class="line" id="L447"></span>
<span class="line" id="L448">                    <span class="tok-kw">if</span> (input_stat.mtime &gt; output_stat.mtime) {</span>
<span class="line" id="L449">                        <span class="tok-comment">// TODO: Reverify that this is faster than the plain copyFileAbsolute()</span>
</span>
<span class="line" id="L450">                        _ = <span class="tok-kw">try</span> updateFileAbsolute(input_file_path, output_file_path, .{});</span>
<span class="line" id="L451">                    }</span>
<span class="line" id="L452">                } <span class="tok-kw">else</span> { <span class="tok-comment">// Else return the access error</span>
</span>
<span class="line" id="L453">                    <span class="tok-kw">return</span> output_file_access;</span>
<span class="line" id="L454">                }</span>
<span class="line" id="L455">            }</span>
<span class="line" id="L456">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (entry.kind == std.fs.File.Kind.directory) {</span>
<span class="line" id="L457">            <span class="tok-kw">const</span> child_input_folder_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ input_folder_path, entry.name });</span>
<span class="line" id="L458">            <span class="tok-kw">const</span> child_output_folder_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ output_folder_path, entry.name });</span>
<span class="line" id="L459">            <span class="tok-kw">try</span> copyFiles(child_input_folder_path, child_output_folder_path, allocator);</span>
<span class="line" id="L460">        }</span>
<span class="line" id="L461">    }</span>
<span class="line" id="L462">}</span>
<span class="line" id="L463"></span>
<span class="line" id="L464"><span class="tok-kw">fn</span> <span class="tok-fn">strEql</span>(str1: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, str2: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L465">    <span class="tok-kw">return</span> eql(<span class="tok-type">u8</span>, str1, str2);</span>
<span class="line" id="L466">}</span>
<span class="line" id="L467"></span>
<span class="line" id="L468"><span class="tok-kw">fn</span> <span class="tok-fn">convertBmpToPng</span>(input_file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, output_file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L469">    <span class="tok-kw">const</span> argv = [_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ getFfmpegPath(), <span class="tok-str">&quot;-i&quot;</span>, input_file_path, output_file_path, <span class="tok-str">&quot;-y&quot;</span> };</span>
<span class="line" id="L470">    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> std.ChildProcess.exec(.{ .argv = &amp;argv, .allocator = allocator });</span>
<span class="line" id="L471">    _ = result;</span>
<span class="line" id="L472">}</span>
<span class="line" id="L473"></span>
<span class="line" id="L474"><span class="tok-kw">fn</span> <span class="tok-fn">convertWavToFlac</span>(input_file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, output_file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L475">    <span class="tok-kw">const</span> argv = [_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ getFfmpegPath(), <span class="tok-str">&quot;-i&quot;</span>, input_file_path, output_file_path, <span class="tok-str">&quot;-y&quot;</span> };</span>
<span class="line" id="L476">    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> std.ChildProcess.exec(.{ .argv = &amp;argv, .allocator = allocator });</span>
<span class="line" id="L477">    _ = result;</span>
<span class="line" id="L478"></span>
<span class="line" id="L479">    <span class="tok-comment">// var line_iter = std.mem.split(u8, result.stderr, &quot;\n&quot;);</span>
</span>
<span class="line" id="L480">    <span class="tok-comment">// while (line_iter.next()) |line| {</span>
</span>
<span class="line" id="L481">    <span class="tok-comment">//     if (line.len == 0) continue;</span>
</span>
<span class="line" id="L482">    <span class="tok-comment">// }</span>
</span>
<span class="line" id="L483">}</span>
<span class="line" id="L484"></span>
<span class="line" id="L485"><span class="tok-kw">fn</span> <span class="tok-fn">parseLuaRules</span>(allocator: Allocator) !std.json.ArrayHashMap([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) {</span>
<span class="line" id="L486">    <span class="tok-kw">const</span> text = <span class="tok-kw">try</span> readFile(<span class="tok-str">&quot;rules/lua_rules.json&quot;</span>, allocator);</span>
<span class="line" id="L487"></span>
<span class="line" id="L488">    <span class="tok-kw">var</span> scanner = Scanner.initCompleteInput(allocator, text);</span>
<span class="line" id="L489"></span>
<span class="line" id="L490">    <span class="tok-kw">var</span> lua_rules = <span class="tok-kw">try</span> std.json.ArrayHashMap([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).jsonParse(allocator, &amp;scanner, .{ .allocate = .alloc_if_needed, .max_value_len = default_max_value_len });</span>
<span class="line" id="L491">    <span class="tok-kw">return</span> lua_rules;</span>
<span class="line" id="L492">}</span>
<span class="line" id="L493"></span>
<span class="line" id="L494"><span class="tok-kw">fn</span> <span class="tok-fn">applyLuaRules</span>(lua_rules: std.json.ArrayHashMap([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>), folder_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L495">    <span class="tok-kw">var</span> iterable_dir = <span class="tok-kw">try</span> std.fs.openIterableDirAbsolute(folder_path, .{});</span>
<span class="line" id="L496">    <span class="tok-kw">defer</span> iterable_dir.close();</span>
<span class="line" id="L497">    <span class="tok-kw">var</span> dir_iterator = iterable_dir.iterate();</span>
<span class="line" id="L498"></span>
<span class="line" id="L499">    <span class="tok-kw">while</span> (<span class="tok-kw">try</span> dir_iterator.next()) |dir_entry| {</span>
<span class="line" id="L500">        <span class="tok-kw">if</span> (dir_entry.kind == std.fs.File.Kind.file) {</span>
<span class="line" id="L501">            <span class="tok-kw">if</span> (strEql(extension(dir_entry.name), <span class="tok-str">&quot;.lua&quot;</span>)) {</span>
<span class="line" id="L502">                <span class="tok-kw">const</span> file_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ folder_path, dir_entry.name });</span>
<span class="line" id="L503">                <span class="tok-kw">var</span> text = <span class="tok-kw">try</span> readFile(file_path, allocator);</span>
<span class="line" id="L504"></span>
<span class="line" id="L505">                <span class="tok-kw">var</span> text_contains_any_key = <span class="tok-null">false</span>;</span>
<span class="line" id="L506"></span>
<span class="line" id="L507">                <span class="tok-kw">var</span> map_iterator = lua_rules.map.iterator();</span>
<span class="line" id="L508">                <span class="tok-kw">while</span> (map_iterator.next()) |map_entry| {</span>
<span class="line" id="L509">                    <span class="tok-kw">const</span> key = map_entry.key_ptr.*;</span>
<span class="line" id="L510">                    <span class="tok-kw">const</span> value = map_entry.value_ptr.*;</span>
<span class="line" id="L511"></span>
<span class="line" id="L512">                    <span class="tok-kw">const</span> text_contains_key = std.mem.indexOfPos(<span class="tok-type">u8</span>, text, <span class="tok-number">0</span>, key) != <span class="tok-null">null</span>;</span>
<span class="line" id="L513">                    <span class="tok-kw">if</span> (text_contains_key) {</span>
<span class="line" id="L514">                        text_contains_any_key = <span class="tok-null">true</span>;</span>
<span class="line" id="L515"></span>
<span class="line" id="L516">                        <span class="tok-kw">const</span> replacement_size = replacementSize(<span class="tok-type">u8</span>, text, key, value);</span>
<span class="line" id="L517">                        <span class="tok-kw">const</span> new_text = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, replacement_size);</span>
<span class="line" id="L518">                        _ = replace(<span class="tok-type">u8</span>, text, key, value, new_text);</span>
<span class="line" id="L519">                        text = new_text;</span>
<span class="line" id="L520">                    }</span>
<span class="line" id="L521">                }</span>
<span class="line" id="L522"></span>
<span class="line" id="L523">                <span class="tok-kw">if</span> (text_contains_any_key) {</span>
<span class="line" id="L524">                    <span class="tok-kw">var</span> file = <span class="tok-kw">try</span> std.fs.cwd().createFile(file_path, .{});</span>
<span class="line" id="L525">                    <span class="tok-kw">defer</span> file.close();</span>
<span class="line" id="L526">                    <span class="tok-kw">try</span> file.writeAll(text);</span>
<span class="line" id="L527">                }</span>
<span class="line" id="L528">            }</span>
<span class="line" id="L529">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (dir_entry.kind == std.fs.File.Kind.directory) {</span>
<span class="line" id="L530">            <span class="tok-kw">try</span> applyLuaRules(lua_rules, <span class="tok-kw">try</span> join(allocator, &amp;.{ folder_path, dir_entry.name }), allocator);</span>
<span class="line" id="L531">        }</span>
<span class="line" id="L532">    }</span>
<span class="line" id="L533">}</span>
<span class="line" id="L534"></span>
<span class="line" id="L535"><span class="tok-kw">fn</span> <span class="tok-fn">getIniFileTree</span>(folder_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allocator: Allocator, diagnostics: *Diagnostics) !IniFolder {</span>
<span class="line" id="L536">    <span class="tok-kw">var</span> folder = IniFolder{</span>
<span class="line" id="L537">        .name = basename(folder_path),</span>
<span class="line" id="L538">        .files = ArrayList(IniFile).init(allocator),</span>
<span class="line" id="L539">        .folders = ArrayList(IniFolder).init(allocator),</span>
<span class="line" id="L540">    };</span>
<span class="line" id="L541"></span>
<span class="line" id="L542">    <span class="tok-kw">var</span> iterable_dir = <span class="tok-kw">try</span> std.fs.openIterableDirAbsolute(folder_path, .{});</span>
<span class="line" id="L543">    <span class="tok-kw">defer</span> iterable_dir.close();</span>
<span class="line" id="L544">    <span class="tok-kw">var</span> dir_iterator = iterable_dir.iterate();</span>
<span class="line" id="L545"></span>
<span class="line" id="L546">    <span class="tok-kw">while</span> (<span class="tok-kw">try</span> dir_iterator.next()) |entry| {</span>
<span class="line" id="L547">        <span class="tok-kw">if</span> (entry.kind == std.fs.File.Kind.file) {</span>
<span class="line" id="L548">            <span class="tok-kw">const</span> file_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ folder_path, entry.name });</span>
<span class="line" id="L549">            <span class="tok-kw">if</span> (strEql(extension(entry.name), <span class="tok-str">&quot;.ini&quot;</span>)) {</span>
<span class="line" id="L550">                diagnostics.file_path = file_path;</span>
<span class="line" id="L551">                <span class="tok-kw">const</span> text = <span class="tok-kw">try</span> readFile(file_path, allocator);</span>
<span class="line" id="L552"></span>
<span class="line" id="L553">                <span class="tok-kw">var</span> tokens = <span class="tok-kw">try</span> getTokens(text, allocator);</span>
<span class="line" id="L554"></span>
<span class="line" id="L555">                <span class="tok-comment">// TODO: Should I stop passing the address of tokens and ast everywhere?</span>
</span>
<span class="line" id="L556">                <span class="tok-kw">var</span> ast = <span class="tok-kw">try</span> getAstFromTokens(&amp;tokens, allocator, diagnostics);</span>
<span class="line" id="L557"></span>
<span class="line" id="L558">                <span class="tok-kw">var</span> file = IniFile{</span>
<span class="line" id="L559">                    .name = <span class="tok-kw">try</span> allocator.dupe(<span class="tok-type">u8</span>, entry.name),</span>
<span class="line" id="L560">                    .ast = ast,</span>
<span class="line" id="L561">                };</span>
<span class="line" id="L562">                <span class="tok-kw">try</span> folder.files.append(file);</span>
<span class="line" id="L563">            }</span>
<span class="line" id="L564">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (entry.kind == std.fs.File.Kind.directory) {</span>
<span class="line" id="L565">            <span class="tok-kw">var</span> child_folder = <span class="tok-kw">try</span> getIniFileTree(<span class="tok-kw">try</span> join(allocator, &amp;.{ folder_path, entry.name }), allocator, diagnostics);</span>
<span class="line" id="L566">            <span class="tok-kw">try</span> folder.folders.append(child_folder);</span>
<span class="line" id="L567">        }</span>
<span class="line" id="L568">    }</span>
<span class="line" id="L569"></span>
<span class="line" id="L570">    <span class="tok-kw">return</span> folder;</span>
<span class="line" id="L571">}</span>
<span class="line" id="L572"></span>
<span class="line" id="L573"><span class="tok-kw">fn</span> <span class="tok-fn">readFile</span>(input_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allocator: Allocator) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L574">    <span class="tok-kw">var</span> input_file = <span class="tok-kw">try</span> std.fs.cwd().openFile(input_path, .{});</span>
<span class="line" id="L575">    <span class="tok-kw">defer</span> input_file.close();</span>
<span class="line" id="L576"></span>
<span class="line" id="L577">    <span class="tok-kw">var</span> buf_reader = bufferedReader(input_file.reader());</span>
<span class="line" id="L578">    <span class="tok-kw">var</span> in_stream = buf_reader.reader();</span>
<span class="line" id="L579"></span>
<span class="line" id="L580">    <span class="tok-kw">const</span> text = <span class="tok-kw">try</span> in_stream.readAllAlloc(allocator, maxInt(<span class="tok-type">usize</span>));</span>
<span class="line" id="L581"></span>
<span class="line" id="L582">    <span class="tok-kw">const</span> lf_text = <span class="tok-kw">try</span> crlfToLf(text, allocator);</span>
<span class="line" id="L583"></span>
<span class="line" id="L584">    <span class="tok-kw">return</span> lf_text;</span>
<span class="line" id="L585">}</span>
<span class="line" id="L586"></span>
<span class="line" id="L587"><span class="tok-kw">fn</span> <span class="tok-fn">crlfToLf</span>(text: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allocator: Allocator) ![]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L588">    <span class="tok-kw">const</span> replacement_size = replacementSize(<span class="tok-type">u8</span>, text, <span class="tok-str">&quot;\r\n&quot;</span>, <span class="tok-str">&quot;\n&quot;</span>);</span>
<span class="line" id="L589">    <span class="tok-kw">var</span> lf_text = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, replacement_size);</span>
<span class="line" id="L590">    _ = replace(<span class="tok-type">u8</span>, text, <span class="tok-str">&quot;\r\n&quot;</span>, <span class="tok-str">&quot;\n&quot;</span>, lf_text);</span>
<span class="line" id="L591">    <span class="tok-kw">return</span> lf_text;</span>
<span class="line" id="L592">}</span>
<span class="line" id="L593"></span>
<span class="line" id="L594"><span class="tok-kw">fn</span> <span class="tok-fn">getTokens</span>(lf_text: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allocator: Allocator) !ArrayList(Token) {</span>
<span class="line" id="L595">    <span class="tok-kw">const</span> TokenError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L596">        UnclosedMultiComment,</span>
<span class="line" id="L597">    };</span>
<span class="line" id="L598"></span>
<span class="line" id="L599">    <span class="tok-kw">var</span> slice: []<span class="tok-kw">const</span> <span class="tok-type">u8</span> = lf_text;</span>
<span class="line" id="L600"></span>
<span class="line" id="L601">    <span class="tok-kw">var</span> tokens = ArrayList(Token).init(allocator);</span>
<span class="line" id="L602"></span>
<span class="line" id="L603">    <span class="tok-kw">var</span> multiline_comment_depth: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L604"></span>
<span class="line" id="L605">    <span class="tok-kw">var</span> seen_property = <span class="tok-null">false</span>;</span>
<span class="line" id="L606"></span>
<span class="line" id="L607">    <span class="tok-kw">while</span> (slice.len &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L608">        <span class="tok-kw">const</span> token = getToken(&amp;slice, &amp;multiline_comment_depth, &amp;seen_property);</span>
<span class="line" id="L609">        <span class="tok-kw">try</span> tokens.append(token);</span>
<span class="line" id="L610">    }</span>
<span class="line" id="L611"></span>
<span class="line" id="L612">    <span class="tok-kw">if</span> (multiline_comment_depth &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L613">        <span class="tok-kw">return</span> TokenError.UnclosedMultiComment;</span>
<span class="line" id="L614">    }</span>
<span class="line" id="L615"></span>
<span class="line" id="L616">    <span class="tok-kw">return</span> tokens;</span>
<span class="line" id="L617">}</span>
<span class="line" id="L618"></span>
<span class="line" id="L619"><span class="tok-kw">fn</span> <span class="tok-fn">getToken</span>(slice: *[]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, multiline_comment_depth: *<span class="tok-type">i32</span>, seen_property: *<span class="tok-type">bool</span>) Token {</span>
<span class="line" id="L620">    <span class="tok-kw">if</span> (slice.*[<span class="tok-number">0</span>] == <span class="tok-str">'\n'</span>) {</span>
<span class="line" id="L621">        seen_property.* = <span class="tok-null">false</span>;</span>
<span class="line" id="L622">        <span class="tok-kw">const</span> token = Token{ .<span class="tok-type">type</span> = .Newline, .slice = slice.*[<span class="tok-number">0</span>..<span class="tok-number">1</span>] };</span>
<span class="line" id="L623">        slice.* = slice.*[<span class="tok-number">1</span>..];</span>
<span class="line" id="L624">        <span class="tok-kw">return</span> token;</span>
<span class="line" id="L625">    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (multiline_comment_depth.* &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L626">        <span class="tok-kw">var</span> found_comment_marker = <span class="tok-null">false</span>;</span>
<span class="line" id="L627">        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L628">        <span class="tok-kw">while</span> (i &lt; slice.len) {</span>
<span class="line" id="L629">            <span class="tok-kw">if</span> (slice.*[i] == <span class="tok-str">'\n'</span>) {</span>
<span class="line" id="L630">                <span class="tok-kw">break</span>;</span>
<span class="line" id="L631">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (slice.*[i] == <span class="tok-str">'/'</span> <span class="tok-kw">and</span> slice.*[i + <span class="tok-number">1</span>] == <span class="tok-str">'*'</span>) {</span>
<span class="line" id="L632">                multiline_comment_depth.* += <span class="tok-number">1</span>;</span>
<span class="line" id="L633">                i += <span class="tok-number">2</span>;</span>
<span class="line" id="L634">                found_comment_marker = <span class="tok-null">true</span>;</span>
<span class="line" id="L635">                <span class="tok-kw">break</span>;</span>
<span class="line" id="L636">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (slice.*[i] == <span class="tok-str">'*'</span> <span class="tok-kw">and</span> slice.*[i + <span class="tok-number">1</span>] == <span class="tok-str">'/'</span>) {</span>
<span class="line" id="L637">                multiline_comment_depth.* -= <span class="tok-number">1</span>;</span>
<span class="line" id="L638">                i += <span class="tok-number">2</span>;</span>
<span class="line" id="L639">                found_comment_marker = <span class="tok-null">true</span>;</span>
<span class="line" id="L640">                <span class="tok-kw">break</span>;</span>
<span class="line" id="L641">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L642">                i += <span class="tok-number">1</span>;</span>
<span class="line" id="L643">            }</span>
<span class="line" id="L644">        }</span>
<span class="line" id="L645"></span>
<span class="line" id="L646">        <span class="tok-kw">const</span> comment_end_index = <span class="tok-kw">if</span> (found_comment_marker) i - <span class="tok-number">2</span> <span class="tok-kw">else</span> i;</span>
<span class="line" id="L647">        <span class="tok-kw">const</span> comment = trim(<span class="tok-type">u8</span>, slice.*[<span class="tok-number">0</span>..comment_end_index], <span class="tok-str">&quot; &quot;</span>);</span>
<span class="line" id="L648">        <span class="tok-kw">const</span> token = Token{ .<span class="tok-type">type</span> = .Comment, .slice = comment };</span>
<span class="line" id="L649">        slice.* = slice.*[i..];</span>
<span class="line" id="L650">        <span class="tok-kw">return</span> token;</span>
<span class="line" id="L651">    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (slice.*[<span class="tok-number">0</span>] == <span class="tok-str">'/'</span> <span class="tok-kw">and</span> slice.*[<span class="tok-number">1</span>] == <span class="tok-str">'/'</span>) {</span>
<span class="line" id="L652">        <span class="tok-kw">const</span> index = std.mem.indexOf(<span class="tok-type">u8</span>, slice.*[<span class="tok-number">2</span>..], <span class="tok-str">&quot;\n&quot;</span>);</span>
<span class="line" id="L653">        <span class="tok-kw">const</span> newline_index = <span class="tok-kw">if</span> (index) |i| i + <span class="tok-number">2</span> <span class="tok-kw">else</span> slice.len;</span>
<span class="line" id="L654">        <span class="tok-kw">const</span> token = Token{ .<span class="tok-type">type</span> = .Comment, .slice = trim(<span class="tok-type">u8</span>, slice.*[<span class="tok-number">2</span>..newline_index], <span class="tok-str">&quot; &quot;</span>) };</span>
<span class="line" id="L655">        slice.* = slice.*[newline_index..];</span>
<span class="line" id="L656">        <span class="tok-kw">return</span> token;</span>
<span class="line" id="L657">    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (slice.*[<span class="tok-number">0</span>] == <span class="tok-str">'/'</span> <span class="tok-kw">and</span> slice.*[<span class="tok-number">1</span>] == <span class="tok-str">'*'</span>) {</span>
<span class="line" id="L658">        multiline_comment_depth.* += <span class="tok-number">1</span>;</span>
<span class="line" id="L659"></span>
<span class="line" id="L660">        <span class="tok-kw">var</span> found_comment_marker = <span class="tok-null">false</span>;</span>
<span class="line" id="L661">        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">2</span>;</span>
<span class="line" id="L662">        <span class="tok-kw">while</span> (i &lt; slice.len) {</span>
<span class="line" id="L663">            <span class="tok-kw">if</span> (slice.*[i] == <span class="tok-str">'\n'</span>) {</span>
<span class="line" id="L664">                <span class="tok-kw">break</span>;</span>
<span class="line" id="L665">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (slice.*[i] == <span class="tok-str">'/'</span> <span class="tok-kw">and</span> slice.*[i + <span class="tok-number">1</span>] == <span class="tok-str">'*'</span>) {</span>
<span class="line" id="L666">                multiline_comment_depth.* += <span class="tok-number">1</span>;</span>
<span class="line" id="L667">                i += <span class="tok-number">2</span>;</span>
<span class="line" id="L668">                found_comment_marker = <span class="tok-null">true</span>;</span>
<span class="line" id="L669">                <span class="tok-kw">break</span>;</span>
<span class="line" id="L670">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (slice.*[i] == <span class="tok-str">'*'</span> <span class="tok-kw">and</span> slice.*[i + <span class="tok-number">1</span>] == <span class="tok-str">'/'</span>) {</span>
<span class="line" id="L671">                multiline_comment_depth.* -= <span class="tok-number">1</span>;</span>
<span class="line" id="L672">                i += <span class="tok-number">2</span>;</span>
<span class="line" id="L673">                found_comment_marker = <span class="tok-null">true</span>;</span>
<span class="line" id="L674">                <span class="tok-kw">break</span>;</span>
<span class="line" id="L675">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L676">                i += <span class="tok-number">1</span>;</span>
<span class="line" id="L677">            }</span>
<span class="line" id="L678">        }</span>
<span class="line" id="L679"></span>
<span class="line" id="L680">        <span class="tok-kw">const</span> comment_end_index = <span class="tok-kw">if</span> (found_comment_marker) i - <span class="tok-number">2</span> <span class="tok-kw">else</span> i;</span>
<span class="line" id="L681">        <span class="tok-kw">const</span> comment = trim(<span class="tok-type">u8</span>, slice.*[<span class="tok-number">2</span>..comment_end_index], <span class="tok-str">&quot; &quot;</span>);</span>
<span class="line" id="L682">        <span class="tok-kw">const</span> token = Token{ .<span class="tok-type">type</span> = .Comment, .slice = comment };</span>
<span class="line" id="L683">        slice.* = slice.*[i..];</span>
<span class="line" id="L684">        <span class="tok-kw">return</span> token;</span>
<span class="line" id="L685">    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (slice.*[<span class="tok-number">0</span>] == <span class="tok-str">'\t'</span>) {</span>
<span class="line" id="L686">        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;</span>
<span class="line" id="L687">        <span class="tok-kw">for</span> (slice.*[<span class="tok-number">1</span>..]) |character| {</span>
<span class="line" id="L688">            <span class="tok-kw">if</span> (character != <span class="tok-str">'\t'</span>) {</span>
<span class="line" id="L689">                <span class="tok-kw">break</span>;</span>
<span class="line" id="L690">            }</span>
<span class="line" id="L691">            i += <span class="tok-number">1</span>;</span>
<span class="line" id="L692">        }</span>
<span class="line" id="L693"></span>
<span class="line" id="L694">        <span class="tok-kw">const</span> token = Token{ .<span class="tok-type">type</span> = .Tabs, .slice = slice.*[<span class="tok-number">0</span>..i] };</span>
<span class="line" id="L695">        slice.* = slice.*[i..];</span>
<span class="line" id="L696">        <span class="tok-kw">return</span> token;</span>
<span class="line" id="L697">    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (slice.*[<span class="tok-number">0</span>] == <span class="tok-str">' '</span>) {</span>
<span class="line" id="L698">        <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;</span>
<span class="line" id="L699">        <span class="tok-kw">for</span> (slice.*[<span class="tok-number">1</span>..]) |character| {</span>
<span class="line" id="L700">            <span class="tok-kw">if</span> (character != <span class="tok-str">' '</span>) {</span>
<span class="line" id="L701">                <span class="tok-kw">break</span>;</span>
<span class="line" id="L702">            }</span>
<span class="line" id="L703">            i += <span class="tok-number">1</span>;</span>
<span class="line" id="L704">        }</span>
<span class="line" id="L705"></span>
<span class="line" id="L706">        <span class="tok-kw">const</span> token = Token{ .<span class="tok-type">type</span> = .Spaces, .slice = slice.*[<span class="tok-number">0</span>..i] };</span>
<span class="line" id="L707">        slice.* = slice.*[i..];</span>
<span class="line" id="L708">        <span class="tok-kw">return</span> token;</span>
<span class="line" id="L709">    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (slice.*[<span class="tok-number">0</span>] == <span class="tok-str">'='</span>) {</span>
<span class="line" id="L710">        <span class="tok-kw">const</span> token = Token{ .<span class="tok-type">type</span> = .Equals, .slice = slice.*[<span class="tok-number">0</span>..<span class="tok-number">1</span>] };</span>
<span class="line" id="L711">        <span class="tok-comment">// TODO: Check what happens if a line ends with an =, since I don't know if slice ends with '\0'</span>
</span>
<span class="line" id="L712">        <span class="tok-comment">// TODO: The same question goes for the comment parsing code that reads 2 characters</span>
</span>
<span class="line" id="L713">        slice.* = slice.*[<span class="tok-number">1</span>..];</span>
<span class="line" id="L714">        <span class="tok-kw">return</span> token;</span>
<span class="line" id="L715">    }</span>
<span class="line" id="L716"></span>
<span class="line" id="L717">    <span class="tok-comment">// A Sentence ends with a word, or the start of a comment</span>
</span>
<span class="line" id="L718">    <span class="tok-kw">var</span> end_index: <span class="tok-type">usize</span> = <span class="tok-number">1</span>;</span>
<span class="line" id="L719">    <span class="tok-kw">var</span> sentence_end_index: <span class="tok-type">usize</span> = end_index;</span>
<span class="line" id="L720">    <span class="tok-kw">while</span> (end_index &lt; slice.len) {</span>
<span class="line" id="L721">        <span class="tok-kw">if</span> (slice.*[end_index] == <span class="tok-str">'='</span> <span class="tok-kw">and</span> !seen_property.*) {</span>
<span class="line" id="L722">            <span class="tok-kw">break</span>;</span>
<span class="line" id="L723">        }</span>
<span class="line" id="L724">        <span class="tok-kw">if</span> (slice.*[end_index] == <span class="tok-str">'\n'</span> <span class="tok-kw">or</span> slice.*[end_index] == <span class="tok-str">'\t'</span> <span class="tok-kw">or</span> (slice.*[end_index] == <span class="tok-str">'/'</span> <span class="tok-kw">and</span> (slice.*[end_index + <span class="tok-number">1</span>] == <span class="tok-str">'*'</span> <span class="tok-kw">or</span> slice.*[end_index + <span class="tok-number">1</span>] == <span class="tok-str">'/'</span>))) {</span>
<span class="line" id="L725">            <span class="tok-kw">break</span>;</span>
<span class="line" id="L726">        }</span>
<span class="line" id="L727">        <span class="tok-kw">if</span> (slice.*[end_index] != <span class="tok-str">' '</span>) {</span>
<span class="line" id="L728">            sentence_end_index = end_index + <span class="tok-number">1</span>;</span>
<span class="line" id="L729">        }</span>
<span class="line" id="L730">        end_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L731">    }</span>
<span class="line" id="L732"></span>
<span class="line" id="L733">    seen_property.* = <span class="tok-null">true</span>;</span>
<span class="line" id="L734">    <span class="tok-kw">const</span> token = Token{ .<span class="tok-type">type</span> = .Sentence, .slice = slice.*[<span class="tok-number">0</span>..sentence_end_index] };</span>
<span class="line" id="L735">    slice.* = slice.*[sentence_end_index..];</span>
<span class="line" id="L736">    <span class="tok-kw">return</span> token;</span>
<span class="line" id="L737">}</span>
<span class="line" id="L738"></span>
<span class="line" id="L739"><span class="tok-kw">fn</span> <span class="tok-fn">getAstFromTokens</span>(tokens: *ArrayList(Token), allocator: Allocator, diagnostics: *Diagnostics) !ArrayList(Node) {</span>
<span class="line" id="L740">    <span class="tok-kw">var</span> ast = ArrayList(Node).init(allocator);</span>
<span class="line" id="L741"></span>
<span class="line" id="L742">    <span class="tok-comment">// The game ignores the indentation of the first line of a file,</span>
</span>
<span class="line" id="L743">    <span class="tok-comment">// but we choose to trim that indentation</span>
</span>
<span class="line" id="L744">    <span class="tok-kw">var</span> token_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L745">    <span class="tok-kw">if</span> (lineHasSentence(tokens, token_index)) {</span>
<span class="line" id="L746">        token_index = leftTrimFirstLine(tokens);</span>
<span class="line" id="L747">    }</span>
<span class="line" id="L748"></span>
<span class="line" id="L749">    <span class="tok-kw">while</span> (token_index &lt; tokens.items.len) {</span>
<span class="line" id="L750">        <span class="tok-kw">const</span> node = <span class="tok-kw">try</span> getNode(tokens, &amp;token_index, <span class="tok-number">0</span>, allocator, diagnostics);</span>
<span class="line" id="L751">        <span class="tok-kw">try</span> ast.append(node);</span>
<span class="line" id="L752">    }</span>
<span class="line" id="L753"></span>
<span class="line" id="L754">    <span class="tok-kw">return</span> ast;</span>
<span class="line" id="L755">}</span>
<span class="line" id="L756"></span>
<span class="line" id="L757"><span class="tok-kw">fn</span> <span class="tok-fn">lineHasSentence</span>(tokens: *ArrayList(Token), token_index_: <span class="tok-type">usize</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L758">    <span class="tok-kw">var</span> token_index = token_index_;</span>
<span class="line" id="L759"></span>
<span class="line" id="L760">    <span class="tok-kw">while</span> (token_index &lt; tokens.items.len) {</span>
<span class="line" id="L761">        <span class="tok-kw">const</span> token = tokens.items[token_index];</span>
<span class="line" id="L762"></span>
<span class="line" id="L763">        <span class="tok-kw">if</span> (token.<span class="tok-type">type</span> == .Newline) {</span>
<span class="line" id="L764">            <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L765">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (token.<span class="tok-type">type</span> == .Sentence) {</span>
<span class="line" id="L766">            <span class="tok-kw">return</span> <span class="tok-null">true</span>;</span>
<span class="line" id="L767">        }</span>
<span class="line" id="L768"></span>
<span class="line" id="L769">        token_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L770">    }</span>
<span class="line" id="L771"></span>
<span class="line" id="L772">    <span class="tok-kw">return</span> <span class="tok-null">false</span>;</span>
<span class="line" id="L773">}</span>
<span class="line" id="L774"></span>
<span class="line" id="L775"><span class="tok-kw">fn</span> <span class="tok-fn">leftTrimFirstLine</span>(tokens: *ArrayList(Token)) <span class="tok-type">usize</span> {</span>
<span class="line" id="L776">    <span class="tok-kw">var</span> token_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L777"></span>
<span class="line" id="L778">    <span class="tok-kw">while</span> (tokens.items[token_index].<span class="tok-type">type</span> != .Sentence) {</span>
<span class="line" id="L779">        token_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L780">    }</span>
<span class="line" id="L781"></span>
<span class="line" id="L782">    <span class="tok-kw">return</span> token_index;</span>
<span class="line" id="L783">}</span>
<span class="line" id="L784"></span>
<span class="line" id="L785"><span class="tok-kw">fn</span> <span class="tok-fn">getNode</span>(tokens: *ArrayList(Token), token_index: *<span class="tok-type">usize</span>, depth: <span class="tok-type">i32</span>, allocator: Allocator, diagnostics: *Diagnostics) <span class="tok-kw">error</span>{ TooManyTabs, UnexpectedToken, OutOfMemory }!Node {</span>
<span class="line" id="L786">    <span class="tok-kw">const</span> States = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L787">        Start,</span>
<span class="line" id="L788">        Property,</span>
<span class="line" id="L789">        Equals,</span>
<span class="line" id="L790">        Value,</span>
<span class="line" id="L791">        Newline,</span>
<span class="line" id="L792">    };</span>
<span class="line" id="L793"></span>
<span class="line" id="L794">    <span class="tok-kw">const</span> NodeError = <span class="tok-kw">error</span>{</span>
<span class="line" id="L795">        TooManyTabs,</span>
<span class="line" id="L796">        UnexpectedToken,</span>
<span class="line" id="L797">    };</span>
<span class="line" id="L798"></span>
<span class="line" id="L799">    <span class="tok-kw">var</span> seen: States = .Start;</span>
<span class="line" id="L800"></span>
<span class="line" id="L801">    <span class="tok-kw">var</span> node = Node{</span>
<span class="line" id="L802">        .comments = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(allocator),</span>
<span class="line" id="L803">        .children = ArrayList(Node).init(allocator),</span>
<span class="line" id="L804">    };</span>
<span class="line" id="L805"></span>
<span class="line" id="L806">    <span class="tok-kw">var</span> token = tokens.items[token_index.*];</span>
<span class="line" id="L807"></span>
<span class="line" id="L808">    <span class="tok-kw">var</span> line_depth = getLineDepth(tokens, token_index.*);</span>
<span class="line" id="L809">    <span class="tok-kw">if</span> (line_depth &gt; depth) {</span>
<span class="line" id="L810">        calculateLineAndColumnDiagnostics(tokens, token_index.*, diagnostics);</span>
<span class="line" id="L811">        <span class="tok-kw">return</span> NodeError.TooManyTabs;</span>
<span class="line" id="L812">    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (line_depth &lt; depth) {</span>
<span class="line" id="L813">        <span class="tok-kw">return</span> node;</span>
<span class="line" id="L814">    }</span>
<span class="line" id="L815"></span>
<span class="line" id="L816">    <span class="tok-kw">var</span> checked_line_depth = <span class="tok-null">true</span>;</span>
<span class="line" id="L817"></span>
<span class="line" id="L818">    <span class="tok-kw">while</span> (token_index.* &lt; tokens.items.len) {</span>
<span class="line" id="L819">        token = tokens.items[token_index.*];</span>
<span class="line" id="L820"></span>
<span class="line" id="L821">        <span class="tok-kw">if</span> (seen == .Start <span class="tok-kw">and</span> token.<span class="tok-type">type</span> == .Sentence) {</span>
<span class="line" id="L822">            <span class="tok-comment">// This if-statement is deliberately in a loop,</span>
</span>
<span class="line" id="L823">            <span class="tok-comment">// since whitespace and multiline comments may come before it</span>
</span>
<span class="line" id="L824">            node.property = token.slice;</span>
<span class="line" id="L825">            seen = .Property;</span>
<span class="line" id="L826">            token_index.* += <span class="tok-number">1</span>;</span>
<span class="line" id="L827">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (seen == .Newline <span class="tok-kw">and</span> !checked_line_depth) {</span>
<span class="line" id="L828">            checked_line_depth = <span class="tok-null">true</span>;</span>
<span class="line" id="L829"></span>
<span class="line" id="L830">            line_depth = getLineDepth(tokens, token_index.*);</span>
<span class="line" id="L831"></span>
<span class="line" id="L832">            <span class="tok-kw">if</span> (line_depth &gt; depth + <span class="tok-number">1</span>) {</span>
<span class="line" id="L833">                calculateLineAndColumnDiagnostics(tokens, token_index.*, diagnostics);</span>
<span class="line" id="L834">                <span class="tok-kw">return</span> NodeError.TooManyTabs;</span>
<span class="line" id="L835">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (line_depth == depth + <span class="tok-number">1</span>) {</span>
<span class="line" id="L836">                <span class="tok-kw">const</span> child_node = <span class="tok-kw">try</span> getNode(tokens, token_index, depth + <span class="tok-number">1</span>, allocator, diagnostics);</span>
<span class="line" id="L837">                <span class="tok-kw">try</span> node.children.append(child_node);</span>
<span class="line" id="L838">                checked_line_depth = <span class="tok-null">false</span>;</span>
<span class="line" id="L839">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L840">                <span class="tok-kw">return</span> node;</span>
<span class="line" id="L841">            }</span>
<span class="line" id="L842">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (seen == .Property <span class="tok-kw">and</span> token.<span class="tok-type">type</span> == .Equals) {</span>
<span class="line" id="L843">            seen = .Equals;</span>
<span class="line" id="L844">            token_index.* += <span class="tok-number">1</span>;</span>
<span class="line" id="L845">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (seen == .Equals <span class="tok-kw">and</span> token.<span class="tok-type">type</span> == .Sentence) {</span>
<span class="line" id="L846">            node.value = token.slice;</span>
<span class="line" id="L847">            seen = .Value;</span>
<span class="line" id="L848">            token_index.* += <span class="tok-number">1</span>;</span>
<span class="line" id="L849">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (token.<span class="tok-type">type</span> == .Comment) {</span>
<span class="line" id="L850">            <span class="tok-kw">if</span> (token.slice.len &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L851">                <span class="tok-kw">try</span> node.comments.append(token.slice);</span>
<span class="line" id="L852">            }</span>
<span class="line" id="L853">            token_index.* += <span class="tok-number">1</span>;</span>
<span class="line" id="L854">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (token.<span class="tok-type">type</span> == .Tabs <span class="tok-kw">or</span> token.<span class="tok-type">type</span> == .Spaces) {</span>
<span class="line" id="L855">            token_index.* += <span class="tok-number">1</span>;</span>
<span class="line" id="L856">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (token.<span class="tok-type">type</span> == .Newline) {</span>
<span class="line" id="L857">            seen = .Newline;</span>
<span class="line" id="L858">            token_index.* += <span class="tok-number">1</span>;</span>
<span class="line" id="L859">            checked_line_depth = <span class="tok-null">false</span>;</span>
<span class="line" id="L860">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L861">            diagnostics.token = token.slice;</span>
<span class="line" id="L862">            calculateLineAndColumnDiagnostics(tokens, token_index.*, diagnostics);</span>
<span class="line" id="L863">            <span class="tok-kw">return</span> NodeError.UnexpectedToken;</span>
<span class="line" id="L864">        }</span>
<span class="line" id="L865">    }</span>
<span class="line" id="L866"></span>
<span class="line" id="L867">    <span class="tok-kw">return</span> node;</span>
<span class="line" id="L868">}</span>
<span class="line" id="L869"></span>
<span class="line" id="L870"><span class="tok-kw">fn</span> <span class="tok-fn">getLineDepth</span>(tokens: *ArrayList(Token), token_index_: <span class="tok-type">usize</span>) <span class="tok-type">i32</span> {</span>
<span class="line" id="L871">    <span class="tok-kw">var</span> token_index = token_index_;</span>
<span class="line" id="L872"></span>
<span class="line" id="L873">    <span class="tok-kw">var</span> token = tokens.items[token_index];</span>
<span class="line" id="L874"></span>
<span class="line" id="L875">    <span class="tok-kw">if</span> (token.<span class="tok-type">type</span> == .Sentence) {</span>
<span class="line" id="L876">        <span class="tok-kw">return</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L877">    } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (!lineHasSentence(tokens, token_index)) {</span>
<span class="line" id="L878">        <span class="tok-kw">return</span> getNextSentenceDepth(tokens, token_index);</span>
<span class="line" id="L879">    }</span>
<span class="line" id="L880"></span>
<span class="line" id="L881">    <span class="tok-kw">var</span> tabs_seen: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L882"></span>
<span class="line" id="L883">    <span class="tok-kw">while</span> (token_index &lt; tokens.items.len) {</span>
<span class="line" id="L884">        token = tokens.items[token_index];</span>
<span class="line" id="L885"></span>
<span class="line" id="L886">        <span class="tok-kw">if</span> (token.<span class="tok-type">type</span> == .Sentence) {</span>
<span class="line" id="L887">            <span class="tok-kw">return</span> tabs_seen;</span>
<span class="line" id="L888">        }</span>
<span class="line" id="L889"></span>
<span class="line" id="L890">        <span class="tok-kw">if</span> (token.<span class="tok-type">type</span> == .Tabs) {</span>
<span class="line" id="L891">            tabs_seen += <span class="tok-builtin">@intCast</span>(token.slice.len);</span>
<span class="line" id="L892">        }</span>
<span class="line" id="L893"></span>
<span class="line" id="L894">        token_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L895">    }</span>
<span class="line" id="L896"></span>
<span class="line" id="L897">    <span class="tok-comment">// If the end of the file is reached</span>
</span>
<span class="line" id="L898">    <span class="tok-comment">// TODO: Find a way to return the same depth as the previous Sentence line</span>
</span>
<span class="line" id="L899">    <span class="tok-comment">// It isn't as easy as &quot;return depth&quot;, since it can also be &quot;return depth + 1&quot;</span>
</span>
<span class="line" id="L900">    <span class="tok-kw">return</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L901">}</span>
<span class="line" id="L902"></span>
<span class="line" id="L903"><span class="tok-kw">fn</span> <span class="tok-fn">getNextSentenceDepth</span>(tokens: *ArrayList(Token), token_index_: <span class="tok-type">usize</span>) <span class="tok-type">i32</span> {</span>
<span class="line" id="L904">    <span class="tok-kw">var</span> token_index = token_index_;</span>
<span class="line" id="L905"></span>
<span class="line" id="L906">    <span class="tok-kw">var</span> tabs_seen: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L907"></span>
<span class="line" id="L908">    <span class="tok-kw">while</span> (token_index &lt; tokens.items.len) {</span>
<span class="line" id="L909">        <span class="tok-kw">const</span> token = tokens.items[token_index];</span>
<span class="line" id="L910"></span>
<span class="line" id="L911">        <span class="tok-kw">if</span> (token.<span class="tok-type">type</span> == .Newline) {</span>
<span class="line" id="L912">            tabs_seen = <span class="tok-number">0</span>;</span>
<span class="line" id="L913">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (token.<span class="tok-type">type</span> == .Sentence) {</span>
<span class="line" id="L914">            <span class="tok-kw">return</span> tabs_seen;</span>
<span class="line" id="L915">        }</span>
<span class="line" id="L916"></span>
<span class="line" id="L917">        <span class="tok-kw">if</span> (token.<span class="tok-type">type</span> == .Tabs) {</span>
<span class="line" id="L918">            tabs_seen += <span class="tok-builtin">@intCast</span>(token.slice.len);</span>
<span class="line" id="L919">        }</span>
<span class="line" id="L920"></span>
<span class="line" id="L921">        token_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L922">    }</span>
<span class="line" id="L923"></span>
<span class="line" id="L924">    <span class="tok-comment">// If the end of the file is reached</span>
</span>
<span class="line" id="L925">    <span class="tok-comment">// TODO: Find a way to return the same depth as the previous Sentence line</span>
</span>
<span class="line" id="L926">    <span class="tok-comment">// It isn't as easy as &quot;return depth&quot;, since it can also be &quot;return depth + 1&quot;</span>
</span>
<span class="line" id="L927">    <span class="tok-kw">return</span> <span class="tok-number">0</span>;</span>
<span class="line" id="L928">}</span>
<span class="line" id="L929"></span>
<span class="line" id="L930"><span class="tok-kw">fn</span> <span class="tok-fn">calculateLineAndColumnDiagnostics</span>(tokens: *ArrayList(Token), token_index: <span class="tok-type">usize</span>, diagnostics: *Diagnostics) <span class="tok-type">void</span> {</span>
<span class="line" id="L931">    diagnostics.line = <span class="tok-number">1</span>;</span>
<span class="line" id="L932">    diagnostics.column = <span class="tok-number">1</span>;</span>
<span class="line" id="L933"></span>
<span class="line" id="L934">    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L935">    <span class="tok-kw">while</span> (i &lt; token_index) {</span>
<span class="line" id="L936">        <span class="tok-kw">var</span> token = tokens.items[i];</span>
<span class="line" id="L937"></span>
<span class="line" id="L938">        <span class="tok-kw">if</span> (token.<span class="tok-type">type</span> == .Newline) {</span>
<span class="line" id="L939">            diagnostics.line.? += <span class="tok-number">1</span>;</span>
<span class="line" id="L940">            diagnostics.column.? = <span class="tok-number">1</span>;</span>
<span class="line" id="L941">        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L942">            diagnostics.column.? += <span class="tok-builtin">@intCast</span>(token.slice.len);</span>
<span class="line" id="L943">        }</span>
<span class="line" id="L944"></span>
<span class="line" id="L945">        i += <span class="tok-number">1</span>;</span>
<span class="line" id="L946">    }</span>
<span class="line" id="L947">}</span>
<span class="line" id="L948"></span>
<span class="line" id="L949"><span class="tok-comment">// Uninitialized is used to detect SupportedGameVersion being seen a second time</span>
</span>
<span class="line" id="L950"><span class="tok-kw">const</span> ModVersion = <span class="tok-kw">enum</span> {</span>
<span class="line" id="L951">    Uninitialized,</span>
<span class="line" id="L952">    BeforePre6,</span>
<span class="line" id="L953">    Pre6,</span>
<span class="line" id="L954">};</span>
<span class="line" id="L955"></span>
<span class="line" id="L956"><span class="tok-kw">fn</span> <span class="tok-fn">getModVersion</span>(file_tree: *IniFolder) !ModVersion {</span>
<span class="line" id="L957">    <span class="tok-kw">var</span> mod_version = ModVersion.Uninitialized;</span>
<span class="line" id="L958"></span>
<span class="line" id="L959">    <span class="tok-kw">for</span> (file_tree.files.items) |file| {</span>
<span class="line" id="L960">        <span class="tok-kw">if</span> (strEql(file.name, <span class="tok-str">&quot;Index.ini&quot;</span>)) {</span>
<span class="line" id="L961">            <span class="tok-kw">var</span> data_module_count: <span class="tok-type">i32</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L962"></span>
<span class="line" id="L963">            <span class="tok-kw">for</span> (file.ast.items) |*node| {</span>
<span class="line" id="L964">                <span class="tok-kw">try</span> getModVersionRecursivelyNode(node, &amp;mod_version, &amp;data_module_count);</span>
<span class="line" id="L965">            }</span>
<span class="line" id="L966"></span>
<span class="line" id="L967">            <span class="tok-kw">if</span> (data_module_count == <span class="tok-number">0</span>) {</span>
<span class="line" id="L968">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ExpectedADataModule;</span>
<span class="line" id="L969">            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (data_module_count &gt; <span class="tok-number">1</span>) {</span>
<span class="line" id="L970">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.ContainsMoreThanOneDataModule;</span>
<span class="line" id="L971">            }</span>
<span class="line" id="L972"></span>
<span class="line" id="L973">            <span class="tok-kw">break</span>;</span>
<span class="line" id="L974">        }</span>
<span class="line" id="L975">    }</span>
<span class="line" id="L976"></span>
<span class="line" id="L977">    <span class="tok-comment">// Apply all updates to the mod if it has no Index.ini,</span>
</span>
<span class="line" id="L978">    <span class="tok-comment">// as we want tests without an Index.ini to pass,</span>
</span>
<span class="line" id="L979">    <span class="tok-comment">// as well as CC Steam Workshop mods that have no SupportedGameVersion</span>
</span>
<span class="line" id="L980">    <span class="tok-kw">if</span> (mod_version == ModVersion.Uninitialized) {</span>
<span class="line" id="L981">        mod_version = ModVersion.BeforePre6;</span>
<span class="line" id="L982">    }</span>
<span class="line" id="L983"></span>
<span class="line" id="L984">    <span class="tok-kw">return</span> mod_version;</span>
<span class="line" id="L985">}</span>
<span class="line" id="L986"></span>
<span class="line" id="L987"><span class="tok-kw">fn</span> <span class="tok-fn">getModVersionRecursivelyNode</span>(node: *Node, mod_version: *ModVersion, data_module_count: *<span class="tok-type">i32</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L988">    <span class="tok-kw">const</span> ModVersionErrors = <span class="tok-kw">error</span>{</span>
<span class="line" id="L989">        AlreadySeenASupportedGameVersion,</span>
<span class="line" id="L990">        UnrecognizedSupportedGameVersion,</span>
<span class="line" id="L991">    };</span>
<span class="line" id="L992"></span>
<span class="line" id="L993">    <span class="tok-kw">if</span> (node.property) |node_property| {</span>
<span class="line" id="L994">        <span class="tok-kw">if</span> (strEql(node_property, <span class="tok-str">&quot;SupportedGameVersion&quot;</span>)) {</span>
<span class="line" id="L995">            <span class="tok-kw">if</span> (node.value) |value| {</span>
<span class="line" id="L996">                <span class="tok-kw">if</span> (mod_version.* != ModVersion.Uninitialized) {</span>
<span class="line" id="L997">                    <span class="tok-kw">return</span> ModVersionErrors.AlreadySeenASupportedGameVersion;</span>
<span class="line" id="L998">                }</span>
<span class="line" id="L999">                <span class="tok-kw">if</span> (strEql(value, <span class="tok-str">&quot;6.0.0&quot;</span>)) {</span>
<span class="line" id="L1000">                    mod_version.* = ModVersion.Pre6;</span>
<span class="line" id="L1001">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (strEql(value, <span class="tok-str">&quot;Pre-Release 3.0&quot;</span>) <span class="tok-kw">or</span> strEql(value, <span class="tok-str">&quot;Pre-Release 4.0&quot;</span>) <span class="tok-kw">or</span> strEql(value, <span class="tok-str">&quot;Pre-Release 5.0&quot;</span>) <span class="tok-kw">or</span> strEql(value, <span class="tok-str">&quot;Pre-Release 5.1&quot;</span>) <span class="tok-kw">or</span> strEql(value, <span class="tok-str">&quot;Pre-Release 5.2&quot;</span>) <span class="tok-kw">or</span> strEql(value, <span class="tok-str">&quot;5.1.0&quot;</span>)) {</span>
<span class="line" id="L1002">                    mod_version.* = ModVersion.BeforePre6;</span>
<span class="line" id="L1003">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1004">                    <span class="tok-kw">return</span> ModVersionErrors.UnrecognizedSupportedGameVersion;</span>
<span class="line" id="L1005">                }</span>
<span class="line" id="L1006">            }</span>
<span class="line" id="L1007">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (strEql(node_property, <span class="tok-str">&quot;DataModule&quot;</span>)) {</span>
<span class="line" id="L1008">            data_module_count.* += <span class="tok-number">1</span>;</span>
<span class="line" id="L1009">        }</span>
<span class="line" id="L1010">    }</span>
<span class="line" id="L1011"></span>
<span class="line" id="L1012">    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L1013">        <span class="tok-kw">try</span> getModVersionRecursivelyNode(child, mod_version, data_module_count);</span>
<span class="line" id="L1014">    }</span>
<span class="line" id="L1015">}</span>
<span class="line" id="L1016"></span>
<span class="line" id="L1017"><span class="tok-kw">fn</span> <span class="tok-fn">replaceMagentaInRgbPngsWithAlpha</span>(output_folder_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1018">    <span class="tok-kw">var</span> iterable_dir = <span class="tok-kw">try</span> std.fs.openIterableDirAbsolute(output_folder_path, .{});</span>
<span class="line" id="L1019">    <span class="tok-kw">defer</span> iterable_dir.close();</span>
<span class="line" id="L1020">    <span class="tok-kw">var</span> dir_iterator = iterable_dir.iterate();</span>
<span class="line" id="L1021"></span>
<span class="line" id="L1022">    <span class="tok-kw">while</span> (<span class="tok-kw">try</span> dir_iterator.next()) |entry| {</span>
<span class="line" id="L1023">        <span class="tok-kw">if</span> (entry.kind == std.fs.File.Kind.file <span class="tok-kw">and</span> strEql(extension(entry.name), <span class="tok-str">&quot;.png&quot;</span>)) {</span>
<span class="line" id="L1024">            <span class="tok-kw">const</span> output_file_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ output_folder_path, entry.name });</span>
<span class="line" id="L1025"></span>
<span class="line" id="L1026">            <span class="tok-kw">if</span> (<span class="tok-kw">try</span> pngIsRgb(output_file_path)) {</span>
<span class="line" id="L1027">                <span class="tok-kw">var</span> tmpdir_output_folder = tmpDir(.{});</span>
<span class="line" id="L1028">                <span class="tok-kw">defer</span> tmpdir_output_folder.cleanup();</span>
<span class="line" id="L1029"></span>
<span class="line" id="L1030">                <span class="tok-kw">var</span> tmpdir_output_folder_path_buffer: [MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L1031">                <span class="tok-kw">const</span> tmpdir_output_folder_path = <span class="tok-kw">try</span> tmpdir_output_folder.dir.realpath(<span class="tok-str">&quot;.&quot;</span>, &amp;tmpdir_output_folder_path_buffer);</span>
<span class="line" id="L1032"></span>
<span class="line" id="L1033">                <span class="tok-comment">// This file will have (255, 0, 255) replaced with (255, 0, 255, 0)</span>
</span>
<span class="line" id="L1034">                <span class="tok-kw">const</span> tmp_alpha_file_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ tmpdir_output_folder_path, <span class="tok-str">&quot;alpha.png&quot;</span> });</span>
<span class="line" id="L1035"></span>
<span class="line" id="L1036">                <span class="tok-comment">// Note that &quot;colorkey&quot; its &quot;similarity&quot; value has a default, and minimum, of 0.01,</span>
</span>
<span class="line" id="L1037">                <span class="tok-comment">// which means that colors that are very close to (255, 0, 255) also turn transparent.</span>
</span>
<span class="line" id="L1038">                <span class="tok-comment">// This is fine however, since I checked that the CC palette doesn't contain other colors</span>
</span>
<span class="line" id="L1039">                <span class="tok-comment">// that are close enough to magenta to be turned transparent.</span>
</span>
<span class="line" id="L1040">                <span class="tok-kw">const</span> argv_alpha = [_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ getFfmpegPath(), <span class="tok-str">&quot;-i&quot;</span>, output_file_path, <span class="tok-str">&quot;-vf&quot;</span>, <span class="tok-str">&quot;colorkey=magenta&quot;</span>, <span class="tok-str">&quot;-y&quot;</span>, tmp_alpha_file_path };</span>
<span class="line" id="L1041">                <span class="tok-kw">const</span> result_alpha = <span class="tok-kw">try</span> std.ChildProcess.exec(.{ .argv = &amp;argv_alpha, .allocator = allocator });</span>
<span class="line" id="L1042">                _ = result_alpha;</span>
<span class="line" id="L1043"></span>
<span class="line" id="L1044">                <span class="tok-comment">// This file will have (r=255, g=0, b=255, a=0) replaced with (r=0, g=0, b=0, a=0), as CC requires all RGB to be 0 when alpha is 0</span>
</span>
<span class="line" id="L1045">                <span class="tok-kw">const</span> tmp_zero_file_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ tmpdir_output_folder_path, <span class="tok-str">&quot;zero.png&quot;</span> });</span>
<span class="line" id="L1046"></span>
<span class="line" id="L1047">                <span class="tok-comment">// This insanity is just asking ffmpeg to replace any (r=255, g=0, b=255, a=0) with (r=0, g=0, b=0, a=0)</span>
</span>
<span class="line" id="L1048">                <span class="tok-kw">const</span> argv_zero = [_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ getFfmpegPath(), <span class="tok-str">&quot;-i&quot;</span>, tmp_alpha_file_path, <span class="tok-str">&quot;-vf&quot;</span>, <span class="tok-str">&quot;geq=r='if(eq(r(X,Y),255)*eq(g(X,Y),0)*eq(b(X,Y),255),0,r(X,Y))':g='if(eq(r(X,Y),255)*eq(g(X,Y),0)*eq(b(X,Y),255),0,g(X,Y))':b='if(eq(r(X,Y),255)*eq(g(X,Y),0)*eq(b(X,Y),255),0,b(X,Y))':a='alpha(X,Y)'&quot;</span>, <span class="tok-str">&quot;-y&quot;</span>, tmp_zero_file_path };</span>
<span class="line" id="L1049">                <span class="tok-kw">const</span> result_zero = <span class="tok-kw">try</span> std.ChildProcess.exec(.{ .argv = &amp;argv_zero, .allocator = allocator });</span>
<span class="line" id="L1050">                _ = result_zero;</span>
<span class="line" id="L1051"></span>
<span class="line" id="L1052">                <span class="tok-comment">// Overwrite the old png with the new one that has transparency</span>
</span>
<span class="line" id="L1053">                <span class="tok-kw">try</span> copyFileAbsolute(tmp_zero_file_path, output_file_path, .{});</span>
<span class="line" id="L1054">            }</span>
<span class="line" id="L1055">        } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (entry.kind == std.fs.File.Kind.directory) {</span>
<span class="line" id="L1056">            <span class="tok-kw">const</span> child_output_folder_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ output_folder_path, entry.name });</span>
<span class="line" id="L1057">            <span class="tok-kw">try</span> replaceMagentaInRgbPngsWithAlpha(child_output_folder_path, allocator);</span>
<span class="line" id="L1058">        }</span>
<span class="line" id="L1059">    }</span>
<span class="line" id="L1060">}</span>
<span class="line" id="L1061"></span>
<span class="line" id="L1062"><span class="tok-comment">// RGB, as opposed to indexed with a palette</span>
</span>
<span class="line" id="L1063"><span class="tok-kw">fn</span> <span class="tok-fn">pngIsRgb</span>(output_file_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">bool</span> {</span>
<span class="line" id="L1064">    <span class="tok-kw">const</span> file = <span class="tok-kw">try</span> std.fs.cwd().openFile(output_file_path, .{});</span>
<span class="line" id="L1065">    <span class="tok-kw">defer</span> file.close();</span>
<span class="line" id="L1066"></span>
<span class="line" id="L1067">    <span class="tok-kw">const</span> color_type_offset = <span class="tok-number">0x19</span>;</span>
<span class="line" id="L1068">    <span class="tok-kw">try</span> file.seekTo(color_type_offset);</span>
<span class="line" id="L1069"></span>
<span class="line" id="L1070">    <span class="tok-kw">const</span> color_type = <span class="tok-kw">try</span> file.reader().readByte();</span>
<span class="line" id="L1071"></span>
<span class="line" id="L1072">    <span class="tok-comment">// Note that 2 means rgb, so we deliberately don't care about rgba,</span>
</span>
<span class="line" id="L1073">    <span class="tok-comment">// since that'd be 6:</span>
</span>
<span class="line" id="L1074">    <span class="tok-comment">// https://en.wikipedia.org/wiki/PNG#Pixel_format</span>
</span>
<span class="line" id="L1075">    <span class="tok-kw">return</span> color_type == <span class="tok-number">2</span>;</span>
<span class="line" id="L1076">}</span>
<span class="line" id="L1077"></span>
<span class="line" id="L1078"><span class="tok-kw">const</span> nodeCallbackDef = <span class="tok-kw">fn</span> (node: *Node) <span class="tok-kw">error</span>{ ExpectedValue, InvalidCharacter, OutOfMemory }!<span class="tok-type">void</span>;</span>
<span class="line" id="L1079"></span>
<span class="line" id="L1080"><span class="tok-kw">fn</span> <span class="tok-fn">applyOnNodes</span>(<span class="tok-kw">comptime</span> nodeCallbackFn: nodeCallbackDef, file_tree: *IniFolder) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1081">    <span class="tok-kw">for</span> (file_tree.folders.items) |*folder| {</span>
<span class="line" id="L1082">        <span class="tok-kw">try</span> applyOnNodes(nodeCallbackFn, folder);</span>
<span class="line" id="L1083">    }</span>
<span class="line" id="L1084"></span>
<span class="line" id="L1085">    <span class="tok-kw">for</span> (file_tree.files.items) |file| {</span>
<span class="line" id="L1086">        <span class="tok-kw">for</span> (file.ast.items) |*node| {</span>
<span class="line" id="L1087">            <span class="tok-kw">try</span> applyOnNode(nodeCallbackFn, node);</span>
<span class="line" id="L1088">        }</span>
<span class="line" id="L1089">    }</span>
<span class="line" id="L1090">}</span>
<span class="line" id="L1091"></span>
<span class="line" id="L1092"><span class="tok-kw">fn</span> <span class="tok-fn">applyOnNode</span>(<span class="tok-kw">comptime</span> nodeCallbackFn: nodeCallbackDef, node: *Node) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1093">    <span class="tok-kw">try</span> nodeCallbackFn(node);</span>
<span class="line" id="L1094"></span>
<span class="line" id="L1095">    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L1096">        <span class="tok-kw">try</span> applyOnNode(nodeCallbackFn, child);</span>
<span class="line" id="L1097">    }</span>
<span class="line" id="L1098">}</span>
<span class="line" id="L1099"></span>
<span class="line" id="L1100"><span class="tok-kw">const</span> nodeAllocCallbackDef = <span class="tok-kw">fn</span> (node: *Node, allocator: Allocator) <span class="tok-kw">error</span>{ ExpectedValue, InvalidCharacter, OutOfMemory }!<span class="tok-type">void</span>;</span>
<span class="line" id="L1101"></span>
<span class="line" id="L1102"><span class="tok-kw">fn</span> <span class="tok-fn">applyOnNodesAlloc</span>(<span class="tok-kw">comptime</span> nodeAllocCallbackFn: nodeAllocCallbackDef, file_tree: *IniFolder, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1103">    <span class="tok-kw">for</span> (file_tree.folders.items) |*folder| {</span>
<span class="line" id="L1104">        <span class="tok-kw">try</span> applyOnNodesAlloc(nodeAllocCallbackFn, folder, allocator);</span>
<span class="line" id="L1105">    }</span>
<span class="line" id="L1106"></span>
<span class="line" id="L1107">    <span class="tok-kw">for</span> (file_tree.files.items) |file| {</span>
<span class="line" id="L1108">        <span class="tok-kw">for</span> (file.ast.items) |*node| {</span>
<span class="line" id="L1109">            <span class="tok-kw">try</span> applyOnNodeAlloc(nodeAllocCallbackFn, node, allocator);</span>
<span class="line" id="L1110">        }</span>
<span class="line" id="L1111">    }</span>
<span class="line" id="L1112">}</span>
<span class="line" id="L1113"></span>
<span class="line" id="L1114"><span class="tok-kw">fn</span> <span class="tok-fn">applyOnNodeAlloc</span>(<span class="tok-kw">comptime</span> nodeAllocCallbackFn: nodeAllocCallbackDef, node: *Node, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1115">    <span class="tok-kw">try</span> nodeAllocCallbackFn(node, allocator);</span>
<span class="line" id="L1116"></span>
<span class="line" id="L1117">    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L1118">        <span class="tok-kw">try</span> applyOnNodeAlloc(nodeAllocCallbackFn, child, allocator);</span>
<span class="line" id="L1119">    }</span>
<span class="line" id="L1120">}</span>
<span class="line" id="L1121"></span>
<span class="line" id="L1122"><span class="tok-kw">fn</span> <span class="tok-fn">pathToFilePath</span>(node: *Node) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1123">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L1124">        <span class="tok-kw">if</span> (strEql(property, <span class="tok-str">&quot;Path&quot;</span>)) {</span>
<span class="line" id="L1125">            node.property = <span class="tok-str">&quot;FilePath&quot;</span>;</span>
<span class="line" id="L1126">        }</span>
<span class="line" id="L1127">    }</span>
<span class="line" id="L1128">}</span>
<span class="line" id="L1129"></span>
<span class="line" id="L1130"><span class="tok-kw">fn</span> <span class="tok-fn">bmpExtensionToPng</span>(node: *Node, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1131">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L1132">        <span class="tok-kw">if</span> (strEql(property, <span class="tok-str">&quot;FilePath&quot;</span>)) {</span>
<span class="line" id="L1133">            <span class="tok-kw">if</span> (node.value) |path| {</span>
<span class="line" id="L1134">                <span class="tok-kw">if</span> (endsWith(<span class="tok-type">u8</span>, path, <span class="tok-str">&quot;.bmp&quot;</span>) <span class="tok-kw">and</span> !strEql(path, <span class="tok-str">&quot;palette.bmp&quot;</span>) <span class="tok-kw">and</span> !strEql(path, <span class="tok-str">&quot;palettemat.bmp&quot;</span>)) {</span>
<span class="line" id="L1135">                    <span class="tok-comment">// We have to dupe, since the u8s in path are const</span>
</span>
<span class="line" id="L1136">                    <span class="tok-kw">var</span> new_path = <span class="tok-kw">try</span> allocator.dupe(<span class="tok-type">u8</span>, path);</span>
<span class="line" id="L1137"></span>
<span class="line" id="L1138">                    new_path[new_path.len - <span class="tok-number">1</span>] = <span class="tok-str">'g'</span>;</span>
<span class="line" id="L1139">                    new_path[new_path.len - <span class="tok-number">2</span>] = <span class="tok-str">'n'</span>;</span>
<span class="line" id="L1140">                    new_path[new_path.len - <span class="tok-number">3</span>] = <span class="tok-str">'p'</span>;</span>
<span class="line" id="L1141"></span>
<span class="line" id="L1142">                    node.value = new_path;</span>
<span class="line" id="L1143">                }</span>
<span class="line" id="L1144">            }</span>
<span class="line" id="L1145">        }</span>
<span class="line" id="L1146">    }</span>
<span class="line" id="L1147">}</span>
<span class="line" id="L1148"></span>
<span class="line" id="L1149"><span class="tok-kw">fn</span> <span class="tok-fn">wavExtensionToFlac</span>(node: *Node, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1150">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L1151">        <span class="tok-kw">if</span> (strEql(property, <span class="tok-str">&quot;FilePath&quot;</span>) <span class="tok-kw">or</span> strEql(property, <span class="tok-str">&quot;AddSound&quot;</span>)) {</span>
<span class="line" id="L1152">            <span class="tok-kw">if</span> (node.value) |path| {</span>
<span class="line" id="L1153">                <span class="tok-kw">if</span> (endsWith(<span class="tok-type">u8</span>, path, <span class="tok-str">&quot;.wav&quot;</span>)) {</span>
<span class="line" id="L1154">                    <span class="tok-comment">// Create a copy of the entry name that is one character longer, so the &quot;c&quot; in .flac fits</span>
</span>
<span class="line" id="L1155">                    <span class="tok-kw">var</span> new_path = <span class="tok-kw">try</span> allocator.alloc(<span class="tok-type">u8</span>, path.len + <span class="tok-number">1</span>);</span>
<span class="line" id="L1156">                    <span class="tok-builtin">@memcpy</span>(new_path[<span class="tok-number">0</span>..path.len], path);</span>
<span class="line" id="L1157"></span>
<span class="line" id="L1158">                    new_path[new_path.len - <span class="tok-number">1</span>] = <span class="tok-str">'c'</span>;</span>
<span class="line" id="L1159">                    new_path[new_path.len - <span class="tok-number">2</span>] = <span class="tok-str">'a'</span>;</span>
<span class="line" id="L1160">                    new_path[new_path.len - <span class="tok-number">3</span>] = <span class="tok-str">'l'</span>;</span>
<span class="line" id="L1161">                    new_path[new_path.len - <span class="tok-number">4</span>] = <span class="tok-str">'f'</span>;</span>
<span class="line" id="L1162"></span>
<span class="line" id="L1163">                    node.value = new_path;</span>
<span class="line" id="L1164">                }</span>
<span class="line" id="L1165">            }</span>
<span class="line" id="L1166">        }</span>
<span class="line" id="L1167">    }</span>
<span class="line" id="L1168">}</span>
<span class="line" id="L1169"></span>
<span class="line" id="L1170"><span class="tok-kw">fn</span> <span class="tok-fn">parseIniCopyOfRules</span>(allocator: Allocator) !std.json.ArrayHashMap([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) {</span>
<span class="line" id="L1171">    <span class="tok-kw">const</span> text = <span class="tok-kw">try</span> readFile(<span class="tok-str">&quot;rules/ini_copy_of_rules.json&quot;</span>, allocator);</span>
<span class="line" id="L1172"></span>
<span class="line" id="L1173">    <span class="tok-kw">var</span> scanner = Scanner.initCompleteInput(allocator, text);</span>
<span class="line" id="L1174"></span>
<span class="line" id="L1175">    <span class="tok-kw">var</span> rules = <span class="tok-kw">try</span> std.json.ArrayHashMap([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).jsonParse(allocator, &amp;scanner, .{ .allocate = .alloc_if_needed, .max_value_len = default_max_value_len });</span>
<span class="line" id="L1176">    <span class="tok-kw">return</span> rules;</span>
<span class="line" id="L1177">}</span>
<span class="line" id="L1178"></span>
<span class="line" id="L1179"><span class="tok-kw">fn</span> <span class="tok-fn">applyIniCopyOfRules</span>(rules: std.json.ArrayHashMap([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>), file_tree: *IniFolder) <span class="tok-type">void</span> {</span>
<span class="line" id="L1180">    <span class="tok-kw">var</span> map_iterator = rules.map.iterator();</span>
<span class="line" id="L1181">    <span class="tok-kw">while</span> (map_iterator.next()) |map_entry| {</span>
<span class="line" id="L1182">        <span class="tok-kw">const</span> old_value = map_entry.key_ptr.*;</span>
<span class="line" id="L1183">        <span class="tok-kw">const</span> new_value = map_entry.value_ptr.*;</span>
<span class="line" id="L1184"></span>
<span class="line" id="L1185">        applyIniValueReplacementRulesRecursivelyFolder(file_tree, <span class="tok-str">&quot;CopyOf&quot;</span>, old_value, new_value);</span>
<span class="line" id="L1186">    }</span>
<span class="line" id="L1187">}</span>
<span class="line" id="L1188"></span>
<span class="line" id="L1189"><span class="tok-kw">fn</span> <span class="tok-fn">applyIniValueReplacementRulesRecursivelyFolder</span>(file_tree: *IniFolder, <span class="tok-kw">comptime</span> property: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, old_value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L1190">    <span class="tok-kw">for</span> (file_tree.folders.items) |*folder| {</span>
<span class="line" id="L1191">        applyIniValueReplacementRulesRecursivelyFolder(folder, property, old_value, new_value);</span>
<span class="line" id="L1192">    }</span>
<span class="line" id="L1193"></span>
<span class="line" id="L1194">    <span class="tok-kw">for</span> (file_tree.files.items) |file| {</span>
<span class="line" id="L1195">        <span class="tok-kw">for</span> (file.ast.items) |*node| {</span>
<span class="line" id="L1196">            applyIniValueReplacementRulesRecursivelyNode(node, property, old_value, new_value);</span>
<span class="line" id="L1197">        }</span>
<span class="line" id="L1198">    }</span>
<span class="line" id="L1199">}</span>
<span class="line" id="L1200"></span>
<span class="line" id="L1201"><span class="tok-kw">fn</span> <span class="tok-fn">applyIniValueReplacementRulesRecursivelyNode</span>(node: *Node, <span class="tok-kw">comptime</span> property: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, old_value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_value: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L1202">    <span class="tok-kw">if</span> (node.property) |node_property| {</span>
<span class="line" id="L1203">        <span class="tok-kw">if</span> (strEql(node_property, property)) {</span>
<span class="line" id="L1204">            <span class="tok-kw">if</span> (node.value) |value| {</span>
<span class="line" id="L1205">                <span class="tok-kw">if</span> (strEql(value, old_value)) {</span>
<span class="line" id="L1206">                    node.value = new_value;</span>
<span class="line" id="L1207">                }</span>
<span class="line" id="L1208">            }</span>
<span class="line" id="L1209">        }</span>
<span class="line" id="L1210">    }</span>
<span class="line" id="L1211"></span>
<span class="line" id="L1212">    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L1213">        applyIniValueReplacementRulesRecursivelyNode(child, property, old_value, new_value);</span>
<span class="line" id="L1214">    }</span>
<span class="line" id="L1215">}</span>
<span class="line" id="L1216"></span>
<span class="line" id="L1217"><span class="tok-kw">fn</span> <span class="tok-fn">parseIniFilePathRules</span>(allocator: Allocator) !std.json.ArrayHashMap([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) {</span>
<span class="line" id="L1218">    <span class="tok-kw">const</span> text = <span class="tok-kw">try</span> readFile(<span class="tok-str">&quot;rules/ini_file_path_rules.json&quot;</span>, allocator);</span>
<span class="line" id="L1219"></span>
<span class="line" id="L1220">    <span class="tok-kw">var</span> scanner = Scanner.initCompleteInput(allocator, text);</span>
<span class="line" id="L1221"></span>
<span class="line" id="L1222">    <span class="tok-kw">var</span> rules = <span class="tok-kw">try</span> std.json.ArrayHashMap([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).jsonParse(allocator, &amp;scanner, .{ .allocate = .alloc_if_needed, .max_value_len = default_max_value_len });</span>
<span class="line" id="L1223">    <span class="tok-kw">return</span> rules;</span>
<span class="line" id="L1224">}</span>
<span class="line" id="L1225"></span>
<span class="line" id="L1226"><span class="tok-kw">fn</span> <span class="tok-fn">applyIniFilePathRules</span>(rules: std.json.ArrayHashMap([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>), file_tree: *IniFolder) <span class="tok-type">void</span> {</span>
<span class="line" id="L1227">    <span class="tok-kw">var</span> map_iterator = rules.map.iterator();</span>
<span class="line" id="L1228">    <span class="tok-kw">while</span> (map_iterator.next()) |map_entry| {</span>
<span class="line" id="L1229">        <span class="tok-kw">const</span> old_value = map_entry.key_ptr.*;</span>
<span class="line" id="L1230">        <span class="tok-kw">const</span> new_value = map_entry.value_ptr.*;</span>
<span class="line" id="L1231"></span>
<span class="line" id="L1232">        applyIniValueReplacementRulesRecursivelyFolder(file_tree, <span class="tok-str">&quot;FilePath&quot;</span>, old_value, new_value);</span>
<span class="line" id="L1233">    }</span>
<span class="line" id="L1234">}</span>
<span class="line" id="L1235"></span>
<span class="line" id="L1236"><span class="tok-kw">fn</span> <span class="tok-fn">parseIniScriptPathRules</span>(allocator: Allocator) !std.json.ArrayHashMap([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) {</span>
<span class="line" id="L1237">    <span class="tok-kw">const</span> text = <span class="tok-kw">try</span> readFile(<span class="tok-str">&quot;rules/ini_script_path_rules.json&quot;</span>, allocator);</span>
<span class="line" id="L1238"></span>
<span class="line" id="L1239">    <span class="tok-kw">var</span> scanner = Scanner.initCompleteInput(allocator, text);</span>
<span class="line" id="L1240"></span>
<span class="line" id="L1241">    <span class="tok-kw">var</span> rules = <span class="tok-kw">try</span> std.json.ArrayHashMap([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).jsonParse(allocator, &amp;scanner, .{ .allocate = .alloc_if_needed, .max_value_len = default_max_value_len });</span>
<span class="line" id="L1242">    <span class="tok-kw">return</span> rules;</span>
<span class="line" id="L1243">}</span>
<span class="line" id="L1244"></span>
<span class="line" id="L1245"><span class="tok-kw">fn</span> <span class="tok-fn">applyIniScriptPathRules</span>(rules: std.json.ArrayHashMap([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>), file_tree: *IniFolder) <span class="tok-type">void</span> {</span>
<span class="line" id="L1246">    <span class="tok-kw">var</span> map_iterator = rules.map.iterator();</span>
<span class="line" id="L1247">    <span class="tok-kw">while</span> (map_iterator.next()) |map_entry| {</span>
<span class="line" id="L1248">        <span class="tok-kw">const</span> old_value = map_entry.key_ptr.*;</span>
<span class="line" id="L1249">        <span class="tok-kw">const</span> new_value = map_entry.value_ptr.*;</span>
<span class="line" id="L1250"></span>
<span class="line" id="L1251">        applyIniValueReplacementRulesRecursivelyFolder(file_tree, <span class="tok-str">&quot;ScriptPath&quot;</span>, old_value, new_value);</span>
<span class="line" id="L1252">    }</span>
<span class="line" id="L1253">}</span>
<span class="line" id="L1254"></span>
<span class="line" id="L1255"><span class="tok-kw">fn</span> <span class="tok-fn">parseIniPropertyRules</span>(allocator: Allocator) !std.json.ArrayHashMap([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>) {</span>
<span class="line" id="L1256">    <span class="tok-kw">const</span> text = <span class="tok-kw">try</span> readFile(<span class="tok-str">&quot;rules/ini_property_rules.json&quot;</span>, allocator);</span>
<span class="line" id="L1257"></span>
<span class="line" id="L1258">    <span class="tok-kw">var</span> scanner = Scanner.initCompleteInput(allocator, text);</span>
<span class="line" id="L1259"></span>
<span class="line" id="L1260">    <span class="tok-kw">var</span> ini_property_rules = <span class="tok-kw">try</span> std.json.ArrayHashMap([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).jsonParse(allocator, &amp;scanner, .{ .allocate = .alloc_if_needed, .max_value_len = default_max_value_len });</span>
<span class="line" id="L1261">    <span class="tok-kw">return</span> ini_property_rules;</span>
<span class="line" id="L1262">}</span>
<span class="line" id="L1263"></span>
<span class="line" id="L1264"><span class="tok-kw">fn</span> <span class="tok-fn">applyIniPropertyRules</span>(ini_property_rules: std.json.ArrayHashMap([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>), file_tree: *IniFolder) <span class="tok-type">void</span> {</span>
<span class="line" id="L1265">    <span class="tok-kw">var</span> map_iterator = ini_property_rules.map.iterator();</span>
<span class="line" id="L1266">    <span class="tok-kw">while</span> (map_iterator.next()) |map_entry| {</span>
<span class="line" id="L1267">        <span class="tok-kw">const</span> old_property = map_entry.key_ptr.*;</span>
<span class="line" id="L1268">        <span class="tok-kw">const</span> new_property = map_entry.value_ptr.*;</span>
<span class="line" id="L1269"></span>
<span class="line" id="L1270">        applyIniPropertyRulesRecursivelyFolder(file_tree, old_property, new_property);</span>
<span class="line" id="L1271">    }</span>
<span class="line" id="L1272">}</span>
<span class="line" id="L1273"></span>
<span class="line" id="L1274"><span class="tok-kw">fn</span> <span class="tok-fn">applyIniPropertyRulesRecursivelyFolder</span>(file_tree: *IniFolder, old_property: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_property: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L1275">    <span class="tok-kw">for</span> (file_tree.folders.items) |*folder| {</span>
<span class="line" id="L1276">        applyIniPropertyRulesRecursivelyFolder(folder, old_property, new_property);</span>
<span class="line" id="L1277">    }</span>
<span class="line" id="L1278"></span>
<span class="line" id="L1279">    <span class="tok-kw">for</span> (file_tree.files.items) |file| {</span>
<span class="line" id="L1280">        <span class="tok-kw">for</span> (file.ast.items) |*node| {</span>
<span class="line" id="L1281">            applyIniPropertyRulesRecursivelyNode(node, old_property, new_property);</span>
<span class="line" id="L1282">        }</span>
<span class="line" id="L1283">    }</span>
<span class="line" id="L1284">}</span>
<span class="line" id="L1285"></span>
<span class="line" id="L1286"><span class="tok-kw">fn</span> <span class="tok-fn">applyIniPropertyRulesRecursivelyNode</span>(node: *Node, old_property: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, new_property: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L1287">    <span class="tok-kw">if</span> (node.property) |node_property| {</span>
<span class="line" id="L1288">        <span class="tok-kw">if</span> (strEql(node_property, old_property)) {</span>
<span class="line" id="L1289">            node.property = new_property;</span>
<span class="line" id="L1290">        }</span>
<span class="line" id="L1291">    }</span>
<span class="line" id="L1292"></span>
<span class="line" id="L1293">    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L1294">        applyIniPropertyRulesRecursivelyNode(child, old_property, new_property);</span>
<span class="line" id="L1295">    }</span>
<span class="line" id="L1296">}</span>
<span class="line" id="L1297"></span>
<span class="line" id="L1298"><span class="tok-kw">fn</span> <span class="tok-fn">parseIniRules</span>(allocator: Allocator) ![]Rule {</span>
<span class="line" id="L1299">    <span class="tok-kw">const</span> text = <span class="tok-kw">try</span> readFile(<span class="tok-str">&quot;rules/ini_rules.json&quot;</span>, allocator);</span>
<span class="line" id="L1300">    <span class="tok-kw">return</span> <span class="tok-kw">try</span> parseFromSliceLeaky([]Rule, allocator, text, .{});</span>
<span class="line" id="L1301">}</span>
<span class="line" id="L1302"></span>
<span class="line" id="L1303"><span class="tok-kw">fn</span> <span class="tok-fn">applyIniRules</span>(ini_rules: []Rule, file_tree: *IniFolder) <span class="tok-type">void</span> {</span>
<span class="line" id="L1304">    <span class="tok-kw">for</span> (ini_rules) |*rule| {</span>
<span class="line" id="L1305">        applyIniRulesRecursivelyFolder(file_tree, rule);</span>
<span class="line" id="L1306">    }</span>
<span class="line" id="L1307">}</span>
<span class="line" id="L1308"></span>
<span class="line" id="L1309"><span class="tok-kw">fn</span> <span class="tok-fn">applyIniRulesRecursivelyFolder</span>(file_tree: *IniFolder, rule: *Rule) <span class="tok-type">void</span> {</span>
<span class="line" id="L1310">    <span class="tok-kw">for</span> (file_tree.folders.items) |*folder| {</span>
<span class="line" id="L1311">        applyIniRulesRecursivelyFolder(folder, rule);</span>
<span class="line" id="L1312">    }</span>
<span class="line" id="L1313"></span>
<span class="line" id="L1314">    <span class="tok-kw">for</span> (file_tree.files.items) |file| {</span>
<span class="line" id="L1315">        <span class="tok-kw">for</span> (file.ast.items) |*node| {</span>
<span class="line" id="L1316">            applyIniRulesRecursivelyNode(node, rule);</span>
<span class="line" id="L1317">        }</span>
<span class="line" id="L1318">    }</span>
<span class="line" id="L1319">}</span>
<span class="line" id="L1320"></span>
<span class="line" id="L1321"><span class="tok-kw">fn</span> <span class="tok-fn">applyIniRulesRecursivelyNode</span>(node: *Node, rule: *Rule) <span class="tok-type">void</span> {</span>
<span class="line" id="L1322">    <span class="tok-kw">if</span> (node.property) |node_property| {</span>
<span class="line" id="L1323">        <span class="tok-kw">if</span> (strEql(node_property, rule.old_property)) {</span>
<span class="line" id="L1324">            <span class="tok-kw">if</span> (node.value) |node_value| {</span>
<span class="line" id="L1325">                <span class="tok-kw">if</span> (strEql(node_value, rule.old_value)) {</span>
<span class="line" id="L1326">                    node.property = rule.new_property;</span>
<span class="line" id="L1327">                    node.value = rule.new_value;</span>
<span class="line" id="L1328">                }</span>
<span class="line" id="L1329">            }</span>
<span class="line" id="L1330">        }</span>
<span class="line" id="L1331">    }</span>
<span class="line" id="L1332"></span>
<span class="line" id="L1333">    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L1334">        applyIniRulesRecursivelyNode(child, rule);</span>
<span class="line" id="L1335">    }</span>
<span class="line" id="L1336">}</span>
<span class="line" id="L1337"></span>
<span class="line" id="L1338"><span class="tok-kw">fn</span> <span class="tok-fn">parseIniSoundContainerRules</span>(allocator: Allocator) ![][]<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L1339">    <span class="tok-kw">const</span> text = <span class="tok-kw">try</span> readFile(<span class="tok-str">&quot;rules/ini_sound_container_rules.json&quot;</span>, allocator);</span>
<span class="line" id="L1340">    <span class="tok-kw">return</span> <span class="tok-kw">try</span> parseFromSliceLeaky([][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allocator, text, .{});</span>
<span class="line" id="L1341">}</span>
<span class="line" id="L1342"></span>
<span class="line" id="L1343"><span class="tok-kw">fn</span> <span class="tok-fn">applyIniSoundContainerRules</span>(ini_sound_container_rules: [][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>, file_tree: *IniFolder) <span class="tok-type">void</span> {</span>
<span class="line" id="L1344">    <span class="tok-kw">for</span> (ini_sound_container_rules) |property| {</span>
<span class="line" id="L1345">        applyIniSoundContainerRulesRecursivelyFolder(file_tree, property);</span>
<span class="line" id="L1346">    }</span>
<span class="line" id="L1347">}</span>
<span class="line" id="L1348"></span>
<span class="line" id="L1349"><span class="tok-kw">fn</span> <span class="tok-fn">applyIniSoundContainerRulesRecursivelyFolder</span>(file_tree: *IniFolder, property: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L1350">    <span class="tok-kw">for</span> (file_tree.folders.items) |*folder| {</span>
<span class="line" id="L1351">        applyIniSoundContainerRulesRecursivelyFolder(folder, property);</span>
<span class="line" id="L1352">    }</span>
<span class="line" id="L1353"></span>
<span class="line" id="L1354">    <span class="tok-kw">for</span> (file_tree.files.items) |file| {</span>
<span class="line" id="L1355">        <span class="tok-kw">for</span> (file.ast.items) |*node| {</span>
<span class="line" id="L1356">            applyIniSoundContainerRulesRecursivelyNode(node, property);</span>
<span class="line" id="L1357">        }</span>
<span class="line" id="L1358">    }</span>
<span class="line" id="L1359">}</span>
<span class="line" id="L1360"></span>
<span class="line" id="L1361"><span class="tok-kw">fn</span> <span class="tok-fn">applyIniSoundContainerRulesRecursivelyNode</span>(node: *Node, property: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">void</span> {</span>
<span class="line" id="L1362">    <span class="tok-kw">if</span> (node.property) |node_property| {</span>
<span class="line" id="L1363">        <span class="tok-kw">if</span> (strEql(node_property, property)) {</span>
<span class="line" id="L1364">            <span class="tok-kw">if</span> (node.value) |node_value| {</span>
<span class="line" id="L1365">                <span class="tok-kw">if</span> (strEql(node_value, <span class="tok-str">&quot;Sound&quot;</span>)) {</span>
<span class="line" id="L1366">                    node.value = <span class="tok-str">&quot;SoundContainer&quot;</span>;</span>
<span class="line" id="L1367">                }</span>
<span class="line" id="L1368">            }</span>
<span class="line" id="L1369">        }</span>
<span class="line" id="L1370">    }</span>
<span class="line" id="L1371"></span>
<span class="line" id="L1372">    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L1373">        applyIniSoundContainerRulesRecursivelyNode(child, property);</span>
<span class="line" id="L1374">    }</span>
<span class="line" id="L1375">}</span>
<span class="line" id="L1376"></span>
<span class="line" id="L1377"><span class="tok-kw">fn</span> <span class="tok-fn">updateIniFileTree</span>(file_tree: *IniFolder, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1378">    <span class="tok-kw">try</span> applyOnNodesAlloc(addGetsHitByMosWhenHeldToShields, file_tree, allocator);</span>
<span class="line" id="L1379">    <span class="tok-kw">try</span> applyOnNodesAlloc(addGripStrength, file_tree, allocator);</span>
<span class="line" id="L1380">    <span class="tok-kw">try</span> applyOnNodesAlloc(addOrUpdateSupportedGameVersion, file_tree, allocator);</span>
<span class="line" id="L1381">    <span class="tok-kw">try</span> applyOnNodes(aemitterFuelToPemitter, file_tree);</span>
<span class="line" id="L1382"></span>
<span class="line" id="L1383">    <span class="tok-comment">// Handles AEJetpacks being made first-class citizens by Causeless</span>
</span>
<span class="line" id="L1384">    {</span>
<span class="line" id="L1385">        <span class="tok-kw">try</span> aemitterToAejetpack(file_tree, file_tree, allocator);</span>
<span class="line" id="L1386">        <span class="tok-kw">try</span> moveJetpackModifiers(file_tree, file_tree, allocator);</span>
<span class="line" id="L1387">        <span class="tok-kw">try</span> copyJetpack(file_tree, file_tree, allocator);</span>
<span class="line" id="L1388">        <span class="tok-kw">try</span> moveJetpackModifiers(file_tree, file_tree, allocator);</span>
<span class="line" id="L1389">        <span class="tok-kw">try</span> removeJetpackModifiersFromActors(file_tree, file_tree, allocator);</span>
<span class="line" id="L1390">    }</span>
<span class="line" id="L1391"></span>
<span class="line" id="L1392">    <span class="tok-kw">try</span> applyOnNodesAlloc(maxLengthToOffsets, file_tree, allocator);</span>
<span class="line" id="L1393">    <span class="tok-kw">try</span> applyOnNodesAlloc(maxMassToMaxInventoryMass, file_tree, allocator);</span>
<span class="line" id="L1394">    <span class="tok-kw">try</span> applyOnNodesAlloc(maxThrottleRangeToPositiveThrottleMultiplier, file_tree, allocator);</span>
<span class="line" id="L1395">    <span class="tok-kw">try</span> applyOnNodesAlloc(minThrottleRangeToNegativeThrottleMultiplier, file_tree, allocator);</span>
<span class="line" id="L1396"></span>
<span class="line" id="L1397">    <span class="tok-kw">try</span> pieMenu(<span class="tok-str">&quot;ACDropShip&quot;</span>, <span class="tok-str">&quot;Default Craft Pie Menu&quot;</span>, <span class="tok-number">2</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, file_tree, allocator);</span>
<span class="line" id="L1398">    <span class="tok-kw">try</span> pieMenu(<span class="tok-str">&quot;ACrab&quot;</span>, <span class="tok-str">&quot;Default Crab Pie Menu&quot;</span>, <span class="tok-number">2</span>, <span class="tok-number">2</span>, <span class="tok-number">2</span>, <span class="tok-number">2</span>, file_tree, allocator);</span>
<span class="line" id="L1399">    <span class="tok-kw">try</span> pieMenu(<span class="tok-str">&quot;ACRocket&quot;</span>, <span class="tok-str">&quot;Default Craft Pie Menu&quot;</span>, <span class="tok-number">2</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, <span class="tok-number">1</span>, file_tree, allocator);</span>
<span class="line" id="L1400">    <span class="tok-kw">try</span> pieMenu(<span class="tok-str">&quot;Actor&quot;</span>, <span class="tok-str">&quot;Default Actor Pie Menu&quot;</span>, <span class="tok-number">1</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, file_tree, allocator);</span>
<span class="line" id="L1401">    <span class="tok-kw">try</span> pieMenu(<span class="tok-str">&quot;AHuman&quot;</span>, <span class="tok-str">&quot;Default Human Pie Menu&quot;</span>, <span class="tok-number">2</span>, <span class="tok-number">2</span>, <span class="tok-number">2</span>, <span class="tok-number">2</span>, file_tree, allocator);</span>
<span class="line" id="L1402">    <span class="tok-kw">try</span> pieMenu(<span class="tok-str">&quot;Turret&quot;</span>, <span class="tok-str">&quot;Default Turret Pie Menu&quot;</span>, <span class="tok-number">2</span>, <span class="tok-number">0</span>, <span class="tok-number">0</span>, <span class="tok-number">1</span>, file_tree, allocator);</span>
<span class="line" id="L1403"></span>
<span class="line" id="L1404">    <span class="tok-kw">try</span> applyOnNodesAlloc(removeSlTerrainProperties, file_tree, allocator);</span>
<span class="line" id="L1405">    <span class="tok-kw">try</span> applyOnNodes(shovelFlashFix, file_tree);</span>
<span class="line" id="L1406">}</span>
<span class="line" id="L1407"></span>
<span class="line" id="L1408"><span class="tok-kw">fn</span> <span class="tok-fn">addGetsHitByMosWhenHeldToShields</span>(node: *Node, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1409">    <span class="tok-kw">if</span> (node.property) |node_property| {</span>
<span class="line" id="L1410">        <span class="tok-kw">if</span> (isInsaneProperty(node_property)) {</span>
<span class="line" id="L1411">            <span class="tok-kw">if</span> (node.value) |node_value| {</span>
<span class="line" id="L1412">                <span class="tok-kw">if</span> (strEql(node_value, <span class="tok-str">&quot;HeldDevice&quot;</span>)) {</span>
<span class="line" id="L1413">                    <span class="tok-kw">var</span> children = &amp;node.children;</span>
<span class="line" id="L1414"></span>
<span class="line" id="L1415">                    <span class="tok-kw">var</span> is_in_shield_group = <span class="tok-null">false</span>;</span>
<span class="line" id="L1416"></span>
<span class="line" id="L1417">                    <span class="tok-kw">for</span> (children.items) |child| {</span>
<span class="line" id="L1418">                        <span class="tok-kw">if</span> (child.property) |property| {</span>
<span class="line" id="L1419">                            <span class="tok-kw">if</span> (strEql(property, <span class="tok-str">&quot;GetsHitByMOsWhenHeld&quot;</span>)) {</span>
<span class="line" id="L1420">                                <span class="tok-kw">return</span>;</span>
<span class="line" id="L1421">                            }</span>
<span class="line" id="L1422">                            <span class="tok-kw">if</span> (strEql(property, <span class="tok-str">&quot;AddToGroup&quot;</span>)) {</span>
<span class="line" id="L1423">                                <span class="tok-kw">if</span> (child.value) |value| {</span>
<span class="line" id="L1424">                                    <span class="tok-kw">if</span> (strEql(value, <span class="tok-str">&quot;Shields&quot;</span>)) {</span>
<span class="line" id="L1425">                                        is_in_shield_group = <span class="tok-null">true</span>;</span>
<span class="line" id="L1426">                                    }</span>
<span class="line" id="L1427">                                }</span>
<span class="line" id="L1428">                            }</span>
<span class="line" id="L1429">                        }</span>
<span class="line" id="L1430">                    }</span>
<span class="line" id="L1431"></span>
<span class="line" id="L1432">                    <span class="tok-kw">if</span> (!is_in_shield_group) {</span>
<span class="line" id="L1433">                        <span class="tok-kw">return</span>;</span>
<span class="line" id="L1434">                    }</span>
<span class="line" id="L1435"></span>
<span class="line" id="L1436">                    <span class="tok-kw">try</span> children.append(Node{</span>
<span class="line" id="L1437">                        .property = <span class="tok-str">&quot;GetsHitByMOsWhenHeld&quot;</span>,</span>
<span class="line" id="L1438">                        .value = <span class="tok-str">&quot;1&quot;</span>,</span>
<span class="line" id="L1439">                        .comments = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(allocator),</span>
<span class="line" id="L1440">                        .children = ArrayList(Node).init(allocator),</span>
<span class="line" id="L1441">                    });</span>
<span class="line" id="L1442">                }</span>
<span class="line" id="L1443">            }</span>
<span class="line" id="L1444">        }</span>
<span class="line" id="L1445">    }</span>
<span class="line" id="L1446">}</span>
<span class="line" id="L1447"></span>
<span class="line" id="L1448"><span class="tok-comment">/// &quot;Insane&quot;, because the game accepts things like &quot;AddAmmo = AHuman&quot; and &quot;AddActor = HeldDevice&quot;</span></span>
<span class="line" id="L1449"><span class="tok-kw">fn</span> <span class="tok-fn">isInsaneProperty</span>(property: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L1450">    <span class="tok-kw">return</span> strEql(property, <span class="tok-str">&quot;AddEffect&quot;</span>) <span class="tok-kw">or</span> strEql(property, <span class="tok-str">&quot;AddAmmo&quot;</span>) <span class="tok-kw">or</span> strEql(property, <span class="tok-str">&quot;AddDevice&quot;</span>) <span class="tok-kw">or</span> strEql(property, <span class="tok-str">&quot;AddActor&quot;</span>);</span>
<span class="line" id="L1451">}</span>
<span class="line" id="L1452"></span>
<span class="line" id="L1453"><span class="tok-kw">fn</span> <span class="tok-fn">addGripStrength</span>(node: *Node, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1454">    <span class="tok-kw">if</span> (node.property) |node_property| {</span>
<span class="line" id="L1455">        <span class="tok-kw">if</span> (isInsaneProperty(node_property)) {</span>
<span class="line" id="L1456">            <span class="tok-kw">if</span> (node.value) |node_value| {</span>
<span class="line" id="L1457">                <span class="tok-kw">if</span> (strEql(node_value, <span class="tok-str">&quot;Arm&quot;</span>)) {</span>
<span class="line" id="L1458">                    <span class="tok-kw">var</span> children = &amp;node.children;</span>
<span class="line" id="L1459"></span>
<span class="line" id="L1460">                    <span class="tok-kw">for</span> (children.items) |child| {</span>
<span class="line" id="L1461">                        <span class="tok-kw">if</span> (child.property) |property| {</span>
<span class="line" id="L1462">                            <span class="tok-kw">if</span> (strEql(property, <span class="tok-str">&quot;GripStrength&quot;</span>)) {</span>
<span class="line" id="L1463">                                <span class="tok-kw">return</span>;</span>
<span class="line" id="L1464">                            }</span>
<span class="line" id="L1465">                        }</span>
<span class="line" id="L1466">                    }</span>
<span class="line" id="L1467"></span>
<span class="line" id="L1468">                    <span class="tok-kw">try</span> children.append(Node{</span>
<span class="line" id="L1469">                        .property = <span class="tok-str">&quot;GripStrength&quot;</span>,</span>
<span class="line" id="L1470">                        .value = <span class="tok-str">&quot;424242&quot;</span>,</span>
<span class="line" id="L1471">                        .comments = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(allocator),</span>
<span class="line" id="L1472">                        .children = ArrayList(Node).init(allocator),</span>
<span class="line" id="L1473">                    });</span>
<span class="line" id="L1474">                }</span>
<span class="line" id="L1475">            }</span>
<span class="line" id="L1476">        }</span>
<span class="line" id="L1477">    }</span>
<span class="line" id="L1478">}</span>
<span class="line" id="L1479"></span>
<span class="line" id="L1480"><span class="tok-kw">fn</span> <span class="tok-fn">addOrUpdateSupportedGameVersion</span>(node: *Node, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1481">    <span class="tok-kw">const</span> converter_game_version = <span class="tok-str">&quot;6.0.0&quot;</span>;</span>
<span class="line" id="L1482"></span>
<span class="line" id="L1483">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L1484">        <span class="tok-kw">if</span> (strEql(property, <span class="tok-str">&quot;DataModule&quot;</span>)) {</span>
<span class="line" id="L1485">            <span class="tok-kw">var</span> has_supported_game_version = <span class="tok-null">false</span>;</span>
<span class="line" id="L1486"></span>
<span class="line" id="L1487">            <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L1488">                <span class="tok-kw">if</span> (child.property) |child_property| {</span>
<span class="line" id="L1489">                    <span class="tok-kw">if</span> (strEql(child_property, <span class="tok-str">&quot;SupportedGameVersion&quot;</span>)) {</span>
<span class="line" id="L1490">                        has_supported_game_version = <span class="tok-null">true</span>;</span>
<span class="line" id="L1491"></span>
<span class="line" id="L1492">                        <span class="tok-kw">if</span> (child.value) |child_value| {</span>
<span class="line" id="L1493">                            <span class="tok-kw">if</span> (!strEql(child_value, converter_game_version)) {</span>
<span class="line" id="L1494">                                child.value = converter_game_version;</span>
<span class="line" id="L1495">                            }</span>
<span class="line" id="L1496">                        }</span>
<span class="line" id="L1497">                    }</span>
<span class="line" id="L1498">                }</span>
<span class="line" id="L1499">            }</span>
<span class="line" id="L1500"></span>
<span class="line" id="L1501">            <span class="tok-kw">if</span> (!has_supported_game_version) {</span>
<span class="line" id="L1502">                <span class="tok-kw">try</span> node.children.append(Node{</span>
<span class="line" id="L1503">                    .property = <span class="tok-str">&quot;SupportedGameVersion&quot;</span>,</span>
<span class="line" id="L1504">                    .value = converter_game_version,</span>
<span class="line" id="L1505">                    .comments = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(allocator),</span>
<span class="line" id="L1506">                    .children = ArrayList(Node).init(allocator),</span>
<span class="line" id="L1507">                });</span>
<span class="line" id="L1508">            }</span>
<span class="line" id="L1509">        }</span>
<span class="line" id="L1510">    }</span>
<span class="line" id="L1511">}</span>
<span class="line" id="L1512"></span>
<span class="line" id="L1513"><span class="tok-kw">fn</span> <span class="tok-fn">aemitterFuelToPemitter</span>(node: *Node) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1514">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L1515">        <span class="tok-kw">if</span> (strEql(property, <span class="tok-str">&quot;GibParticle&quot;</span>)) {</span>
<span class="line" id="L1516">            <span class="tok-kw">if</span> (node.value) |value| {</span>
<span class="line" id="L1517">                <span class="tok-kw">if</span> (strEql(value, <span class="tok-str">&quot;AEmitter&quot;</span>)) {</span>
<span class="line" id="L1518">                    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L1519">                        <span class="tok-kw">if</span> (child.property) |child_property| {</span>
<span class="line" id="L1520">                            <span class="tok-kw">if</span> (strEql(child_property, <span class="tok-str">&quot;CopyOf&quot;</span>)) {</span>
<span class="line" id="L1521">                                <span class="tok-kw">if</span> (child.value) |child_value| {</span>
<span class="line" id="L1522">                                    <span class="tok-kw">if</span> (strEql(child_value, <span class="tok-str">&quot;Fuel Fire Trace Black&quot;</span>)) {</span>
<span class="line" id="L1523">                                        node.value = <span class="tok-str">&quot;PEmitter&quot;</span>;</span>
<span class="line" id="L1524">                                    }</span>
<span class="line" id="L1525">                                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1526">                                    <span class="tok-kw">return</span> UpdateIniFileTreeErrors.ExpectedValue;</span>
<span class="line" id="L1527">                                }</span>
<span class="line" id="L1528">                            }</span>
<span class="line" id="L1529">                        }</span>
<span class="line" id="L1530">                    }</span>
<span class="line" id="L1531">                }</span>
<span class="line" id="L1532">            }</span>
<span class="line" id="L1533">        }</span>
<span class="line" id="L1534">    }</span>
<span class="line" id="L1535">}</span>
<span class="line" id="L1536"></span>
<span class="line" id="L1537"><span class="tok-kw">fn</span> <span class="tok-fn">aemitterToAejetpack</span>(folder: *IniFolder, file_tree: *IniFolder, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1538">    <span class="tok-kw">for</span> (folder.folders.items) |*subfolder| {</span>
<span class="line" id="L1539">        <span class="tok-kw">try</span> aemitterToAejetpack(subfolder, file_tree, allocator);</span>
<span class="line" id="L1540">    }</span>
<span class="line" id="L1541"></span>
<span class="line" id="L1542">    <span class="tok-kw">for</span> (folder.files.items) |file| {</span>
<span class="line" id="L1543">        <span class="tok-kw">for</span> (file.ast.items) |*node| {</span>
<span class="line" id="L1544">            <span class="tok-kw">try</span> aemitterToAejetpackRecursivelyNode(node, file_tree, allocator);</span>
<span class="line" id="L1545">        }</span>
<span class="line" id="L1546">    }</span>
<span class="line" id="L1547">}</span>
<span class="line" id="L1548"></span>
<span class="line" id="L1549"><span class="tok-comment">// Translate &quot;Jetpack = AEmitter&quot; to &quot;Jetpack = AEJetpack&quot;,</span>
</span>
<span class="line" id="L1550"><span class="tok-comment">// and its &quot;AddEffect = AEmitter&quot; children to &quot;AddEffect = AEJetpack&quot;</span>
</span>
<span class="line" id="L1551"><span class="tok-kw">fn</span> <span class="tok-fn">aemitterToAejetpackRecursivelyNode</span>(node: *Node, file_tree: *IniFolder, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1552">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L1553">        <span class="tok-kw">if</span> (strEql(property, <span class="tok-str">&quot;Jetpack&quot;</span>)) {</span>
<span class="line" id="L1554">            <span class="tok-kw">if</span> (node.value) |value| {</span>
<span class="line" id="L1555">                <span class="tok-kw">if</span> (strEql(value, <span class="tok-str">&quot;AEmitter&quot;</span>)) {</span>
<span class="line" id="L1556">                    node.value = <span class="tok-str">&quot;AEJetpack&quot;</span>;</span>
<span class="line" id="L1557"></span>
<span class="line" id="L1558">                    <span class="tok-kw">try</span> addEffectAemitterToAddEffectAejetpackCopyOfFinder(node, file_tree);</span>
<span class="line" id="L1559">                }</span>
<span class="line" id="L1560">            }</span>
<span class="line" id="L1561">        }</span>
<span class="line" id="L1562">    }</span>
<span class="line" id="L1563"></span>
<span class="line" id="L1564">    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L1565">        <span class="tok-kw">try</span> aemitterToAejetpackRecursivelyNode(child, file_tree, allocator);</span>
<span class="line" id="L1566">    }</span>
<span class="line" id="L1567">}</span>
<span class="line" id="L1568"></span>
<span class="line" id="L1569"><span class="tok-kw">fn</span> <span class="tok-fn">addEffectAemitterToAddEffectAejetpackCopyOfFinder</span>(node: *Node, file_tree: *IniFolder) <span class="tok-kw">error</span>{ExpectedValue}!<span class="tok-type">void</span> {</span>
<span class="line" id="L1570">    <span class="tok-kw">for</span> (node.children.items) |*node_child| {</span>
<span class="line" id="L1571">        <span class="tok-kw">if</span> (node_child.property) |node_child_property| {</span>
<span class="line" id="L1572">            <span class="tok-kw">if</span> (strEql(node_child_property, <span class="tok-str">&quot;CopyOf&quot;</span>)) {</span>
<span class="line" id="L1573">                <span class="tok-kw">if</span> (node_child.value) |preset_name| {</span>
<span class="line" id="L1574">                    <span class="tok-kw">try</span> addEffectAemitterToAddEffectAejetpackRecursivelyFolder(file_tree, file_tree, preset_name);</span>
<span class="line" id="L1575">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1576">                    <span class="tok-kw">return</span> UpdateIniFileTreeErrors.ExpectedValue;</span>
<span class="line" id="L1577">                }</span>
<span class="line" id="L1578">            }</span>
<span class="line" id="L1579">        }</span>
<span class="line" id="L1580">    }</span>
<span class="line" id="L1581">}</span>
<span class="line" id="L1582"></span>
<span class="line" id="L1583"><span class="tok-kw">fn</span> <span class="tok-fn">addEffectAemitterToAddEffectAejetpackRecursivelyFolder</span>(folder: *IniFolder, file_tree: *IniFolder, preset_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1584">    <span class="tok-kw">for</span> (folder.folders.items) |*subfolder| {</span>
<span class="line" id="L1585">        <span class="tok-kw">try</span> addEffectAemitterToAddEffectAejetpackRecursivelyFolder(subfolder, file_tree, preset_name);</span>
<span class="line" id="L1586">    }</span>
<span class="line" id="L1587"></span>
<span class="line" id="L1588">    <span class="tok-kw">for</span> (folder.files.items) |file| {</span>
<span class="line" id="L1589">        <span class="tok-kw">for</span> (file.ast.items) |*node| {</span>
<span class="line" id="L1590">            <span class="tok-kw">try</span> addEffectAemitterToAddEffectAejetpackRecursivelyNode(node, file_tree, preset_name);</span>
<span class="line" id="L1591">        }</span>
<span class="line" id="L1592">    }</span>
<span class="line" id="L1593">}</span>
<span class="line" id="L1594"></span>
<span class="line" id="L1595"><span class="tok-kw">fn</span> <span class="tok-fn">addEffectAemitterToAddEffectAejetpackRecursivelyNode</span>(node: *Node, file_tree: *IniFolder, preset_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1596">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L1597">        <span class="tok-kw">if</span> (isInsaneProperty(property)) {</span>
<span class="line" id="L1598">            <span class="tok-kw">if</span> (node.value) |value| {</span>
<span class="line" id="L1599">                <span class="tok-kw">if</span> (strEql(value, <span class="tok-str">&quot;AEmitter&quot;</span>)) {</span>
<span class="line" id="L1600">                    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L1601">                        <span class="tok-kw">if</span> (child.property) |child_property| {</span>
<span class="line" id="L1602">                            <span class="tok-kw">if</span> (strEql(child_property, <span class="tok-str">&quot;PresetName&quot;</span>)) {</span>
<span class="line" id="L1603">                                <span class="tok-kw">if</span> (child.value) |child_value| {</span>
<span class="line" id="L1604">                                    <span class="tok-kw">if</span> (strEql(child_value, preset_name)) {</span>
<span class="line" id="L1605">                                        node.value = <span class="tok-str">&quot;AEJetpack&quot;</span>;</span>
<span class="line" id="L1606"></span>
<span class="line" id="L1607">                                        <span class="tok-kw">try</span> addEffectAemitterToAddEffectAejetpackCopyOfFinder(node, file_tree);</span>
<span class="line" id="L1608">                                    }</span>
<span class="line" id="L1609">                                }</span>
<span class="line" id="L1610">                            }</span>
<span class="line" id="L1611">                        }</span>
<span class="line" id="L1612">                    }</span>
<span class="line" id="L1613">                }</span>
<span class="line" id="L1614">            }</span>
<span class="line" id="L1615">        }</span>
<span class="line" id="L1616">    }</span>
<span class="line" id="L1617"></span>
<span class="line" id="L1618">    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L1619">        <span class="tok-kw">try</span> addEffectAemitterToAddEffectAejetpackRecursivelyNode(child, file_tree, preset_name);</span>
<span class="line" id="L1620">    }</span>
<span class="line" id="L1621">}</span>
<span class="line" id="L1622"></span>
<span class="line" id="L1623"><span class="tok-kw">fn</span> <span class="tok-fn">moveJetpackModifiers</span>(folder: *IniFolder, file_tree: *IniFolder, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1624">    <span class="tok-kw">for</span> (folder.folders.items) |*subfolder| {</span>
<span class="line" id="L1625">        <span class="tok-kw">try</span> moveJetpackModifiers(subfolder, file_tree, allocator);</span>
<span class="line" id="L1626">    }</span>
<span class="line" id="L1627"></span>
<span class="line" id="L1628">    <span class="tok-kw">for</span> (folder.files.items) |file| {</span>
<span class="line" id="L1629">        <span class="tok-kw">for</span> (file.ast.items) |*node| {</span>
<span class="line" id="L1630">            <span class="tok-kw">try</span> moveJetpackModifiersRecursivelyNode(node, file_tree, allocator);</span>
<span class="line" id="L1631">        }</span>
<span class="line" id="L1632">    }</span>
<span class="line" id="L1633">}</span>
<span class="line" id="L1634"></span>
<span class="line" id="L1635"><span class="tok-comment">/// Move the Actor's jetpack modifiers to its last &quot;Jetpack = AEJetpack&quot;,</span></span>
<span class="line" id="L1636"><span class="tok-comment">/// where the modifiers get pushed to the back of the AEJetpack if they came after it,</span></span>
<span class="line" id="L1637"><span class="tok-comment">/// and inserted to the front of it if they came before it.</span></span>
<span class="line" id="L1638"><span class="tok-comment">/// Modifiers that come after the AEJetpack are .appended() in a forwards loop.</span></span>
<span class="line" id="L1639"><span class="tok-comment">/// Modifiers that come before the AEJetpack are .inserted() in a backwards loop,</span></span>
<span class="line" id="L1640"><span class="tok-comment">/// where the loop is stopped if a CopyOf is encountered.</span></span>
<span class="line" id="L1641"><span class="tok-kw">fn</span> <span class="tok-fn">moveJetpackModifiersRecursivelyNode</span>(node: *Node, file_tree: *IniFolder, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1642">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L1643">        <span class="tok-kw">if</span> (isInsaneProperty(property)) {</span>
<span class="line" id="L1644">            <span class="tok-kw">if</span> (node.value) |value| {</span>
<span class="line" id="L1645">                <span class="tok-kw">if</span> (strEql(value, <span class="tok-str">&quot;ACrab&quot;</span>) <span class="tok-kw">or</span> strEql(value, <span class="tok-str">&quot;AHuman&quot;</span>)) {</span>
<span class="line" id="L1646">                    <span class="tok-kw">try</span> appendJetpackModifiers(node);</span>
<span class="line" id="L1647">                    <span class="tok-kw">try</span> prependJetpackModifiers(node);</span>
<span class="line" id="L1648">                }</span>
<span class="line" id="L1649">            }</span>
<span class="line" id="L1650">        }</span>
<span class="line" id="L1651">    }</span>
<span class="line" id="L1652"></span>
<span class="line" id="L1653">    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L1654">        <span class="tok-kw">try</span> moveJetpackModifiersRecursivelyNode(child, file_tree, allocator);</span>
<span class="line" id="L1655">    }</span>
<span class="line" id="L1656">}</span>
<span class="line" id="L1657"></span>
<span class="line" id="L1658"><span class="tok-kw">fn</span> <span class="tok-fn">appendJetpackModifiers</span>(node: *Node) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1659">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L1660">        <span class="tok-kw">var</span> modifier_index: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L1661">        <span class="tok-kw">var</span> removed = <span class="tok-null">false</span>;</span>
<span class="line" id="L1662">        modifier_blk: <span class="tok-kw">while</span> (modifier_index &lt; node.children.items.len) {</span>
<span class="line" id="L1663">            <span class="tok-kw">const</span> modifier = node.children.items[modifier_index];</span>
<span class="line" id="L1664">            <span class="tok-kw">if</span> (modifier.property) |modifier_property| {</span>
<span class="line" id="L1665">                <span class="tok-kw">if</span> (isJetpackModifier(modifier_property)) {</span>
<span class="line" id="L1666">                    <span class="tok-comment">// The AEJetpack *HAS* to be refound every time,</span>
</span>
<span class="line" id="L1667">                    <span class="tok-comment">// in order for aejetpack_index to stay accurate</span>
</span>
<span class="line" id="L1668">                    <span class="tok-kw">var</span> aejetpack_index = node.children.items.len;</span>
<span class="line" id="L1669">                    aejetpack_blk: <span class="tok-kw">while</span> (aejetpack_index &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L1670">                        aejetpack_index -= <span class="tok-number">1</span>;</span>
<span class="line" id="L1671">                        <span class="tok-kw">const</span> aejetpack = &amp;node.children.items[aejetpack_index];</span>
<span class="line" id="L1672">                        <span class="tok-kw">if</span> (aejetpack.property) |aejetpack_property| {</span>
<span class="line" id="L1673">                            <span class="tok-comment">// If there is no AEJetpack for it to be copied to</span>
</span>
<span class="line" id="L1674">                            <span class="tok-kw">if</span> (strEql(aejetpack_property, <span class="tok-str">&quot;CopyOf&quot;</span>)) {</span>
<span class="line" id="L1675">                                <span class="tok-kw">return</span>;</span>
<span class="line" id="L1676">                            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (strEql(aejetpack_property, <span class="tok-str">&quot;Jetpack&quot;</span>)) {</span>
<span class="line" id="L1677">                                <span class="tok-kw">if</span> (aejetpack.value) |aejetpack_value| {</span>
<span class="line" id="L1678">                                    <span class="tok-kw">if</span> (strEql(aejetpack_value, <span class="tok-str">&quot;AEJetpack&quot;</span>)) {</span>
<span class="line" id="L1679">                                        <span class="tok-kw">if</span> (modifier_index &gt; aejetpack_index) {</span>
<span class="line" id="L1680">                                            <span class="tok-kw">try</span> aejetpack.children.append(modifier);</span>
<span class="line" id="L1681">                                            _ = node.children.orderedRemove(modifier_index);</span>
<span class="line" id="L1682">                                            removed = <span class="tok-null">true</span>;</span>
<span class="line" id="L1683">                                            <span class="tok-kw">break</span> :modifier_blk;</span>
<span class="line" id="L1684">                                        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1685">                                            <span class="tok-kw">break</span> :aejetpack_blk;</span>
<span class="line" id="L1686">                                        }</span>
<span class="line" id="L1687">                                    }</span>
<span class="line" id="L1688">                                }</span>
<span class="line" id="L1689">                            }</span>
<span class="line" id="L1690">                        }</span>
<span class="line" id="L1691">                    }</span>
<span class="line" id="L1692">                }</span>
<span class="line" id="L1693">            }</span>
<span class="line" id="L1694">            modifier_index += <span class="tok-number">1</span>;</span>
<span class="line" id="L1695">        }</span>
<span class="line" id="L1696">        <span class="tok-kw">if</span> (!removed) {</span>
<span class="line" id="L1697">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L1698">        }</span>
<span class="line" id="L1699">    }</span>
<span class="line" id="L1700">}</span>
<span class="line" id="L1701"></span>
<span class="line" id="L1702"><span class="tok-kw">fn</span> <span class="tok-fn">prependJetpackModifiers</span>(node: *Node) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1703">    <span class="tok-kw">while</span> (<span class="tok-null">true</span>) {</span>
<span class="line" id="L1704">        <span class="tok-kw">var</span> modifier_index = node.children.items.len;</span>
<span class="line" id="L1705">        <span class="tok-kw">var</span> removed = <span class="tok-null">false</span>;</span>
<span class="line" id="L1706">        modifier_blk: <span class="tok-kw">while</span> (modifier_index &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L1707">            modifier_index -= <span class="tok-number">1</span>;</span>
<span class="line" id="L1708">            <span class="tok-kw">const</span> modifier = node.children.items[modifier_index];</span>
<span class="line" id="L1709">            <span class="tok-kw">if</span> (modifier.property) |modifier_property| {</span>
<span class="line" id="L1710">                <span class="tok-kw">if</span> (strEql(modifier_property, <span class="tok-str">&quot;CopyOf&quot;</span>)) {</span>
<span class="line" id="L1711">                    <span class="tok-kw">return</span>;</span>
<span class="line" id="L1712">                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (isJetpackModifier(modifier_property)) {</span>
<span class="line" id="L1713">                    <span class="tok-comment">// The AEJetpack *HAS* to be refound every time,</span>
</span>
<span class="line" id="L1714">                    <span class="tok-comment">// in order for aejetpack_index to stay accurate</span>
</span>
<span class="line" id="L1715">                    <span class="tok-kw">var</span> aejetpack_index = node.children.items.len;</span>
<span class="line" id="L1716">                    aejetpack_blk: <span class="tok-kw">while</span> (aejetpack_index &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L1717">                        aejetpack_index -= <span class="tok-number">1</span>;</span>
<span class="line" id="L1718">                        <span class="tok-kw">const</span> aejetpack = &amp;node.children.items[aejetpack_index];</span>
<span class="line" id="L1719">                        <span class="tok-kw">if</span> (aejetpack.property) |aejetpack_property| {</span>
<span class="line" id="L1720">                            <span class="tok-comment">// If there is no AEJetpack for it to be copied to</span>
</span>
<span class="line" id="L1721">                            <span class="tok-kw">if</span> (strEql(aejetpack_property, <span class="tok-str">&quot;CopyOf&quot;</span>)) {</span>
<span class="line" id="L1722">                                <span class="tok-kw">return</span>;</span>
<span class="line" id="L1723">                            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (strEql(aejetpack_property, <span class="tok-str">&quot;Jetpack&quot;</span>)) {</span>
<span class="line" id="L1724">                                <span class="tok-kw">if</span> (aejetpack.value) |aejetpack_value| {</span>
<span class="line" id="L1725">                                    <span class="tok-kw">if</span> (strEql(aejetpack_value, <span class="tok-str">&quot;AEJetpack&quot;</span>)) {</span>
<span class="line" id="L1726">                                        <span class="tok-kw">if</span> (modifier_index &lt; aejetpack_index) {</span>
<span class="line" id="L1727">                                            <span class="tok-kw">try</span> aejetpack.children.insert(<span class="tok-number">0</span>, modifier);</span>
<span class="line" id="L1728">                                            _ = node.children.orderedRemove(modifier_index);</span>
<span class="line" id="L1729">                                            removed = <span class="tok-null">true</span>;</span>
<span class="line" id="L1730">                                            <span class="tok-kw">break</span> :modifier_blk;</span>
<span class="line" id="L1731">                                        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1732">                                            <span class="tok-kw">break</span> :aejetpack_blk;</span>
<span class="line" id="L1733">                                        }</span>
<span class="line" id="L1734">                                    }</span>
<span class="line" id="L1735">                                }</span>
<span class="line" id="L1736">                            }</span>
<span class="line" id="L1737">                        }</span>
<span class="line" id="L1738">                    }</span>
<span class="line" id="L1739">                }</span>
<span class="line" id="L1740">            }</span>
<span class="line" id="L1741">        }</span>
<span class="line" id="L1742">        <span class="tok-kw">if</span> (!removed) {</span>
<span class="line" id="L1743">            <span class="tok-kw">return</span>;</span>
<span class="line" id="L1744">        }</span>
<span class="line" id="L1745">    }</span>
<span class="line" id="L1746">}</span>
<span class="line" id="L1747"></span>
<span class="line" id="L1748"><span class="tok-kw">fn</span> <span class="tok-fn">copyJetpack</span>(folder: *IniFolder, file_tree: *IniFolder, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1749">    <span class="tok-kw">for</span> (folder.folders.items) |*subfolder| {</span>
<span class="line" id="L1750">        <span class="tok-kw">try</span> copyJetpack(subfolder, file_tree, allocator);</span>
<span class="line" id="L1751">    }</span>
<span class="line" id="L1752"></span>
<span class="line" id="L1753">    <span class="tok-kw">for</span> (folder.files.items) |file| {</span>
<span class="line" id="L1754">        <span class="tok-kw">for</span> (file.ast.items) |*node| {</span>
<span class="line" id="L1755">            <span class="tok-kw">try</span> copyJetpackRecursivelyNode(node, file_tree, allocator);</span>
<span class="line" id="L1756">        }</span>
<span class="line" id="L1757">    }</span>
<span class="line" id="L1758">}</span>
<span class="line" id="L1759"></span>
<span class="line" id="L1760"><span class="tok-comment">// Looping back-to-front through every ACrab and AHuman Actor child node, if</span>
</span>
<span class="line" id="L1761"><span class="tok-comment">// 1. we first encounter the Actor containing any of the six Jetpack modifiers, and</span>
</span>
<span class="line" id="L1762"><span class="tok-comment">// 2. after that we encounter it CopyOfs an Actor that has a Jetpack with the value AEJetpack,</span>
</span>
<span class="line" id="L1763"><span class="tok-comment">// before our Actor has any &quot;Jetpack =&quot;, .insert() that Jetpack in our own Actor</span>
</span>
<span class="line" id="L1764"><span class="tok-comment">// directly after the CopyOf.</span>
</span>
<span class="line" id="L1765"><span class="tok-comment">// The CopyOf has to be searched recursively, since a copied Jetpack may be in a CopyOf of a CopyOf.</span>
</span>
<span class="line" id="L1766"><span class="tok-kw">fn</span> <span class="tok-fn">copyJetpackRecursivelyNode</span>(node: *Node, file_tree: *IniFolder, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1767">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L1768">        <span class="tok-kw">if</span> (isInsaneProperty(property)) {</span>
<span class="line" id="L1769">            <span class="tok-kw">if</span> (node.value) |value| {</span>
<span class="line" id="L1770">                <span class="tok-kw">if</span> (strEql(value, <span class="tok-str">&quot;ACrab&quot;</span>) <span class="tok-kw">or</span> strEql(value, <span class="tok-str">&quot;AHuman&quot;</span>)) {</span>
<span class="line" id="L1771">                    <span class="tok-kw">var</span> seen_jetpack_modifier = <span class="tok-null">false</span>;</span>
<span class="line" id="L1772">                    <span class="tok-kw">var</span> i = node.children.items.len;</span>
<span class="line" id="L1773">                    <span class="tok-kw">while</span> (i &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L1774">                        i -= <span class="tok-number">1</span>;</span>
<span class="line" id="L1775">                        <span class="tok-kw">const</span> child = node.children.items[i];</span>
<span class="line" id="L1776">                        <span class="tok-kw">if</span> (child.property) |child_property| {</span>
<span class="line" id="L1777">                            <span class="tok-kw">if</span> (strEql(child_property, <span class="tok-str">&quot;Jetpack&quot;</span>)) {</span>
<span class="line" id="L1778">                                <span class="tok-kw">break</span>;</span>
<span class="line" id="L1779">                            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (isJetpackModifier(child_property)) {</span>
<span class="line" id="L1780">                                seen_jetpack_modifier = <span class="tok-null">true</span>;</span>
<span class="line" id="L1781">                            } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (seen_jetpack_modifier <span class="tok-kw">and</span> strEql(child_property, <span class="tok-str">&quot;CopyOf&quot;</span>)) {</span>
<span class="line" id="L1782">                                <span class="tok-kw">if</span> (child.value) |preset_name| {</span>
<span class="line" id="L1783">                                    <span class="tok-kw">if</span> (findJetpackRecursivelyFolder(file_tree, file_tree, preset_name)) |jetpack| {</span>
<span class="line" id="L1784">                                        <span class="tok-kw">const</span> jetpack_deepcopy = <span class="tok-kw">try</span> deepCopyNode(jetpack, allocator);</span>
<span class="line" id="L1785">                                        <span class="tok-kw">try</span> node.children.insert(i + <span class="tok-number">1</span>, jetpack_deepcopy);</span>
<span class="line" id="L1786">                                        <span class="tok-kw">break</span>;</span>
<span class="line" id="L1787">                                    }</span>
<span class="line" id="L1788">                                }</span>
<span class="line" id="L1789">                            }</span>
<span class="line" id="L1790">                        }</span>
<span class="line" id="L1791">                    }</span>
<span class="line" id="L1792">                }</span>
<span class="line" id="L1793">            }</span>
<span class="line" id="L1794">        }</span>
<span class="line" id="L1795">    }</span>
<span class="line" id="L1796"></span>
<span class="line" id="L1797">    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L1798">        <span class="tok-kw">try</span> copyJetpackRecursivelyNode(child, file_tree, allocator);</span>
<span class="line" id="L1799">    }</span>
<span class="line" id="L1800">}</span>
<span class="line" id="L1801"></span>
<span class="line" id="L1802"><span class="tok-kw">fn</span> <span class="tok-fn">deepCopyNode</span>(input_node: *Node, allocator: Allocator) !Node {</span>
<span class="line" id="L1803">    <span class="tok-kw">var</span> returned_node = Node{</span>
<span class="line" id="L1804">        .property = <span class="tok-kw">if</span> (input_node.property) |property| <span class="tok-kw">try</span> allocator.dupe(<span class="tok-type">u8</span>, property) <span class="tok-kw">else</span> <span class="tok-null">null</span>,</span>
<span class="line" id="L1805">        .value = <span class="tok-kw">if</span> (input_node.value) |value| <span class="tok-kw">try</span> allocator.dupe(<span class="tok-type">u8</span>, value) <span class="tok-kw">else</span> <span class="tok-null">null</span>,</span>
<span class="line" id="L1806">        .comments = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(allocator),</span>
<span class="line" id="L1807">        .children = ArrayList(Node).init(allocator),</span>
<span class="line" id="L1808">    };</span>
<span class="line" id="L1809"></span>
<span class="line" id="L1810">    <span class="tok-kw">for</span> (input_node.comments.items) |comment| {</span>
<span class="line" id="L1811">        <span class="tok-kw">try</span> returned_node.comments.append(<span class="tok-kw">try</span> allocator.dupe(<span class="tok-type">u8</span>, comment));</span>
<span class="line" id="L1812">    }</span>
<span class="line" id="L1813"></span>
<span class="line" id="L1814">    <span class="tok-kw">for</span> (input_node.children.items) |*child| {</span>
<span class="line" id="L1815">        <span class="tok-kw">try</span> returned_node.children.append(<span class="tok-kw">try</span> deepCopyNode(child, allocator));</span>
<span class="line" id="L1816">    }</span>
<span class="line" id="L1817"></span>
<span class="line" id="L1818">    <span class="tok-kw">return</span> returned_node;</span>
<span class="line" id="L1819">}</span>
<span class="line" id="L1820"></span>
<span class="line" id="L1821"><span class="tok-kw">fn</span> <span class="tok-fn">removeJetpackModifiersFromActors</span>(folder: *IniFolder, file_tree: *IniFolder, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1822">    <span class="tok-kw">for</span> (folder.folders.items) |*subfolder| {</span>
<span class="line" id="L1823">        <span class="tok-kw">try</span> removeJetpackModifiersFromActors(subfolder, file_tree, allocator);</span>
<span class="line" id="L1824">    }</span>
<span class="line" id="L1825"></span>
<span class="line" id="L1826">    <span class="tok-kw">for</span> (folder.files.items) |file| {</span>
<span class="line" id="L1827">        <span class="tok-kw">for</span> (file.ast.items) |*node| {</span>
<span class="line" id="L1828">            <span class="tok-kw">try</span> removeJetpackModifiersFromActorsRecursivelyNode(node, file_tree, allocator);</span>
<span class="line" id="L1829">        }</span>
<span class="line" id="L1830">    }</span>
<span class="line" id="L1831">}</span>
<span class="line" id="L1832"></span>
<span class="line" id="L1833"><span class="tok-kw">fn</span> <span class="tok-fn">removeJetpackModifiersFromActorsRecursivelyNode</span>(node: *Node, file_tree: *IniFolder, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1834">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L1835">        <span class="tok-kw">if</span> (isInsaneProperty(property)) {</span>
<span class="line" id="L1836">            <span class="tok-kw">if</span> (node.value) |value| {</span>
<span class="line" id="L1837">                <span class="tok-kw">if</span> (strEql(value, <span class="tok-str">&quot;ACrab&quot;</span>) <span class="tok-kw">or</span> strEql(value, <span class="tok-str">&quot;AHuman&quot;</span>)) {</span>
<span class="line" id="L1838">                    <span class="tok-kw">var</span> i = node.children.items.len;</span>
<span class="line" id="L1839">                    <span class="tok-kw">while</span> (i &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L1840">                        i -= <span class="tok-number">1</span>;</span>
<span class="line" id="L1841">                        <span class="tok-kw">const</span> child = node.children.items[i];</span>
<span class="line" id="L1842">                        <span class="tok-kw">if</span> (child.property) |child_property| {</span>
<span class="line" id="L1843">                            <span class="tok-kw">if</span> (isJetpackModifier(child_property)) {</span>
<span class="line" id="L1844">                                _ = node.children.orderedRemove(i);</span>
<span class="line" id="L1845">                            }</span>
<span class="line" id="L1846">                        }</span>
<span class="line" id="L1847">                    }</span>
<span class="line" id="L1848">                }</span>
<span class="line" id="L1849">            }</span>
<span class="line" id="L1850">        }</span>
<span class="line" id="L1851">    }</span>
<span class="line" id="L1852"></span>
<span class="line" id="L1853">    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L1854">        <span class="tok-kw">try</span> removeJetpackModifiersFromActorsRecursivelyNode(child, file_tree, allocator);</span>
<span class="line" id="L1855">    }</span>
<span class="line" id="L1856">}</span>
<span class="line" id="L1857"></span>
<span class="line" id="L1858"><span class="tok-kw">fn</span> <span class="tok-fn">isJetpackModifier</span>(property: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) <span class="tok-type">bool</span> {</span>
<span class="line" id="L1859">    <span class="tok-kw">return</span> strEql(property, <span class="tok-str">&quot;JumpTime&quot;</span>) <span class="tok-kw">or</span> strEql(property, <span class="tok-str">&quot;JetTime&quot;</span>) <span class="tok-kw">or</span> strEql(property, <span class="tok-str">&quot;JumpReplenishRate&quot;</span>) <span class="tok-kw">or</span> strEql(property, <span class="tok-str">&quot;JetReplenishRate&quot;</span>) <span class="tok-kw">or</span> strEql(property, <span class="tok-str">&quot;JumpAngleRange&quot;</span>) <span class="tok-kw">or</span> strEql(property, <span class="tok-str">&quot;JetAngleRange&quot;</span>);</span>
<span class="line" id="L1860">}</span>
<span class="line" id="L1861"></span>
<span class="line" id="L1862"><span class="tok-kw">fn</span> <span class="tok-fn">findJetpackRecursivelyFolder</span>(folder: *IniFolder, file_tree: *IniFolder, preset_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?*Node {</span>
<span class="line" id="L1863">    <span class="tok-kw">for</span> (folder.folders.items) |*subfolder| {</span>
<span class="line" id="L1864">        <span class="tok-kw">if</span> (findJetpackRecursivelyFolder(subfolder, file_tree, preset_name)) |returned| {</span>
<span class="line" id="L1865">            <span class="tok-kw">return</span> returned;</span>
<span class="line" id="L1866">        }</span>
<span class="line" id="L1867">    }</span>
<span class="line" id="L1868"></span>
<span class="line" id="L1869">    <span class="tok-kw">for</span> (folder.files.items) |file| {</span>
<span class="line" id="L1870">        <span class="tok-kw">for</span> (file.ast.items) |*node| {</span>
<span class="line" id="L1871">            <span class="tok-kw">if</span> (findJetpackRecursivelyNode(node, file_tree, preset_name)) |returned| {</span>
<span class="line" id="L1872">                <span class="tok-kw">return</span> returned;</span>
<span class="line" id="L1873">            }</span>
<span class="line" id="L1874">        }</span>
<span class="line" id="L1875">    }</span>
<span class="line" id="L1876"></span>
<span class="line" id="L1877">    <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1878">}</span>
<span class="line" id="L1879"></span>
<span class="line" id="L1880"><span class="tok-kw">fn</span> <span class="tok-fn">findJetpackRecursivelyNode</span>(node: *Node, file_tree: *IniFolder, preset_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) ?*Node {</span>
<span class="line" id="L1881">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L1882">        <span class="tok-kw">if</span> (isInsaneProperty(property)) {</span>
<span class="line" id="L1883">            <span class="tok-kw">if</span> (node.value) |value| {</span>
<span class="line" id="L1884">                <span class="tok-kw">if</span> (strEql(value, <span class="tok-str">&quot;ACrab&quot;</span>) <span class="tok-kw">or</span> strEql(value, <span class="tok-str">&quot;AHuman&quot;</span>)) {</span>
<span class="line" id="L1885">                    <span class="tok-kw">var</span> found_searched_for_preset_name = <span class="tok-null">false</span>;</span>
<span class="line" id="L1886">                    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L1887">                        <span class="tok-kw">if</span> (child.property) |child_property| {</span>
<span class="line" id="L1888">                            <span class="tok-kw">if</span> (strEql(child_property, <span class="tok-str">&quot;PresetName&quot;</span>)) {</span>
<span class="line" id="L1889">                                <span class="tok-kw">if</span> (child.value) |child_value| {</span>
<span class="line" id="L1890">                                    <span class="tok-kw">if</span> (strEql(child_value, preset_name)) {</span>
<span class="line" id="L1891">                                        found_searched_for_preset_name = <span class="tok-null">true</span>;</span>
<span class="line" id="L1892">                                    }</span>
<span class="line" id="L1893">                                    <span class="tok-kw">break</span>;</span>
<span class="line" id="L1894">                                }</span>
<span class="line" id="L1895">                            }</span>
<span class="line" id="L1896">                        }</span>
<span class="line" id="L1897">                    }</span>
<span class="line" id="L1898"></span>
<span class="line" id="L1899">                    <span class="tok-kw">if</span> (found_searched_for_preset_name) {</span>
<span class="line" id="L1900">                        <span class="tok-kw">var</span> i = node.children.items.len;</span>
<span class="line" id="L1901">                        <span class="tok-kw">while</span> (i &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L1902">                            i -= <span class="tok-number">1</span>;</span>
<span class="line" id="L1903">                            <span class="tok-kw">const</span> child = &amp;node.children.items[i];</span>
<span class="line" id="L1904">                            <span class="tok-kw">if</span> (child.property) |child_property| {</span>
<span class="line" id="L1905">                                <span class="tok-kw">if</span> (strEql(child_property, <span class="tok-str">&quot;Jetpack&quot;</span>)) {</span>
<span class="line" id="L1906">                                    <span class="tok-kw">if</span> (child.value) |child_value| {</span>
<span class="line" id="L1907">                                        <span class="tok-kw">if</span> (strEql(child_value, <span class="tok-str">&quot;AEJetpack&quot;</span>)) {</span>
<span class="line" id="L1908">                                            <span class="tok-kw">return</span> child;</span>
<span class="line" id="L1909">                                        }</span>
<span class="line" id="L1910">                                    }</span>
<span class="line" id="L1911">                                } <span class="tok-kw">else</span> <span class="tok-kw">if</span> (strEql(child_property, <span class="tok-str">&quot;CopyOf&quot;</span>)) {</span>
<span class="line" id="L1912">                                    <span class="tok-kw">if</span> (child.value) |child_preset_name| {</span>
<span class="line" id="L1913">                                        <span class="tok-kw">return</span> findJetpackRecursivelyFolder(file_tree, file_tree, child_preset_name);</span>
<span class="line" id="L1914">                                    }</span>
<span class="line" id="L1915">                                }</span>
<span class="line" id="L1916">                            }</span>
<span class="line" id="L1917">                        }</span>
<span class="line" id="L1918">                    }</span>
<span class="line" id="L1919">                }</span>
<span class="line" id="L1920">            }</span>
<span class="line" id="L1921">        }</span>
<span class="line" id="L1922">    }</span>
<span class="line" id="L1923"></span>
<span class="line" id="L1924">    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L1925">        <span class="tok-kw">if</span> (findJetpackRecursivelyNode(child, file_tree, preset_name)) |returned| {</span>
<span class="line" id="L1926">            <span class="tok-kw">return</span> returned;</span>
<span class="line" id="L1927">        }</span>
<span class="line" id="L1928">    }</span>
<span class="line" id="L1929"></span>
<span class="line" id="L1930">    <span class="tok-kw">return</span> <span class="tok-null">null</span>;</span>
<span class="line" id="L1931">}</span>
<span class="line" id="L1932"></span>
<span class="line" id="L1933"><span class="tok-kw">fn</span> <span class="tok-fn">maxLengthToOffsets</span>(node: *Node, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1934">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L1935">        <span class="tok-kw">if</span> (isInsaneProperty(property)) {</span>
<span class="line" id="L1936">            <span class="tok-kw">if</span> (node.value) |value| {</span>
<span class="line" id="L1937">                <span class="tok-kw">if</span> (strEql(value, <span class="tok-str">&quot;Leg&quot;</span>)) {</span>
<span class="line" id="L1938">                    <span class="tok-kw">var</span> children = &amp;node.children;</span>
<span class="line" id="L1939"></span>
<span class="line" id="L1940">                    <span class="tok-kw">for</span> (children.items) |*child| {</span>
<span class="line" id="L1941">                        <span class="tok-kw">if</span> (child.property) |child_property| {</span>
<span class="line" id="L1942">                            <span class="tok-kw">if</span> (strEql(child_property, <span class="tok-str">&quot;MaxLength&quot;</span>)) {</span>
<span class="line" id="L1943">                                <span class="tok-kw">if</span> (child.value) |child_value| {</span>
<span class="line" id="L1944">                                    child.property = <span class="tok-str">&quot;ContractedOffset&quot;</span>;</span>
<span class="line" id="L1945">                                    child.value = <span class="tok-str">&quot;Vector&quot;</span>;</span>
<span class="line" id="L1946">                                    <span class="tok-kw">try</span> child.children.append(Node{</span>
<span class="line" id="L1947">                                        .property = <span class="tok-str">&quot;X&quot;</span>,</span>
<span class="line" id="L1948">                                        .value = <span class="tok-kw">try</span> allocPrint(allocator, <span class="tok-str">&quot;{d}&quot;</span>, .{<span class="tok-kw">try</span> parseFloat(<span class="tok-type">f32</span>, child_value) / <span class="tok-number">2</span>}),</span>
<span class="line" id="L1949">                                        .comments = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(allocator),</span>
<span class="line" id="L1950">                                        .children = ArrayList(Node).init(allocator),</span>
<span class="line" id="L1951">                                    });</span>
<span class="line" id="L1952">                                    <span class="tok-kw">try</span> child.children.append(Node{</span>
<span class="line" id="L1953">                                        .property = <span class="tok-str">&quot;Y&quot;</span>,</span>
<span class="line" id="L1954">                                        .value = <span class="tok-str">&quot;0&quot;</span>,</span>
<span class="line" id="L1955">                                        .comments = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(allocator),</span>
<span class="line" id="L1956">                                        .children = ArrayList(Node).init(allocator),</span>
<span class="line" id="L1957">                                    });</span>
<span class="line" id="L1958"></span>
<span class="line" id="L1959">                                    <span class="tok-kw">var</span> extended_offset = Node{</span>
<span class="line" id="L1960">                                        .property = <span class="tok-str">&quot;ExtendedOffset&quot;</span>,</span>
<span class="line" id="L1961">                                        .value = <span class="tok-str">&quot;Vector&quot;</span>,</span>
<span class="line" id="L1962">                                        .comments = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(allocator),</span>
<span class="line" id="L1963">                                        .children = ArrayList(Node).init(allocator),</span>
<span class="line" id="L1964">                                    };</span>
<span class="line" id="L1965">                                    <span class="tok-kw">try</span> extended_offset.children.append(Node{</span>
<span class="line" id="L1966">                                        .property = <span class="tok-str">&quot;X&quot;</span>,</span>
<span class="line" id="L1967">                                        .value = child_value,</span>
<span class="line" id="L1968">                                        .comments = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(allocator),</span>
<span class="line" id="L1969">                                        .children = ArrayList(Node).init(allocator),</span>
<span class="line" id="L1970">                                    });</span>
<span class="line" id="L1971">                                    <span class="tok-kw">try</span> extended_offset.children.append(Node{</span>
<span class="line" id="L1972">                                        .property = <span class="tok-str">&quot;Y&quot;</span>,</span>
<span class="line" id="L1973">                                        .value = <span class="tok-str">&quot;0&quot;</span>,</span>
<span class="line" id="L1974">                                        .comments = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(allocator),</span>
<span class="line" id="L1975">                                        .children = ArrayList(Node).init(allocator),</span>
<span class="line" id="L1976">                                    });</span>
<span class="line" id="L1977">                                    <span class="tok-kw">try</span> children.append(extended_offset);</span>
<span class="line" id="L1978">                                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L1979">                                    <span class="tok-kw">return</span> UpdateIniFileTreeErrors.ExpectedValue;</span>
<span class="line" id="L1980">                                }</span>
<span class="line" id="L1981">                            }</span>
<span class="line" id="L1982">                        }</span>
<span class="line" id="L1983">                    }</span>
<span class="line" id="L1984">                }</span>
<span class="line" id="L1985">            }</span>
<span class="line" id="L1986">        }</span>
<span class="line" id="L1987">    }</span>
<span class="line" id="L1988">}</span>
<span class="line" id="L1989"></span>
<span class="line" id="L1990"><span class="tok-kw">fn</span> <span class="tok-fn">maxMassToMaxInventoryMass</span>(node: *Node, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L1991">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L1992">        <span class="tok-kw">if</span> (isInsaneProperty(property)) {</span>
<span class="line" id="L1993">            <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L1994">                <span class="tok-kw">if</span> (child.property) |child_property| {</span>
<span class="line" id="L1995">                    <span class="tok-kw">if</span> (strEql(child_property, <span class="tok-str">&quot;MaxMass&quot;</span>)) {</span>
<span class="line" id="L1996">                        <span class="tok-kw">if</span> (child.value) |v| {</span>
<span class="line" id="L1997">                            <span class="tok-kw">const</span> max_mass = <span class="tok-kw">try</span> parseFloat(<span class="tok-type">f32</span>, v);</span>
<span class="line" id="L1998"></span>
<span class="line" id="L1999">                            <span class="tok-kw">for</span> (node.children.items) |child2| {</span>
<span class="line" id="L2000">                                <span class="tok-kw">if</span> (child2.property) |child_property2| {</span>
<span class="line" id="L2001">                                    <span class="tok-kw">if</span> (strEql(child_property2, <span class="tok-str">&quot;Mass&quot;</span>)) {</span>
<span class="line" id="L2002">                                        <span class="tok-kw">if</span> (child2.value) |v2| {</span>
<span class="line" id="L2003">                                            child.property = <span class="tok-str">&quot;MaxInventoryMass&quot;</span>;</span>
<span class="line" id="L2004"></span>
<span class="line" id="L2005">                                            <span class="tok-kw">const</span> mass = <span class="tok-kw">try</span> parseFloat(<span class="tok-type">f32</span>, v2);</span>
<span class="line" id="L2006">                                            <span class="tok-kw">const</span> max_inventory_mass = max_mass - mass;</span>
<span class="line" id="L2007">                                            child.value = <span class="tok-kw">try</span> allocPrint(allocator, <span class="tok-str">&quot;{d}&quot;</span>, .{max_inventory_mass});</span>
<span class="line" id="L2008">                                        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2009">                                            <span class="tok-kw">return</span> UpdateIniFileTreeErrors.ExpectedValue;</span>
<span class="line" id="L2010">                                        }</span>
<span class="line" id="L2011">                                    }</span>
<span class="line" id="L2012">                                }</span>
<span class="line" id="L2013">                            }</span>
<span class="line" id="L2014">                        } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2015">                            <span class="tok-kw">return</span> UpdateIniFileTreeErrors.ExpectedValue;</span>
<span class="line" id="L2016">                        }</span>
<span class="line" id="L2017">                    }</span>
<span class="line" id="L2018">                }</span>
<span class="line" id="L2019">            }</span>
<span class="line" id="L2020">        }</span>
<span class="line" id="L2021">    }</span>
<span class="line" id="L2022">}</span>
<span class="line" id="L2023"></span>
<span class="line" id="L2024"><span class="tok-kw">fn</span> <span class="tok-fn">maxThrottleRangeToPositiveThrottleMultiplier</span>(node: *Node, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2025">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L2026">        <span class="tok-kw">if</span> (strEql(property, <span class="tok-str">&quot;MaxThrottleRange&quot;</span>)) {</span>
<span class="line" id="L2027">            node.property = <span class="tok-str">&quot;PositiveThrottleMultiplier&quot;</span>;</span>
<span class="line" id="L2028">            <span class="tok-kw">if</span> (node.value) |v| {</span>
<span class="line" id="L2029">                <span class="tok-kw">const</span> old_value = <span class="tok-kw">try</span> parseFloat(<span class="tok-type">f32</span>, v);</span>
<span class="line" id="L2030">                <span class="tok-kw">const</span> new_value = fabs(<span class="tok-number">1</span> + fabs(old_value));</span>
<span class="line" id="L2031">                node.value = <span class="tok-kw">try</span> allocPrint(allocator, <span class="tok-str">&quot;{d}&quot;</span>, .{new_value});</span>
<span class="line" id="L2032">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2033">                <span class="tok-kw">return</span> UpdateIniFileTreeErrors.ExpectedValue;</span>
<span class="line" id="L2034">            }</span>
<span class="line" id="L2035">        }</span>
<span class="line" id="L2036">    }</span>
<span class="line" id="L2037">}</span>
<span class="line" id="L2038"></span>
<span class="line" id="L2039"><span class="tok-kw">fn</span> <span class="tok-fn">minThrottleRangeToNegativeThrottleMultiplier</span>(node: *Node, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2040">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L2041">        <span class="tok-kw">if</span> (strEql(property, <span class="tok-str">&quot;MinThrottleRange&quot;</span>)) {</span>
<span class="line" id="L2042">            node.property = <span class="tok-str">&quot;NegativeThrottleMultiplier&quot;</span>;</span>
<span class="line" id="L2043">            <span class="tok-kw">if</span> (node.value) |v| {</span>
<span class="line" id="L2044">                <span class="tok-kw">const</span> old_value = <span class="tok-kw">try</span> parseFloat(<span class="tok-type">f32</span>, v);</span>
<span class="line" id="L2045">                <span class="tok-kw">const</span> new_value = fabs(<span class="tok-number">1</span> - fabs(old_value));</span>
<span class="line" id="L2046">                node.value = <span class="tok-kw">try</span> allocPrint(allocator, <span class="tok-str">&quot;{d}&quot;</span>, .{new_value});</span>
<span class="line" id="L2047">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2048">                <span class="tok-kw">return</span> UpdateIniFileTreeErrors.ExpectedValue;</span>
<span class="line" id="L2049">            }</span>
<span class="line" id="L2050">        }</span>
<span class="line" id="L2051">    }</span>
<span class="line" id="L2052">}</span>
<span class="line" id="L2053"></span>
<span class="line" id="L2054"><span class="tok-kw">fn</span> <span class="tok-fn">pieMenu</span>(actor_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, default_copy_of_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, starting_direction_count_up: <span class="tok-type">u32</span>, starting_direction_count_down: <span class="tok-type">u32</span>, starting_direction_count_left: <span class="tok-type">u32</span>, starting_direction_count_right: <span class="tok-type">u32</span>, file_tree: *IniFolder, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2055">    <span class="tok-kw">for</span> (file_tree.folders.items) |*folder| {</span>
<span class="line" id="L2056">        <span class="tok-kw">try</span> pieMenu(actor_name, default_copy_of_name, starting_direction_count_up, starting_direction_count_down, starting_direction_count_left, starting_direction_count_right, folder, allocator);</span>
<span class="line" id="L2057">    }</span>
<span class="line" id="L2058"></span>
<span class="line" id="L2059">    <span class="tok-kw">for</span> (file_tree.files.items) |file| {</span>
<span class="line" id="L2060">        <span class="tok-kw">for</span> (file.ast.items) |*node| {</span>
<span class="line" id="L2061">            <span class="tok-kw">try</span> pieMenuRecursivelyNode(node, actor_name, default_copy_of_name, starting_direction_count_up, starting_direction_count_down, starting_direction_count_left, starting_direction_count_right, allocator);</span>
<span class="line" id="L2062">        }</span>
<span class="line" id="L2063">    }</span>
<span class="line" id="L2064">}</span>
<span class="line" id="L2065"></span>
<span class="line" id="L2066"><span class="tok-kw">fn</span> <span class="tok-fn">pieMenuRecursivelyNode</span>(node: *Node, actor_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, default_copy_of_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, starting_direction_count_up: <span class="tok-type">u32</span>, starting_direction_count_down: <span class="tok-type">u32</span>, starting_direction_count_left: <span class="tok-type">u32</span>, starting_direction_count_right: <span class="tok-type">u32</span>, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2067">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L2068">        <span class="tok-kw">if</span> (isInsaneProperty(property)) {</span>
<span class="line" id="L2069">            <span class="tok-kw">if</span> (node.value) |value| {</span>
<span class="line" id="L2070">                <span class="tok-kw">if</span> (strEql(value, actor_name)) {</span>
<span class="line" id="L2071">                    <span class="tok-kw">var</span> children = &amp;node.children;</span>
<span class="line" id="L2072"></span>
<span class="line" id="L2073">                    <span class="tok-kw">var</span> contains_pie_slice = <span class="tok-null">false</span>;</span>
<span class="line" id="L2074">                    <span class="tok-kw">for</span> (children.items) |*child| {</span>
<span class="line" id="L2075">                        <span class="tok-kw">if</span> (child.property) |child_property| {</span>
<span class="line" id="L2076">                            <span class="tok-kw">if</span> (strEql(child_property, <span class="tok-str">&quot;AddPieSlice&quot;</span>)) {</span>
<span class="line" id="L2077">                                <span class="tok-kw">if</span> (child.value) |child_value| {</span>
<span class="line" id="L2078">                                    <span class="tok-kw">if</span> (strEql(child_value, <span class="tok-str">&quot;PieSlice&quot;</span>)) {</span>
<span class="line" id="L2079">                                        contains_pie_slice = <span class="tok-null">true</span>;</span>
<span class="line" id="L2080">                                    }</span>
<span class="line" id="L2081">                                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2082">                                    <span class="tok-kw">return</span> UpdateIniFileTreeErrors.ExpectedValue;</span>
<span class="line" id="L2083">                                }</span>
<span class="line" id="L2084">                            }</span>
<span class="line" id="L2085">                        }</span>
<span class="line" id="L2086">                    }</span>
<span class="line" id="L2087"></span>
<span class="line" id="L2088">                    <span class="tok-kw">if</span> (contains_pie_slice) {</span>
<span class="line" id="L2089">                        <span class="tok-kw">var</span> pie_menu = Node{</span>
<span class="line" id="L2090">                            .property = <span class="tok-str">&quot;PieMenu&quot;</span>,</span>
<span class="line" id="L2091">                            .value = <span class="tok-str">&quot;PieMenu&quot;</span>,</span>
<span class="line" id="L2092">                            .comments = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(allocator),</span>
<span class="line" id="L2093">                            .children = ArrayList(Node).init(allocator),</span>
<span class="line" id="L2094">                        };</span>
<span class="line" id="L2095"></span>
<span class="line" id="L2096">                        <span class="tok-kw">try</span> pie_menu.children.append(Node{</span>
<span class="line" id="L2097">                            .property = <span class="tok-str">&quot;CopyOf&quot;</span>,</span>
<span class="line" id="L2098">                            .value = default_copy_of_name,</span>
<span class="line" id="L2099">                            .comments = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(allocator),</span>
<span class="line" id="L2100">                            .children = ArrayList(Node).init(allocator),</span>
<span class="line" id="L2101">                        });</span>
<span class="line" id="L2102"></span>
<span class="line" id="L2103">                        <span class="tok-kw">for</span> (children.items) |*child| {</span>
<span class="line" id="L2104">                            <span class="tok-kw">if</span> (child.property) |child_property| {</span>
<span class="line" id="L2105">                                <span class="tok-kw">if</span> (strEql(child_property, <span class="tok-str">&quot;AddPieSlice&quot;</span>)) {</span>
<span class="line" id="L2106">                                    <span class="tok-kw">if</span> (child.value) |child_value| {</span>
<span class="line" id="L2107">                                        <span class="tok-kw">if</span> (strEql(child_value, <span class="tok-str">&quot;PieSlice&quot;</span>)) {</span>
<span class="line" id="L2108">                                            <span class="tok-comment">// Make a copy of the PieSlice in the PieMenu</span>
</span>
<span class="line" id="L2109">                                            <span class="tok-kw">try</span> pie_menu.children.append(Node{</span>
<span class="line" id="L2110">                                                .property = <span class="tok-str">&quot;AddPieSlice&quot;</span>,</span>
<span class="line" id="L2111">                                                .value = <span class="tok-str">&quot;PieSlice&quot;</span>,</span>
<span class="line" id="L2112">                                                .comments = child.comments,</span>
<span class="line" id="L2113">                                                .children = child.children,</span>
<span class="line" id="L2114">                                            });</span>
<span class="line" id="L2115"></span>
<span class="line" id="L2116">                                            <span class="tok-comment">// Remove the PieSlice from the root of the Actor</span>
</span>
<span class="line" id="L2117">                                            child.property = <span class="tok-null">null</span>;</span>
<span class="line" id="L2118">                                            child.value = <span class="tok-null">null</span>;</span>
<span class="line" id="L2119">                                            child.comments = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(allocator);</span>
<span class="line" id="L2120">                                            child.children = ArrayList(Node).init(allocator);</span>
<span class="line" id="L2121">                                        }</span>
<span class="line" id="L2122">                                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2123">                                        <span class="tok-kw">return</span> UpdateIniFileTreeErrors.ExpectedValue;</span>
<span class="line" id="L2124">                                    }</span>
<span class="line" id="L2125">                                }</span>
<span class="line" id="L2126">                            }</span>
<span class="line" id="L2127">                        }</span>
<span class="line" id="L2128"></span>
<span class="line" id="L2129">                        <span class="tok-kw">try</span> applyPieQuadrantSlotLimit(&amp;pie_menu, <span class="tok-str">&quot;Up&quot;</span>, starting_direction_count_up);</span>
<span class="line" id="L2130">                        <span class="tok-kw">try</span> applyPieQuadrantSlotLimit(&amp;pie_menu, <span class="tok-str">&quot;Down&quot;</span>, starting_direction_count_down);</span>
<span class="line" id="L2131">                        <span class="tok-kw">try</span> applyPieQuadrantSlotLimit(&amp;pie_menu, <span class="tok-str">&quot;Left&quot;</span>, starting_direction_count_left);</span>
<span class="line" id="L2132">                        <span class="tok-kw">try</span> applyPieQuadrantSlotLimit(&amp;pie_menu, <span class="tok-str">&quot;Right&quot;</span>, starting_direction_count_right);</span>
<span class="line" id="L2133"></span>
<span class="line" id="L2134">                        <span class="tok-kw">try</span> children.append(pie_menu);</span>
<span class="line" id="L2135">                    }</span>
<span class="line" id="L2136">                }</span>
<span class="line" id="L2137">            }</span>
<span class="line" id="L2138">        }</span>
<span class="line" id="L2139">    }</span>
<span class="line" id="L2140"></span>
<span class="line" id="L2141">    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L2142">        <span class="tok-kw">try</span> pieMenuRecursivelyNode(child, actor_name, default_copy_of_name, starting_direction_count_up, starting_direction_count_down, starting_direction_count_left, starting_direction_count_right, allocator);</span>
<span class="line" id="L2143">    }</span>
<span class="line" id="L2144">}</span>
<span class="line" id="L2145"></span>
<span class="line" id="L2146"><span class="tok-kw">fn</span> <span class="tok-fn">applyPieQuadrantSlotLimit</span>(pie_menu: *Node, direction: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, starting_direction_count: <span class="tok-type">u32</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2147">    <span class="tok-kw">var</span> direction_count = starting_direction_count;</span>
<span class="line" id="L2148"></span>
<span class="line" id="L2149">    <span class="tok-comment">// From the Source repo in System/PieQuadrant.h, under the name c_PieQuadrantSlotCount</span>
</span>
<span class="line" id="L2150">    <span class="tok-kw">const</span> PieQuadrantSlotCount = <span class="tok-number">5</span>;</span>
<span class="line" id="L2151"></span>
<span class="line" id="L2152">    <span class="tok-kw">for</span> (pie_menu.children.items) |menu_child| {</span>
<span class="line" id="L2153">        <span class="tok-kw">if</span> (menu_child.property) |meny_child_property| {</span>
<span class="line" id="L2154">            <span class="tok-kw">if</span> (strEql(meny_child_property, <span class="tok-str">&quot;AddPieSlice&quot;</span>)) {</span>
<span class="line" id="L2155">                <span class="tok-kw">if</span> (menu_child.value) |value| {</span>
<span class="line" id="L2156">                    <span class="tok-kw">if</span> (strEql(value, <span class="tok-str">&quot;PieSlice&quot;</span>)) {</span>
<span class="line" id="L2157">                        <span class="tok-kw">for</span> (menu_child.children.items) |*slice_child| {</span>
<span class="line" id="L2158">                            <span class="tok-kw">if</span> (slice_child.property) |slice_child_property| {</span>
<span class="line" id="L2159">                                <span class="tok-kw">if</span> (strEql(slice_child_property, <span class="tok-str">&quot;Direction&quot;</span>)) {</span>
<span class="line" id="L2160">                                    <span class="tok-kw">if</span> (slice_child.value) |slice_child_value| {</span>
<span class="line" id="L2161">                                        <span class="tok-kw">if</span> (strEql(slice_child_value, direction)) {</span>
<span class="line" id="L2162">                                            <span class="tok-kw">if</span> (direction_count == PieQuadrantSlotCount) {</span>
<span class="line" id="L2163">                                                slice_child.value = <span class="tok-str">&quot;Any&quot;</span>;</span>
<span class="line" id="L2164">                                            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2165">                                                direction_count += <span class="tok-number">1</span>;</span>
<span class="line" id="L2166">                                            }</span>
<span class="line" id="L2167">                                        }</span>
<span class="line" id="L2168">                                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2169">                                        <span class="tok-kw">return</span> UpdateIniFileTreeErrors.ExpectedValue;</span>
<span class="line" id="L2170">                                    }</span>
<span class="line" id="L2171">                                }</span>
<span class="line" id="L2172">                            }</span>
<span class="line" id="L2173">                        }</span>
<span class="line" id="L2174">                    }</span>
<span class="line" id="L2175">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2176">                    <span class="tok-kw">return</span> UpdateIniFileTreeErrors.ExpectedValue;</span>
<span class="line" id="L2177">                }</span>
<span class="line" id="L2178">            }</span>
<span class="line" id="L2179">        }</span>
<span class="line" id="L2180">    }</span>
<span class="line" id="L2181">}</span>
<span class="line" id="L2182"></span>
<span class="line" id="L2183"><span class="tok-kw">fn</span> <span class="tok-fn">removeSlTerrainProperties</span>(node: *Node, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2184">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L2185">        <span class="tok-kw">if</span> (strEql(property, <span class="tok-str">&quot;Terrain&quot;</span>) <span class="tok-kw">or</span> strEql(property, <span class="tok-str">&quot;AddTerrain&quot;</span>)) {</span>
<span class="line" id="L2186">            <span class="tok-kw">if</span> (node.value) |value| {</span>
<span class="line" id="L2187">                <span class="tok-kw">if</span> (strEql(value, <span class="tok-str">&quot;SLTerrain&quot;</span>)) {</span>
<span class="line" id="L2188">                    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L2189">                        <span class="tok-kw">if</span> (child.property) |child_property| {</span>
<span class="line" id="L2190">                            <span class="tok-comment">// Remove DrawTransparent from the Terrain</span>
</span>
<span class="line" id="L2191">                            <span class="tok-kw">if</span> (strEql(child_property, <span class="tok-str">&quot;DrawTransparent&quot;</span>)) {</span>
<span class="line" id="L2192">                                child.property = <span class="tok-null">null</span>;</span>
<span class="line" id="L2193">                                child.value = <span class="tok-null">null</span>;</span>
<span class="line" id="L2194">                                child.comments = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(allocator);</span>
<span class="line" id="L2195">                                child.children = ArrayList(Node).init(allocator);</span>
<span class="line" id="L2196">                            }</span>
<span class="line" id="L2197"></span>
<span class="line" id="L2198">                            <span class="tok-comment">// Remove Offset and ScrollRatio and ScaleFactor from the Terrain</span>
</span>
<span class="line" id="L2199">                            <span class="tok-kw">if</span> (strEql(child_property, <span class="tok-str">&quot;Offset&quot;</span>) <span class="tok-kw">or</span> strEql(child_property, <span class="tok-str">&quot;ScrollRatio&quot;</span>) <span class="tok-kw">or</span> strEql(child_property, <span class="tok-str">&quot;ScaleFactor&quot;</span>)) {</span>
<span class="line" id="L2200">                                <span class="tok-kw">if</span> (child.value) |child_value| {</span>
<span class="line" id="L2201">                                    <span class="tok-kw">if</span> (strEql(child_value, <span class="tok-str">&quot;Vector&quot;</span>)) {</span>
<span class="line" id="L2202">                                        child.property = <span class="tok-null">null</span>;</span>
<span class="line" id="L2203">                                        child.value = <span class="tok-null">null</span>;</span>
<span class="line" id="L2204">                                        child.comments = ArrayList([]<span class="tok-kw">const</span> <span class="tok-type">u8</span>).init(allocator);</span>
<span class="line" id="L2205">                                        child.children = ArrayList(Node).init(allocator);</span>
<span class="line" id="L2206">                                    }</span>
<span class="line" id="L2207">                                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2208">                                    <span class="tok-kw">return</span> UpdateIniFileTreeErrors.ExpectedValue;</span>
<span class="line" id="L2209">                                }</span>
<span class="line" id="L2210">                            }</span>
<span class="line" id="L2211">                        }</span>
<span class="line" id="L2212">                    }</span>
<span class="line" id="L2213">                }</span>
<span class="line" id="L2214">            }</span>
<span class="line" id="L2215">        }</span>
<span class="line" id="L2216">    }</span>
<span class="line" id="L2217">}</span>
<span class="line" id="L2218"></span>
<span class="line" id="L2219"><span class="tok-kw">fn</span> <span class="tok-fn">shovelFlashFix</span>(node: *Node) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2220">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L2221">        <span class="tok-kw">if</span> (isInsaneProperty(property)) {</span>
<span class="line" id="L2222">            <span class="tok-kw">if</span> (node.value) |value| {</span>
<span class="line" id="L2223">                <span class="tok-kw">if</span> (strEql(value, <span class="tok-str">&quot;HDFirearm&quot;</span>)) {</span>
<span class="line" id="L2224">                    <span class="tok-kw">var</span> changed_shovel_sprite = <span class="tok-null">false</span>;</span>
<span class="line" id="L2225"></span>
<span class="line" id="L2226">                    <span class="tok-kw">for</span> (node.children.items) |firearm_child| {</span>
<span class="line" id="L2227">                        <span class="tok-kw">if</span> (firearm_child.property) |firearm_child_property| {</span>
<span class="line" id="L2228">                            <span class="tok-kw">if</span> (strEql(firearm_child_property, <span class="tok-str">&quot;SpriteFile&quot;</span>)) {</span>
<span class="line" id="L2229">                                <span class="tok-kw">if</span> (firearm_child.value) |firearm_child_value| {</span>
<span class="line" id="L2230">                                    <span class="tok-kw">if</span> (strEql(firearm_child_value, <span class="tok-str">&quot;ContentFile&quot;</span>)) {</span>
<span class="line" id="L2231">                                        <span class="tok-kw">for</span> (firearm_child.children.items) |*content_file_child| {</span>
<span class="line" id="L2232">                                            <span class="tok-kw">if</span> (content_file_child.property) |content_file_child_property| {</span>
<span class="line" id="L2233">                                                <span class="tok-kw">if</span> (strEql(content_file_child_property, <span class="tok-str">&quot;FilePath&quot;</span>)) {</span>
<span class="line" id="L2234">                                                    <span class="tok-kw">if</span> (content_file_child.value) |content_file_child_value| {</span>
<span class="line" id="L2235">                                                        <span class="tok-kw">if</span> (strEql(content_file_child_value, <span class="tok-str">&quot;Ronin.rte/Effects/Pyro/Flashes/ShovelFlash.png&quot;</span>)) {</span>
<span class="line" id="L2236">                                                            content_file_child.value = <span class="tok-str">&quot;Ronin.rte/Devices/Tools/Shovel/Effects/ShovelFlash.png&quot;</span>;</span>
<span class="line" id="L2237"></span>
<span class="line" id="L2238">                                                            changed_shovel_sprite = <span class="tok-null">true</span>;</span>
<span class="line" id="L2239">                                                        }</span>
<span class="line" id="L2240">                                                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2241">                                                        <span class="tok-kw">return</span> UpdateIniFileTreeErrors.ExpectedValue;</span>
<span class="line" id="L2242">                                                    }</span>
<span class="line" id="L2243">                                                }</span>
<span class="line" id="L2244">                                            }</span>
<span class="line" id="L2245">                                        }</span>
<span class="line" id="L2246">                                    }</span>
<span class="line" id="L2247">                                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2248">                                    <span class="tok-kw">return</span> UpdateIniFileTreeErrors.ExpectedValue;</span>
<span class="line" id="L2249">                                }</span>
<span class="line" id="L2250">                            }</span>
<span class="line" id="L2251">                        }</span>
<span class="line" id="L2252">                    }</span>
<span class="line" id="L2253"></span>
<span class="line" id="L2254">                    <span class="tok-kw">if</span> (changed_shovel_sprite) {</span>
<span class="line" id="L2255">                        <span class="tok-kw">for</span> (node.children.items) |*firearm_child| {</span>
<span class="line" id="L2256">                            <span class="tok-kw">if</span> (firearm_child.property) |firearm_child_property| {</span>
<span class="line" id="L2257">                                <span class="tok-kw">if</span> (strEql(firearm_child_property, <span class="tok-str">&quot;FrameCount&quot;</span>)) {</span>
<span class="line" id="L2258">                                    <span class="tok-kw">if</span> (firearm_child.value) |firearm_child_value| {</span>
<span class="line" id="L2259">                                        <span class="tok-kw">if</span> (strEql(firearm_child_value, <span class="tok-str">&quot;2&quot;</span>)) {</span>
<span class="line" id="L2260">                                            firearm_child.value = <span class="tok-str">&quot;1&quot;</span>;</span>
<span class="line" id="L2261">                                        }</span>
<span class="line" id="L2262">                                    } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2263">                                        <span class="tok-kw">return</span> UpdateIniFileTreeErrors.ExpectedValue;</span>
<span class="line" id="L2264">                                    }</span>
<span class="line" id="L2265">                                }</span>
<span class="line" id="L2266">                            }</span>
<span class="line" id="L2267">                        }</span>
<span class="line" id="L2268">                    }</span>
<span class="line" id="L2269">                }</span>
<span class="line" id="L2270">            }</span>
<span class="line" id="L2271">        }</span>
<span class="line" id="L2272">    }</span>
<span class="line" id="L2273">}</span>
<span class="line" id="L2274"></span>
<span class="line" id="L2275"><span class="tok-kw">fn</span> <span class="tok-fn">writeIniFileTree</span>(file_tree: *<span class="tok-kw">const</span> IniFolder, output_folder_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2276">    <span class="tok-kw">for</span> (file_tree.files.items) |file| {</span>
<span class="line" id="L2277">        <span class="tok-kw">const</span> file_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ output_folder_path, file.name });</span>
<span class="line" id="L2278">        <span class="tok-kw">try</span> writeAst(&amp;file.ast, file_path);</span>
<span class="line" id="L2279">    }</span>
<span class="line" id="L2280"></span>
<span class="line" id="L2281">    <span class="tok-kw">for</span> (file_tree.folders.items) |folder| {</span>
<span class="line" id="L2282">        <span class="tok-kw">const</span> child_output_folder_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ output_folder_path, folder.name });</span>
<span class="line" id="L2283">        <span class="tok-kw">try</span> writeIniFileTree(&amp;folder, child_output_folder_path, allocator);</span>
<span class="line" id="L2284">    }</span>
<span class="line" id="L2285">}</span>
<span class="line" id="L2286"></span>
<span class="line" id="L2287"><span class="tok-kw">fn</span> <span class="tok-fn">writeAst</span>(ast: *<span class="tok-kw">const</span> ArrayList(Node), output_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2288">    <span class="tok-kw">const</span> output_file = <span class="tok-kw">try</span> std.fs.cwd().createFile(output_path, .{});</span>
<span class="line" id="L2289">    <span class="tok-kw">defer</span> output_file.close();</span>
<span class="line" id="L2290"></span>
<span class="line" id="L2291">    <span class="tok-kw">var</span> buffered = bufferedWriter(output_file.writer());</span>
<span class="line" id="L2292">    <span class="tok-kw">const</span> buffered_writer = buffered.writer();</span>
<span class="line" id="L2293"></span>
<span class="line" id="L2294">    <span class="tok-kw">for</span> (ast.items, <span class="tok-number">0</span>..) |*node, index| {</span>
<span class="line" id="L2295">        <span class="tok-kw">try</span> writeAstRecursively(node, buffered_writer, <span class="tok-number">0</span>);</span>
<span class="line" id="L2296"></span>
<span class="line" id="L2297">        <span class="tok-comment">// Don't add a trailing newline,</span>
</span>
<span class="line" id="L2298">        <span class="tok-comment">// since writeAstRecursively() already adds it</span>
</span>
<span class="line" id="L2299">        <span class="tok-kw">if</span> (node.property != <span class="tok-null">null</span> <span class="tok-kw">and</span> index &lt; ast.items.len - <span class="tok-number">1</span>) {</span>
<span class="line" id="L2300">            <span class="tok-kw">try</span> writeBuffered(buffered_writer, <span class="tok-str">&quot;\n&quot;</span>);</span>
<span class="line" id="L2301">        }</span>
<span class="line" id="L2302">    }</span>
<span class="line" id="L2303"></span>
<span class="line" id="L2304">    <span class="tok-kw">try</span> buffered.flush();</span>
<span class="line" id="L2305">}</span>
<span class="line" id="L2306"></span>
<span class="line" id="L2307"><span class="tok-kw">fn</span> <span class="tok-fn">writeAstRecursively</span>(node: *Node, buffered_writer: <span class="tok-kw">anytype</span>, depth: <span class="tok-type">usize</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2308">    <span class="tok-comment">// Don't add an empty line</span>
</span>
<span class="line" id="L2309">    <span class="tok-kw">if</span> (node.property == <span class="tok-null">null</span> <span class="tok-kw">and</span> node.comments.items.len == <span class="tok-number">0</span>) {</span>
<span class="line" id="L2310">        <span class="tok-kw">return</span>;</span>
<span class="line" id="L2311">    }</span>
<span class="line" id="L2312"></span>
<span class="line" id="L2313">    <span class="tok-kw">var</span> i: <span class="tok-type">usize</span> = <span class="tok-number">0</span>;</span>
<span class="line" id="L2314">    <span class="tok-kw">while</span> (i &lt; depth) : (i += <span class="tok-number">1</span>) {</span>
<span class="line" id="L2315">        <span class="tok-kw">try</span> writeBuffered(buffered_writer, <span class="tok-str">&quot;\t&quot;</span>);</span>
<span class="line" id="L2316">    }</span>
<span class="line" id="L2317"></span>
<span class="line" id="L2318">    <span class="tok-kw">if</span> (node.property) |property| {</span>
<span class="line" id="L2319">        <span class="tok-kw">try</span> writeBuffered(buffered_writer, property);</span>
<span class="line" id="L2320">    }</span>
<span class="line" id="L2321"></span>
<span class="line" id="L2322">    <span class="tok-kw">if</span> (node.value) |value| {</span>
<span class="line" id="L2323">        <span class="tok-kw">try</span> writeBuffered(buffered_writer, <span class="tok-str">&quot; = &quot;</span>);</span>
<span class="line" id="L2324">        <span class="tok-kw">try</span> writeBuffered(buffered_writer, value);</span>
<span class="line" id="L2325">    }</span>
<span class="line" id="L2326"></span>
<span class="line" id="L2327">    <span class="tok-kw">if</span> (node.comments.items.len &gt; <span class="tok-number">0</span>) {</span>
<span class="line" id="L2328">        <span class="tok-kw">if</span> (node.property != <span class="tok-null">null</span>) {</span>
<span class="line" id="L2329">            <span class="tok-kw">try</span> writeBuffered(buffered_writer, <span class="tok-str">&quot; &quot;</span>);</span>
<span class="line" id="L2330">        }</span>
<span class="line" id="L2331"></span>
<span class="line" id="L2332">        <span class="tok-kw">try</span> writeBuffered(buffered_writer, <span class="tok-str">&quot;//&quot;</span>);</span>
<span class="line" id="L2333"></span>
<span class="line" id="L2334">        <span class="tok-kw">for</span> (node.comments.items) |comment| {</span>
<span class="line" id="L2335">            <span class="tok-kw">try</span> writeBuffered(buffered_writer, <span class="tok-str">&quot; &quot;</span>);</span>
<span class="line" id="L2336">            <span class="tok-kw">try</span> writeBuffered(buffered_writer, comment);</span>
<span class="line" id="L2337">        }</span>
<span class="line" id="L2338">    }</span>
<span class="line" id="L2339"></span>
<span class="line" id="L2340">    <span class="tok-kw">try</span> writeBuffered(buffered_writer, <span class="tok-str">&quot;\n&quot;</span>);</span>
<span class="line" id="L2341"></span>
<span class="line" id="L2342">    <span class="tok-kw">for</span> (node.children.items) |*child| {</span>
<span class="line" id="L2343">        <span class="tok-kw">try</span> writeAstRecursively(child, buffered_writer, depth + <span class="tok-number">1</span>);</span>
<span class="line" id="L2344">    }</span>
<span class="line" id="L2345">}</span>
<span class="line" id="L2346"></span>
<span class="line" id="L2347"><span class="tok-kw">fn</span> <span class="tok-fn">writeBuffered</span>(buffered_writer: <span class="tok-kw">anytype</span>, string: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2348">    <span class="tok-kw">try</span> buffered_writer.print(<span class="tok-str">&quot;{s}&quot;</span>, .{string});</span>
<span class="line" id="L2349">}</span>
<span class="line" id="L2350"></span>
<span class="line" id="L2351"><span class="tok-kw">test</span> <span class="tok-str">&quot;general&quot;</span> {</span>
<span class="line" id="L2352">    <span class="tok-kw">try</span> testDirectory(<span class="tok-str">&quot;general&quot;</span>, <span class="tok-null">false</span>);</span>
<span class="line" id="L2353">}</span>
<span class="line" id="L2354"></span>
<span class="line" id="L2355"><span class="tok-kw">test</span> <span class="tok-str">&quot;ini_rules&quot;</span> {</span>
<span class="line" id="L2356">    <span class="tok-kw">try</span> testDirectory(<span class="tok-str">&quot;ini_rules&quot;</span>, <span class="tok-null">false</span>);</span>
<span class="line" id="L2357">}</span>
<span class="line" id="L2358"></span>
<span class="line" id="L2359"><span class="tok-kw">test</span> <span class="tok-str">&quot;invalid&quot;</span> {</span>
<span class="line" id="L2360">    <span class="tok-kw">try</span> testDirectory(<span class="tok-str">&quot;invalid&quot;</span>, <span class="tok-null">true</span>);</span>
<span class="line" id="L2361">}</span>
<span class="line" id="L2362"></span>
<span class="line" id="L2363"><span class="tok-kw">test</span> <span class="tok-str">&quot;lua_rules&quot;</span> {</span>
<span class="line" id="L2364">    <span class="tok-kw">try</span> testDirectory(<span class="tok-str">&quot;lua_rules&quot;</span>, <span class="tok-null">false</span>);</span>
<span class="line" id="L2365">}</span>
<span class="line" id="L2366"></span>
<span class="line" id="L2367"><span class="tok-kw">test</span> <span class="tok-str">&quot;mod&quot;</span> {</span>
<span class="line" id="L2368">    <span class="tok-kw">try</span> testDirectory(<span class="tok-str">&quot;mod&quot;</span>, <span class="tok-null">false</span>);</span>
<span class="line" id="L2369">}</span>
<span class="line" id="L2370"></span>
<span class="line" id="L2371"><span class="tok-kw">test</span> <span class="tok-str">&quot;updated&quot;</span> {</span>
<span class="line" id="L2372">    <span class="tok-kw">try</span> testDirectory(<span class="tok-str">&quot;updated&quot;</span>, <span class="tok-null">false</span>);</span>
<span class="line" id="L2373">}</span>
<span class="line" id="L2374"></span>
<span class="line" id="L2375"><span class="tok-kw">fn</span> <span class="tok-fn">testDirectory</span>(<span class="tok-kw">comptime</span> directory_name: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, is_invalid_test: <span class="tok-type">bool</span>) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2376">    <span class="tok-kw">var</span> iterable_tests = <span class="tok-kw">try</span> std.fs.cwd().openIterableDir(<span class="tok-str">&quot;tests/&quot;</span> ++ directory_name, .{});</span>
<span class="line" id="L2377">    <span class="tok-kw">defer</span> iterable_tests.close();</span>
<span class="line" id="L2378"></span>
<span class="line" id="L2379">    <span class="tok-kw">var</span> arena = ArenaAllocator.init(page_allocator);</span>
<span class="line" id="L2380">    <span class="tok-kw">defer</span> arena.deinit();</span>
<span class="line" id="L2381">    <span class="tok-kw">const</span> allocator = arena.allocator();</span>
<span class="line" id="L2382"></span>
<span class="line" id="L2383">    <span class="tok-kw">var</span> tests_walker = <span class="tok-kw">try</span> iterable_tests.walk(allocator);</span>
<span class="line" id="L2384">    <span class="tok-kw">defer</span> tests_walker.deinit();</span>
<span class="line" id="L2385"></span>
<span class="line" id="L2386">    <span class="tok-kw">while</span> (<span class="tok-kw">try</span> tests_walker.next()) |entry| {</span>
<span class="line" id="L2387">        <span class="tok-kw">if</span> (entry.kind == std.fs.File.Kind.directory <span class="tok-kw">and</span> strEql(entry.basename, <span class="tok-str">&quot;input&quot;</span>)) {</span>
<span class="line" id="L2388">            std.debug.print(<span class="tok-str">&quot;\nSubtest '&quot;</span> ++ directory_name ++ <span class="tok-str">&quot;/{s}'&quot;</span>, .{std.fs.path.dirname(entry.path) <span class="tok-kw">orelse</span> <span class="tok-str">&quot;null&quot;</span>});</span>
<span class="line" id="L2389"></span>
<span class="line" id="L2390">            <span class="tok-kw">var</span> test_folder_path_buffer: [MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L2391">            <span class="tok-kw">const</span> test_folder_path = <span class="tok-kw">try</span> entry.dir.realpath(<span class="tok-str">&quot;.&quot;</span>, &amp;test_folder_path_buffer);</span>
<span class="line" id="L2392"></span>
<span class="line" id="L2393">            <span class="tok-kw">const</span> input_folder_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ test_folder_path, <span class="tok-str">&quot;input&quot;</span> });</span>
<span class="line" id="L2394"></span>
<span class="line" id="L2395">            <span class="tok-kw">var</span> tmpdir_output_folder = tmpDir(.{});</span>
<span class="line" id="L2396">            <span class="tok-kw">defer</span> tmpdir_output_folder.cleanup();</span>
<span class="line" id="L2397">            <span class="tok-kw">var</span> tmpdir_output_folder_path_buffer: [MAX_PATH_BYTES]<span class="tok-type">u8</span> = <span class="tok-null">undefined</span>;</span>
<span class="line" id="L2398">            <span class="tok-kw">const</span> tmpdir_output_folder_path = <span class="tok-kw">try</span> tmpdir_output_folder.dir.realpath(<span class="tok-str">&quot;.&quot;</span>, &amp;tmpdir_output_folder_path_buffer);</span>
<span class="line" id="L2399"></span>
<span class="line" id="L2400">            <span class="tok-kw">var</span> diagnostics: Diagnostics = .{};</span>
<span class="line" id="L2401">            convert(input_folder_path, tmpdir_output_folder_path, allocator, &amp;diagnostics) <span class="tok-kw">catch</span> |err| {</span>
<span class="line" id="L2402">                <span class="tok-kw">if</span> (is_invalid_test) {</span>
<span class="line" id="L2403">                    <span class="tok-kw">const</span> error_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ test_folder_path, <span class="tok-str">&quot;expected_error.txt&quot;</span> });</span>
<span class="line" id="L2404"></span>
<span class="line" id="L2405">                    <span class="tok-kw">const</span> error_file = <span class="tok-kw">try</span> std.fs.cwd().openFile(error_path, .{});</span>
<span class="line" id="L2406">                    <span class="tok-kw">defer</span> error_file.close();</span>
<span class="line" id="L2407"></span>
<span class="line" id="L2408">                    <span class="tok-kw">var</span> error_buf_reader = bufferedReader(error_file.reader());</span>
<span class="line" id="L2409">                    <span class="tok-kw">const</span> error_stream = error_buf_reader.reader();</span>
<span class="line" id="L2410">                    <span class="tok-kw">const</span> error_text_crlf = <span class="tok-kw">try</span> error_stream.readAllAlloc(allocator, maxInt(<span class="tok-type">usize</span>));</span>
<span class="line" id="L2411">                    <span class="tok-kw">const</span> error_text = <span class="tok-kw">try</span> crlfToLf(error_text_crlf, allocator);</span>
<span class="line" id="L2412"></span>
<span class="line" id="L2413">                    <span class="tok-kw">try</span> expectEqualStrings(error_text, <span class="tok-builtin">@errorName</span>(err));</span>
<span class="line" id="L2414">                    std.debug.print(<span class="tok-str">&quot; passed&quot;</span>, .{});</span>
<span class="line" id="L2415"></span>
<span class="line" id="L2416">                    <span class="tok-kw">continue</span>;</span>
<span class="line" id="L2417">                } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2418">                    <span class="tok-kw">return</span> err;</span>
<span class="line" id="L2419">                }</span>
<span class="line" id="L2420">            };</span>
<span class="line" id="L2421"></span>
<span class="line" id="L2422">            <span class="tok-kw">if</span> (is_invalid_test) {</span>
<span class="line" id="L2423">                <span class="tok-kw">return</span> <span class="tok-kw">error</span>.InvalidTestDidntReturnError;</span>
<span class="line" id="L2424">            }</span>
<span class="line" id="L2425"></span>
<span class="line" id="L2426">            <span class="tok-kw">const</span> expected_result_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ test_folder_path, <span class="tok-str">&quot;expected_result&quot;</span> });</span>
<span class="line" id="L2427">            <span class="tok-kw">try</span> testDirectoryFiles(test_folder_path, expected_result_path, tmpdir_output_folder_path, allocator);</span>
<span class="line" id="L2428"></span>
<span class="line" id="L2429">            std.debug.print(<span class="tok-str">&quot; passed&quot;</span>, .{});</span>
<span class="line" id="L2430">        }</span>
<span class="line" id="L2431">    }</span>
<span class="line" id="L2432"></span>
<span class="line" id="L2433">    std.debug.print(<span class="tok-str">&quot;\n\n&quot;</span>, .{});</span>
<span class="line" id="L2434">}</span>
<span class="line" id="L2435"></span>
<span class="line" id="L2436"><span class="tok-kw">fn</span> <span class="tok-fn">testDirectoryFiles</span>(test_folder_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, expected_result_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, tmpdir_output_folder_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2437">    <span class="tok-kw">var</span> iterable_expected_result = <span class="tok-kw">try</span> std.fs.cwd().openIterableDir(expected_result_path, .{});</span>
<span class="line" id="L2438">    <span class="tok-kw">defer</span> iterable_expected_result.close();</span>
<span class="line" id="L2439"></span>
<span class="line" id="L2440">    <span class="tok-kw">var</span> expected_result_walker = <span class="tok-kw">try</span> iterable_expected_result.walk(allocator);</span>
<span class="line" id="L2441">    <span class="tok-kw">defer</span> expected_result_walker.deinit();</span>
<span class="line" id="L2442"></span>
<span class="line" id="L2443">    <span class="tok-kw">while</span> (<span class="tok-kw">try</span> expected_result_walker.next()) |expected_result_entry| {</span>
<span class="line" id="L2444">        <span class="tok-kw">if</span> (expected_result_entry.kind == std.fs.File.Kind.file) {</span>
<span class="line" id="L2445">            <span class="tok-kw">const</span> expected_file_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ expected_result_path, expected_result_entry.path });</span>
<span class="line" id="L2446"></span>
<span class="line" id="L2447">            <span class="tok-kw">const</span> expected_file = <span class="tok-kw">try</span> std.fs.cwd().openFile(expected_file_path, .{});</span>
<span class="line" id="L2448">            <span class="tok-kw">defer</span> expected_file.close();</span>
<span class="line" id="L2449"></span>
<span class="line" id="L2450">            <span class="tok-kw">var</span> expected_buf_reader = bufferedReader(expected_file.reader());</span>
<span class="line" id="L2451">            <span class="tok-kw">const</span> expected_stream = expected_buf_reader.reader();</span>
<span class="line" id="L2452">            <span class="tok-kw">const</span> expected_text_crlf = <span class="tok-kw">try</span> expected_stream.readAllAlloc(allocator, maxInt(<span class="tok-type">usize</span>));</span>
<span class="line" id="L2453">            <span class="tok-kw">const</span> expected_text = <span class="tok-kw">try</span> crlfToLf(expected_text_crlf, allocator);</span>
<span class="line" id="L2454"></span>
<span class="line" id="L2455">            <span class="tok-kw">const</span> output_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ tmpdir_output_folder_path, expected_result_entry.path });</span>
<span class="line" id="L2456">            <span class="tok-kw">const</span> output_file = <span class="tok-kw">try</span> std.fs.cwd().openFile(output_path, .{});</span>
<span class="line" id="L2457">            <span class="tok-kw">defer</span> output_file.close();</span>
<span class="line" id="L2458"></span>
<span class="line" id="L2459">            <span class="tok-kw">var</span> output_buf_reader = bufferedReader(output_file.reader());</span>
<span class="line" id="L2460">            <span class="tok-kw">const</span> output_stream = output_buf_reader.reader();</span>
<span class="line" id="L2461">            <span class="tok-kw">const</span> output_text_crlf = <span class="tok-kw">try</span> output_stream.readAllAlloc(allocator, maxInt(<span class="tok-type">usize</span>));</span>
<span class="line" id="L2462">            <span class="tok-kw">const</span> output_text = <span class="tok-kw">try</span> crlfToLf(output_text_crlf, allocator);</span>
<span class="line" id="L2463"></span>
<span class="line" id="L2464">            <span class="tok-kw">const</span> ext = extension(expected_result_entry.basename);</span>
<span class="line" id="L2465">            <span class="tok-kw">if</span> (strEql(ext, <span class="tok-str">&quot;.png&quot;</span>) <span class="tok-kw">or</span> strEql(ext, <span class="tok-str">&quot;.flac&quot;</span>)) {</span>
<span class="line" id="L2466">                <span class="tok-kw">if</span> (indexOfDiff(<span class="tok-type">u8</span>, expected_text, output_text)) |diff_index| {</span>
<span class="line" id="L2467">                    <span class="tok-kw">const</span> unequal_copy_path = <span class="tok-kw">try</span> join(allocator, &amp;.{ test_folder_path, expected_result_entry.basename });</span>
<span class="line" id="L2468"></span>
<span class="line" id="L2469">                    std.debug.print(<span class="tok-str">&quot;\nUnequal file at index {} is '{s}'; copying it to `{s}`\n&quot;</span>, .{ diff_index, output_path, unequal_copy_path });</span>
<span class="line" id="L2470">                    <span class="tok-kw">try</span> copyFileAbsolute(output_path, unequal_copy_path, .{});</span>
<span class="line" id="L2471"></span>
<span class="line" id="L2472">                    <span class="tok-kw">return</span> <span class="tok-kw">error</span>.unequalFiles;</span>
<span class="line" id="L2473">                }</span>
<span class="line" id="L2474">            } <span class="tok-kw">else</span> {</span>
<span class="line" id="L2475">                <span class="tok-kw">try</span> expectEqualStrings(expected_text, output_text);</span>
<span class="line" id="L2476">            }</span>
<span class="line" id="L2477">        }</span>
<span class="line" id="L2478">    }</span>
<span class="line" id="L2479">}</span>
<span class="line" id="L2480"></span>
<span class="line" id="L2481"><span class="tok-kw">pub</span> <span class="tok-kw">fn</span> <span class="tok-fn">beautifyLua</span>(output_folder_path: []<span class="tok-kw">const</span> <span class="tok-type">u8</span>, allocator: Allocator) !<span class="tok-type">void</span> {</span>
<span class="line" id="L2482">    std.log.info(<span class="tok-str">&quot;Beautifying Lua...\n&quot;</span>, .{});</span>
<span class="line" id="L2483">    <span class="tok-comment">// TODO: Do we want to compile this from source?</span>
</span>
<span class="line" id="L2484">    <span class="tok-kw">const</span> argv = [_][]<span class="tok-kw">const</span> <span class="tok-type">u8</span>{ getStyluaPath(), output_folder_path };</span>
<span class="line" id="L2485">    <span class="tok-kw">const</span> result = <span class="tok-kw">try</span> std.ChildProcess.exec(.{ .argv = &amp;argv, .allocator = allocator });</span>
<span class="line" id="L2486">    _ = result;</span>
<span class="line" id="L2487">}</span>
<span class="line" id="L2488"></span>
<span class="line" id="L2489"><span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">getFfmpegPath</span>() []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L2490">    <span class="tok-kw">return</span> <span class="tok-str">&quot;dependency_executables/ffmpeg/windows/ffmpeg.exe&quot;</span>;</span>
<span class="line" id="L2491">}</span>
<span class="line" id="L2492"></span>
<span class="line" id="L2493"><span class="tok-kw">inline</span> <span class="tok-kw">fn</span> <span class="tok-fn">getStyluaPath</span>() []<span class="tok-kw">const</span> <span class="tok-type">u8</span> {</span>
<span class="line" id="L2494">    <span class="tok-kw">return</span> <span class="tok-str">&quot;dependency_executables/stylua/windows/stylua.exe&quot;</span>;</span>
<span class="line" id="L2495">}</span>
<span class="line" id="L2496"></span>
</code></pre></body>
</html>